{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/event_loop.png","path":"img/event_loop.png","modified":0,"renderable":0},{"_id":"source/img/flex/1.jpg","path":"img/flex/1.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/2.jpg","path":"img/flex/2.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/6.jpg","path":"img/flex/6.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/3.jpg","path":"img/flex/3.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/7.jpg","path":"img/flex/7.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/8.jpg","path":"img/flex/8.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/5.jpg","path":"img/flex/5.jpg","modified":0,"renderable":0},{"_id":"source/img/flex/4.jpg","path":"img/flex/4.jpg","modified":0,"renderable":0},{"_id":"source/img/roc/2.gif","path":"img/roc/2.gif","modified":0,"renderable":0},{"_id":"source/img/roc/1.png","path":"img/roc/1.png","modified":0,"renderable":0},{"_id":"source/img/flex/9.jpg","path":"img/flex/9.jpg","modified":0,"renderable":0},{"_id":"source/img/roc/3.png","path":"img/roc/3.png","modified":0,"renderable":0},{"_id":"source/img/roc/4.gif","path":"img/roc/4.gif","modified":0,"renderable":0},{"_id":"source/img/roc/5.png","path":"img/roc/5.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/zhudi.jpg","path":"uploads/zhudi.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"source/img/3.jpg","path":"img/3.jpg","modified":0,"renderable":0},{"_id":"source/img/4.jpg","path":"img/4.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/img/2.jpg","path":"img/2.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"526ec2e5b043b2bccf894db6e7ec7e8d1b5f07a9","modified":1463494631609},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1462451774576},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1462451774577},{"_id":"themes/next/.gitignore","hash":"63d003fa46cf9665b4dab1786f9dc694812a5a79","modified":1462451774579},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1462451774579},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1462451774580},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1462451774580},{"_id":"themes/next/gulpfile.coffee","hash":"4e8c1082fa82e383494ff5b5963b7936d9c7bb2e","modified":1462451774583},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1462451774581},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1462451774581},{"_id":"themes/next/bower.json","hash":"da39b00fcdf2e7a42af412de0a4d3617cc6d7084","modified":1462451774583},{"_id":"source/_drafts/jquery事件.md","hash":"88914d2202735206b1785d8c2caab12c4d325f1c","modified":1466516007206},{"_id":"themes/next/_config.yml","hash":"08a93f6646e4a8a554bf511423116f8829597ae4","modified":1464098944824},{"_id":"source/_drafts/jquery中的prop和attr.md","hash":"49bcbc6df9b45e700f32c18c00359f6301764667","modified":1468941161156},{"_id":"themes/next/package.json","hash":"95eaba1607544965e432d56406bae391dd11bcbb","modified":1462451774626},{"_id":"source/_drafts/决策树算法学习.md","hash":"772cd5743186208da62b962dfa8e46da61b1a634","modified":1463223173802},{"_id":"source/_drafts/生活启示录.md","hash":"0438a22a8de07860ed66c65aab6be355e78f1482","modified":1467733248338},{"_id":"source/_posts/JavaScript事件.md","hash":"8cda3022d092cc3f4d3338d250ef06b84632aaa8","modified":1468934452393},{"_id":"source/_posts/PCA.md","hash":"daa092bef65ba6d81e488272612339b884dc7ab7","modified":1466515746906},{"_id":"source/_drafts/mongodb.md","hash":"c1011c9fc8fd2e6b817b6f1340e41fc810a83ec8","modified":1472913184808},{"_id":"source/_posts/CSS3多列布局.md","hash":"e32bfe2bcc0a5f2e943cfaba9d6f9796808b0135","modified":1464096055496},{"_id":"source/_posts/BFC.md","hash":"c07e1fc90c9a6f6c64710d04b0bcc00a4a711df5","modified":1463494597614},{"_id":"source/_posts/ROC.md","hash":"7444dd242b64540564bdee4173ec3c1714830021","modified":1465910170684},{"_id":"source/_drafts/makeArray.md","hash":"25a8ee5611aa74447875657d735ac0467a423ec5","modified":1468766466439},{"_id":"source/_posts/css3选择器整理.md","hash":"d84c86a820b7f8180e0463bca4c5b1d3c26b926e","modified":1462459164417},{"_id":"source/_posts/Variance.md","hash":"52db87272fb129823495b34f889c10fd36e11460","modified":1468758339699},{"_id":"source/_posts/ajax.md","hash":"5c000b62a74f4bea8fb935f53972b99a3f3db6ff","modified":1469959992056},{"_id":"source/_posts/css3动画.md","hash":"c1df0d2f2b75bca12ed28b3cd7b0448df25e62fa","modified":1469018107147},{"_id":"source/_posts/cookie.md","hash":"90ea319c8dbaa83538e1387e583ddd28621d99fa","modified":1468934452393},{"_id":"source/_posts/css3变形.md","hash":"b858ccf8a638f5b5fd4498500028e51b9050349c","modified":1464191095278},{"_id":"source/_posts/git回滚.md","hash":"c51ee790c312177ef08ce9901dc011561656f560","modified":1472912915960},{"_id":"source/_posts/flex.md","hash":"7915a18b3f24976d8438fa31cd5c48c904e7cc2a","modified":1469626878387},{"_id":"source/_posts/bt.md","hash":"9348a3f8bae5647943d8752e81cd41db48359485","modified":1465997509235},{"_id":"source/_posts/heapSort.md","hash":"6dcc67ac248906c78fb8a42211bf34494e18c0fc","modified":1465907638919},{"_id":"source/_posts/gulp.md","hash":"9d078dde32f95f6522caa4696f88c91b3222f1a8","modified":1469624618449},{"_id":"source/_posts/inline-block.md","hash":"1cd842f2e90429b3c8d29d4d4551e6988db77f4a","modified":1469624618449},{"_id":"source/_posts/each.md","hash":"6664f6e0a1d247e75243c6c530a38b45d08d11e4","modified":1466258021170},{"_id":"source/_posts/html标签.md","hash":"a741fa9edf56a86ed6d0bb3c7dcb4341a6921737","modified":1463223173786},{"_id":"source/_posts/javascript创建对象及继承.md","hash":"e79be1dc032d37ed81f3bd49f53dc5dc3fa6ddb6","modified":1472912915963},{"_id":"source/_posts/mergeSort.md","hash":"3be15866c1872421e5a32045d4ee948a5502a2ed","modified":1465907638920},{"_id":"source/_posts/padding-margin.md","hash":"3e35c647408bec1076fcbee8fd1e38216f24f3ff","modified":1475073313470},{"_id":"source/_posts/npm.md","hash":"b0b1e45302f2403f6388c1615a3d438e1d6d3638","modified":1469624618464},{"_id":"source/_posts/property与attribute.md","hash":"c03be7c3105743552889ea39b792b38977751ecf","modified":1469018107147},{"_id":"source/_posts/pushstate.md","hash":"c1e2fcd8867988155dacaa0e4744db0c4a4d31e9","modified":1464096055496},{"_id":"source/_posts/queue.md","hash":"68d712debcfb97aede37c4bedb424e2e0bbd23aa","modified":1468934452393},{"_id":"source/_posts/jqueryMerge.md","hash":"0a914ba5f5483dea28ae20a42db3440383aa9575","modified":1468763188200},{"_id":"source/_posts/svm.md","hash":"1589dde54427a27d86c9c089b9087091c82d73a7","modified":1465907638922},{"_id":"source/_posts/java栈方法.md","hash":"4900bd2c202890187ddbe865c287816692f8ec22","modified":1466258021170},{"_id":"source/_posts/this.md","hash":"7a7082b2b57cf1d5c13ae199cd8f38da097572fb","modified":1469947178846},{"_id":"source/_posts/setTimeout.md","hash":"00483197b043e454ebf3b4a467d2d695a41e9e56","modified":1472912915965},{"_id":"source/_posts/javascript作用域.md","hash":"3d91ba80452c2d9d087364e88b7ec9547b1e8823","modified":1469947189134},{"_id":"source/_posts/关门山.md","hash":"879113bb5991a2712c7f4d53cd059c58cec7d78e","modified":1462455493740},{"_id":"source/_posts/doctype.md","hash":"9659415ed560d7853bd7c4768ca24204abf4cc19","modified":1473264341183},{"_id":"source/_posts/数据库.md","hash":"79ab41af1e1fec19dbebd81b7960be202507cc47","modified":1464096055496},{"_id":"source/_posts/gitignore配置.md","hash":"25ff5e19c30924e24446af33cd534380ecbfa92a","modified":1462459175570},{"_id":"source/_posts/正则表达式.md","hash":"ae7fa8936e0e6a7d0495556f2a3c7e5a1eba31a1","modified":1469711711140},{"_id":"source/_posts/transition.md","hash":"6b4920fad70aaf1735c10e5c52b4ec96a8184211","modified":1462459070029},{"_id":"source/_posts/思考.md","hash":"4f8cf74caafe22ba986d24dfee05d0b6ab710304","modified":1464097668185},{"_id":"source/_posts/栈方法1.md","hash":"b7114b604e44d4eea59da93b07649c3b1a432a17","modified":1466258021185},{"_id":"source/categories/index.md","hash":"757902a3e899c80e32a2a52bf99865bd17a244b9","modified":1462451774453},{"_id":"source/_posts/将本地项目首次提交到远程git上遇到的问题.md","hash":"6d923be2350c07cfc0efb2dc46b57024ff5c0e49","modified":1469018107147},{"_id":"source/_posts/块级元素和内联元素.md","hash":"57b0e34fb7ca5c705a0e1b993294f78928f4c996","modified":1469711711140},{"_id":"source/_posts/配置Hexo.md","hash":"860f82838449053c0ef56531c27a82f4a395b348","modified":1462459155302},{"_id":"source/_posts/部署到git上面时报错.md","hash":"09d6852e9e1cb829700ba1f9dfbd0447ca0940ff","modified":1462459139700},{"_id":"source/_posts/类数组.md","hash":"36c412e76e6f891e0da9344c495f2ccf9b9b966e","modified":1468941233958},{"_id":"source/tags/index.md","hash":"81e6ae9778247b8fb8c96b20c0fc4ff09b270110","modified":1462451774454},{"_id":"source/img/event_loop.png","hash":"991109df2ef5ae00d95568a69200baa1775ed399","modified":1472912915967},{"_id":"source/_posts/广度优先遍历.md","hash":"2c3e84f73d54de47b67efd5ecc6b731be89dc1a7","modified":1466266282019},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1462451774585},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1462451774584},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1462451774585},{"_id":"themes/next/languages/id.yml","hash":"19537c8bae42c4c2e7d06a64537e8dfd503b7e19","modified":1462451774586},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1462451774587},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1462451774586},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1462451774589},{"_id":"themes/next/languages/zh-Hans.yml","hash":"23b45e77c1846c9457b98c745a60a9461678c389","modified":1462451774589},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1462451774588},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1462451774590},{"_id":"themes/next/layout/_layout.swig","hash":"1138b849e1240249480849cc2b6c6d09b28207a5","modified":1462451774592},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1462451774624},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1462451774590},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1462451774624},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1462451774623},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"2692e36cc35b1594530981e7727771f601720a43","modified":1462451774578},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1462451774577},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1462451774627},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1462451774625},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1462451774625},{"_id":"themes/next/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1462451774758},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1462451774758},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1462451774759},{"_id":"source/img/flex/1.jpg","hash":"e29ffb5f65f40b3eddf545582c0e86631bbb0fce","modified":1463234739255},{"_id":"source/img/flex/2.jpg","hash":"3846a7211365e4007b1ae30ca18f940513569ccb","modified":1463234774362},{"_id":"source/img/flex/6.jpg","hash":"57168956bfe6f9ddeba2428d7b6ac3dcbaf1c7cc","modified":1463235425402},{"_id":"source/img/flex/3.jpg","hash":"00520c0855634ca4a12f66a4949d0916a0a84ef8","modified":1463234703027},{"_id":"source/img/flex/7.jpg","hash":"eaeeb9c69a9d0c79e3c41370e6fc057517799962","modified":1463236300319},{"_id":"source/img/flex/8.jpg","hash":"f83a7c1d4f6696cb40830da32493261e844591a1","modified":1463240132377},{"_id":"source/img/flex/5.jpg","hash":"09390cdaaa31e944970f3c8757f4bdfe203649ce","modified":1463235211785},{"_id":"source/img/flex/4.jpg","hash":"8ec29b5f3380801ab3c76ccebc579e2bcbf5bec7","modified":1463235193097},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1462451774623},{"_id":"source/img/roc/2.gif","hash":"49789ec23b540cad49535da38d39e11965495c3f","modified":1465909725640},{"_id":"source/img/roc/1.png","hash":"9e71cba98b2cf1655060dcb0cd0e0d2d9e9f4740","modified":1465908836385},{"_id":"source/img/flex/9.jpg","hash":"02afb6cd53c1ceb2dcd715de3f8a2e318f7cb49c","modified":1463240620717},{"_id":"source/img/roc/3.png","hash":"e9133ff72ab5d0cdaa31566307ff76936e73a61f","modified":1465909883750},{"_id":"themes/next/layout/_macro/post.swig","hash":"74e316a693166969af1de1eb23cd8077dc922963","modified":1462451774593},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"8cd78f0f934318524393fcb26dbdff9be4df70b9","modified":1462451774595},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"d569af20d20a960d534a5b60f90c20fef519d351","modified":1462451774595},{"_id":"themes/next/layout/_partials/comments.swig","hash":"325dd5923d845a539fc0524ca72ce40edd1e516a","modified":1462451774596},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1462451774597},{"_id":"source/img/roc/4.gif","hash":"23cf74e8026467c4dd18c2fd020187291cad780a","modified":1465909988067},{"_id":"themes/next/layout/_macro/reward.swig","hash":"05cad11b3efcb8b7e74677bd7c13ad53d268476a","modified":1462451774594},{"_id":"themes/next/layout/_partials/footer.swig","hash":"27669118b957e8a39d843b63dddf561c9d62b336","modified":1462451774598},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1462451774600},{"_id":"themes/next/layout/_partials/head.swig","hash":"d5eadfe13cd28aa4626a1b17e18deaafe0a0452e","modified":1462451774598},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1462451774601},{"_id":"themes/next/layout/_partials/header.swig","hash":"b3f4f07f03bedd615039934b44d552b91e2a4a1d","modified":1462451774600},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c5db707b46eac6a5df1d2a77f8556945a66fd181","modified":1462451774607},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1462451774607},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1462451774608},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c9d45628330ce8bf5fbe71c9f131c7d75334c1c4","modified":1462451774622},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774692},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1462451774628},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1462451774629},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1462451774629},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1462451774593},{"_id":"source/img/roc/5.png","hash":"72a935068f4b2e1e64b2d0f0d1da65a4247ca58b","modified":1465909999792},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774610},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774610},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1462451774693},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1462451774691},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1462451774694},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1462451774695},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1462451774695},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462451774698},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1462451774697},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462451774698},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1462451774696},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1462451774697},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1462451774699},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1462451774700},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1462451774602},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1462451774602},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1462451774603},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1462451774604},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"b83439cfca7b2c81846cd35596e27381ea4045e9","modified":1462451774599},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1462451774700},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1462451774609},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1462451774612},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1462451774617},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1462451774604},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1462451774606},{"_id":"themes/next/source/uploads/zhudi.jpg","hash":"b4d438b5b8d6b69d2fc8458bbac13b2563680b0e","modified":1462451774708},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"5bd98c26cc188a2a30504d1330a0eaae34034db0","modified":1462451774620},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1462451774611},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"4a5c6df1579a4ca72ed17f7dbd6d16a509aa7dc8","modified":1462451774621},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"aebc73513c9cbbbbda2935e2eb18e09bb1c24bf8","modified":1462451774620},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774688},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774690},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1462451774621},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1462451774605},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774670},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774671},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462451774673},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1462451774670},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1462451774688},{"_id":"themes/next/source/css/_variables/default.styl","hash":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1462451774690},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ea6e519065702dfdb1dc299f85411b9ee2bcf4ce","modified":1462451774689},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"6da593f19a9c8e76b43bc05172923d82b2aefa03","modified":1462451774689},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1462451774720},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1462451774722},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1462451774726},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1462451774726},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1462451774727},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1462451774727},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1462451774742},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1462451774725},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1462451774744},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1462451774745},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1462451774745},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1462451774746},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1462451774747},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1462451774747},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1462451774750},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1462451774751},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1462451774721},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1462451774722},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1462451774755},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1462451774757},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1462451774756},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1462451774701},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1462451774702},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1462451774703},{"_id":"themes/next/source/js/src/utils.js","hash":"14521498ba62a9a4050b86fb1eae0babd5b88c8a","modified":1462451774706},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1462451774671},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1462451774704},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1462451774703},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1462451774613},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"096e7a6958b3bcacaa94361266832871ccb989c0","modified":1462451774615},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1462451774615},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1462451774706},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1462451774616},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1462451774616},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1462451774672},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"24105e62d7f26946907fa14cd02589f899bf8122","modified":1462451774613},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1462451774618},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"2338be12ffee58bc08197cb9da8aaf31737aaf5c","modified":1462451774619},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1462451774743},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1462451774631},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1462451774633},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1462451774633},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1462451774657},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1462451774665},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"302fca2d38d0175f5b5c7c42bc80b5a87404a50d","modified":1462451774667},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1462451774668},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1462451774669},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1462451774669},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"99487a9e1acb05eedbefa36eb6f4a606fe85f20c","modified":1463494597614},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1462451774674},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1462451774677},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1462451774675},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1462451774632},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1462451774643},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1462451774675},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"13af2fb21fabfc4df4b577ce5363e13d03daff71","modified":1462451774681},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1462451774680},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"f70fa81275eb4e0ea5e5a740b7a35539c6ffa9ba","modified":1462451774682},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c9875c010bebd77b4f59d459a10455fceb0a66a1","modified":1462451774683},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1462451774683},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5187512cc4b2ce095230928c7046e0b26c3897bd","modified":1462451774678},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1462451774676},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1462451774677},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1462451774685},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1462451774686},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1462451774681},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1462451774679},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"2182a6da3434a6fd4d03ab1592c645d3d3c88500","modified":1462451774684},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"9887bd3894db5394c1e64e800afaae55f47e8dd0","modified":1462451774685},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1462451774710},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1462451774711},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1462451774712},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1462451774713},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1462451774712},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1462451774718},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1462451774709},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1462451774719},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1462451774724},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1462451774724},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1462451774729},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1462451774720},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1462451774731},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1462451774729},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1462451774741},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1462451774749},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"a9d064d600ee35acd66508167e1ac8c6cfdbdcd8","modified":1462451774705},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1462451774733},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1462451774740},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1462451774734},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1462451774749},{"_id":"source/img/3.jpg","hash":"6fedbd33722bfa225714020cac3a0dc959ecbe4b","modified":1462453806501},{"_id":"source/img/4.jpg","hash":"39a4de4757a664bc8037c1c0f06b07fb08471928","modified":1462453879319},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1462451774634},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1462451774636},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ecd6b77afaeeb5b8674e5a62f2ab204004082fab","modified":1463494597614},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1462451774636},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1462451774638},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1462451774637},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4f7dfc2826a95a0d571976d9084b7e7175d99b0f","modified":1462451774639},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1462451774635},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"12e366f04497e3f44388fd40111a03e02f7c26af","modified":1462451774639},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1462451774640},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1462451774641},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1462451774641},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1462451774642},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1462451774645},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1462451774646},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"2bc3e33fdfbcf348c96ca60598f629dcd7ba3617","modified":1462451774647},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1462451774754},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1462451774648},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1462451774645},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"758d64ad65f718537ab5bfe5592a626abc40987e","modified":1462451774650},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1462451774644},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1462451774652},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1462451774650},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"70407054dbb5180c69e50ea2655d32835494394e","modified":1462451774652},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1462451774654},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1462451774653},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ca20affaeaf33c0904cb6356864fc6b78e95f447","modified":1462451774646},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"ec23bb0dacd150588d871e177bb69ad4d35b2307","modified":1462451774651},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1462451774655},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"99c4b7d1459569cda394c733845d368008a180bf","modified":1462451774657},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1462451774654},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1462451774659},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1462451774655},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1462451774660},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1462451774656},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1462451774661},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1462451774658},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1462451774663},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1462451774660},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"7bd182d918f3117335a5ee87a1b544e6d2b54d7d","modified":1462451774664},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"7f7e9df15148608a9c29326dd880d8e8e8efc0ec","modified":1462451774662},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1462451774679},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1462451774663},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"dcb4548d07cbb38b645b1753cf3ee7157e16921a","modified":1462451774664},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1462451774714},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1462451774715},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1462451774715},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1462451774716},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1462451774739},{"_id":"source/img/2.jpg","hash":"ed51490bf3eb63a261de74886d43694623fff3b1","modified":1462453781727},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1462451774648},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1462451774717},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1462451774717},{"_id":"source/img/1.jpg","hash":"1ee536df019f16546a28515c962ecc0c2e8604e0","modified":1462453822697},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1462451774737},{"_id":"public/categories/index.html","hash":"095c153fd944b6551206ea72987f73c85219cf62","modified":1475073338512},{"_id":"public/tags/index.html","hash":"cd2e6cbcd49cf803513d8d75118f47c7268e9f62","modified":1475073338574},{"_id":"public/2016/09/07/doctype/index.html","hash":"bcc0992180cf248f603cc507817a061b5935d012","modified":1475073338574},{"_id":"public/2016/08/01/setTimeout/index.html","hash":"e73ad89e12a54e21178ae1d9703b68f5b62b7d5b","modified":1475073338574},{"_id":"public/2016/07/31/javascript作用域/index.html","hash":"2334729b3c15047ea6a6f9911381e46fb9bd0555","modified":1475073338574},{"_id":"public/2016/09/28/padding-margin/index.html","hash":"19d7a71396da3f4ccc7eb3a8641b72c0a206ef27","modified":1475073338730},{"_id":"public/2016/07/28/git回滚/index.html","hash":"b2ee4f888b23173eb21e51aebfca0dd153a3355e","modified":1475073338730},{"_id":"public/2016/07/28/正则表达式/index.html","hash":"6666bb085663140e067505efadcb2e284115782b","modified":1475073338730},{"_id":"public/2016/07/27/inline-block/index.html","hash":"ac3acfa2cf8873b8a1890a1527a7f4f5918bc049","modified":1475073338730},{"_id":"public/2016/07/26/npm/index.html","hash":"0185213b988090295c29ddbb2ad887c48cf7c21b","modified":1475073338730},{"_id":"public/2016/07/20/ajax/index.html","hash":"abf7ba6c7d69a6b3f76c93c38791c77c987fa1ee","modified":1475073338730},{"_id":"public/2016/07/17/jqueryMerge/index.html","hash":"dac0ddc5111a3ef0d22ff91873e3cb99b7c4a8c6","modified":1475073338730},{"_id":"public/2016/07/17/this/index.html","hash":"3e8c4b882ad73104ff05fe35b47d9e5077961c64","modified":1475073338730},{"_id":"public/2016/06/19/广度优先遍历/index.html","hash":"aefce4abe96cbb91153008f55afd21dcc9aef859","modified":1475073338730},{"_id":"public/2016/06/18/queue/index.html","hash":"39be9ef9c0bc53173ef1f0a0a431a78e6d2f29c2","modified":1475073338730},{"_id":"public/2016/06/17/栈方法1/index.html","hash":"a7c67579e5de0b17389d44433a41727ca5dbe832","modified":1475073338730},{"_id":"public/2016/06/17/java栈方法/index.html","hash":"86bfc7133cb82eb40f5f30b4f8a68d68c3e165c2","modified":1475073338730},{"_id":"public/2016/06/12/svm/index.html","hash":"9d3a61470bb219e3436cc935b13e71d5c9b00184","modified":1475073338730},{"_id":"public/2016/05/27/mergeSort/index.html","hash":"59f03577c4b12e58b811c9c3937e41016720d890","modified":1475073338730},{"_id":"public/2016/05/26/heapSort/index.html","hash":"c9705b5a36987b31b7b7567934744e9bbc995173","modified":1475073338730},{"_id":"public/2016/05/25/css3变形/index.html","hash":"4d582df90fecdb431be88b96dd475644c85769f5","modified":1475073338730},{"_id":"public/2016/04/27/部署到git上面时报错/index.html","hash":"9a8ae2e2bc101a5fe1d6490bf3bcf6cb6d1d039e","modified":1475073338730},{"_id":"public/2016/04/27/gitignore配置/index.html","hash":"6804f0a0ba58b280676595998de379be58336161","modified":1475073338730},{"_id":"public/2016/04/26/配置Hexo/index.html","hash":"12e5112434740050502f06add564f92932497806","modified":1475073338730},{"_id":"public/2014/10/18/关门山/index.html","hash":"998a966e45421a088491014de8e857c65a7a87ee","modified":1475073338730},{"_id":"public/archives/page/5/index.html","hash":"64505a4b2446f1b5b2b47be61057f928d5caa3e1","modified":1475073338730},{"_id":"public/archives/2014/10/index.html","hash":"eb4ba5a8cb4212373cb6e7ac4c4a4d616b7661a3","modified":1475073338730},{"_id":"public/archives/2016/page/5/index.html","hash":"c45fb4a0ad9b9a60f284acb8b0527e4a9e60bb16","modified":1475073338730},{"_id":"public/archives/2016/03/index.html","hash":"3c7a556da09ac61a6c874b2f3883f475367d4692","modified":1475073338730},{"_id":"public/archives/2014/index.html","hash":"dc5ad23cbf966a47ef1ff351f358fbaef561b5d2","modified":1475073338730},{"_id":"public/archives/2016/05/page/2/index.html","hash":"680692aa6934cdffd52063624ad086147b6c3daf","modified":1475073338730},{"_id":"public/archives/2016/08/index.html","hash":"9d72dfc27e2b3f27882ea2eec70bb736b7a35b45","modified":1475073338730},{"_id":"public/archives/2016/09/index.html","hash":"94ec40ce5800b2f423a1a2d8432363b21f34154d","modified":1475073338730},{"_id":"public/categories/学习笔记/page/4/index.html","hash":"6500928fb0dd2f414db0c8d167436d52b7c9556d","modified":1475073338730},{"_id":"public/categories/学习笔记/数据挖掘/index.html","hash":"b3e10bfd78628b9c96d861abadb89923f4c9dda0","modified":1475073338730},{"_id":"public/categories/学习笔记/前端学习/page/3/index.html","hash":"c35d3182806c7745066f2423acf84d67fde5b810","modified":1475073338730},{"_id":"public/categories/学习笔记/git学习/index.html","hash":"5a96f031c96b6fdf47ec8e09073ae93590742298","modified":1475073338730},{"_id":"public/categories/学习笔记/数据结构/index.html","hash":"c237b487e36935ceca7eed685c0878ad8079156e","modified":1475073338730},{"_id":"public/categories/学习笔记/javascript/index.html","hash":"5f50408ff080067b18c15b172e3392a6b8958b94","modified":1475073338730},{"_id":"public/categories/学习笔记/java/index.html","hash":"8446ea3c33c70da6abe06fae1299fd8c1876d7a9","modified":1475073338730},{"_id":"public/categories/随手日记/index.html","hash":"21eccb4bd5ae1ee259eb474bd8fe19b83f81969d","modified":1475073338730},{"_id":"public/archives/2016/04/index.html","hash":"e0c70401b74208b1a5224facf506b7fbe3fccd25","modified":1475073338730},{"_id":"public/categories/学习笔记/hexo学习/index.html","hash":"da37f3f7954c161f5769b4c573b1b75724280b95","modified":1475073338730},{"_id":"public/tags/数据挖掘/index.html","hash":"d14eae81684af12335ad3721701f62c6fede7b46","modified":1475073338730},{"_id":"public/tags/javascript事件/index.html","hash":"ef9a2ed5abef12b02b4014cfae3ff35bf38f9647","modified":1475073338730},{"_id":"public/tags/降维/index.html","hash":"06925c0a42e1f0d21603c018fe91642be008e321","modified":1475073338730},{"_id":"public/tags/css3/index.html","hash":"1556302aeb3ffb5c16f60daafcda134114b9f2a4","modified":1475073338746},{"_id":"public/archives/2016/07/page/2/index.html","hash":"84fe7178b3d09f296792a50337857189f359e03e","modified":1475073338746},{"_id":"public/tags/BFC/index.html","hash":"4d087ff1deca9547380ab97228045b4ff4ba7c16","modified":1475073338746},{"_id":"public/tags/算法评价指标/index.html","hash":"f14e13c0fa1cdab712889fe635989e9d0eed5af9","modified":1475073338746},{"_id":"public/tags/jQuery源码/index.html","hash":"cb76936d2f623bb3f1dc3ab291f821d531e8c1e1","modified":1475073338746},{"_id":"public/tags/css3选择器/index.html","hash":"47e2d85d1a6d92048316aae99f1fc46cea931c03","modified":1475073338746},{"_id":"public/tags/ajax/index.html","hash":"7ca02bcbbcf1bee536ea74d3d4a5df4251c84f9c","modified":1475073338746},{"_id":"public/tags/CSS3/index.html","hash":"74577167522761f64206844536132b0b3b0846cd","modified":1475073338746},{"_id":"public/tags/CSS3动画/index.html","hash":"acc6013b60fcee99724da16215849b94341c9e59","modified":1475073338746},{"_id":"public/tags/cookie/index.html","hash":"e6e30a46639d1ff72f63ddcae90d07d757e73332","modified":1475073338746},{"_id":"public/tags/css3变形/index.html","hash":"df7ded07da60b72d1454c408faf1b6c63a938dd9","modified":1475073338746},{"_id":"public/tags/git/index.html","hash":"9fdec7772c42fa9bb2225e586d8b7fbe05070a6e","modified":1475073338746},{"_id":"public/tags/FlexBox/index.html","hash":"667f33300b8bd1fcae6ee85b1abc8b52086074ed","modified":1475073338746},{"_id":"public/tags/数据结构/index.html","hash":"c4ef965eaaba20f63d54d0579483c8f62307fc7d","modified":1475073338746},{"_id":"public/tags/二叉树遍历/index.html","hash":"4cff7dc7f662b41d393b428773ac4a185a700e83","modified":1475073338746},{"_id":"public/tags/排序算法/index.html","hash":"6cf891ccc76a110c31c2727dad8504fa39591ba5","modified":1475073338746},{"_id":"public/tags/css/index.html","hash":"1d2458a8433a5b7043ba3cd22b9607cf12d94cf8","modified":1475073338746},{"_id":"public/tags/inline-block/index.html","hash":"017a557868e40381a8ace20d9102e5e69072454a","modified":1475073338746},{"_id":"public/tags/jquery/index.html","hash":"a11de3fa74a206eec549470d36e5a2fd45a8e153","modified":1475073338746},{"_id":"public/categories/学习笔记/数据库/index.html","hash":"998dfbfc63f7de94dccb25db176633a077ad007a","modified":1475073338746},{"_id":"public/tags/javascript/index.html","hash":"a767ad17cba2ac0a6d0c8f1c4ec01bf8c9c4a5c3","modified":1475073338746},{"_id":"public/tags/JavaScript/index.html","hash":"da40890a356ab6701039a155b29cc3479ff4ef53","modified":1475073338746},{"_id":"public/tags/pushState/index.html","hash":"294601052ef184586e6e90586a81af417f40501a","modified":1475073338746},{"_id":"public/tags/html标签/index.html","hash":"7b84d08d3b73de7e17e504da0c4b2393ced0806c","modified":1475073338746},{"_id":"public/tags/stack/index.html","hash":"09a232937b2e9135634423b6b700e501cb45fcab","modified":1475073338746},{"_id":"public/tags/add-and-push/index.html","hash":"d49c74a7bf07f6056cb2bf167e3e2ea1b2540431","modified":1475073338746},{"_id":"public/tags/this/index.html","hash":"dc49edc83770bf1ec164f84e7cdb0e6991e30087","modified":1475073338746},{"_id":"public/tags/作用域/index.html","hash":"0910871844369893d38d389501104258d6d9cb52","modified":1475073338746},{"_id":"public/tags/旅游日记/index.html","hash":"31fca6d6a5400dcc85e6b59de42c851961c9f192","modified":1475073338746},{"_id":"public/tags/html/index.html","hash":"93a45f365eb3062fafd52c81ffef4bd04a9249e8","modified":1475073338746},{"_id":"public/tags/数据库/index.html","hash":"7c658b29924feecdd821b9809abea136bd04bf94","modified":1475073338746},{"_id":"public/tags/html5/index.html","hash":"cd62b420ba9403d1636ce91b5b90bbb82df5288f","modified":1475073338746},{"_id":"public/tags/css3多列布局/index.html","hash":"acd86b6a3dfe11d0e54170deeff7af2f3eec1c22","modified":1475073338746},{"_id":"public/tags/随笔/index.html","hash":"fa8f0fc3a9f1642d5f3a2a197bc04dcbe1c516f7","modified":1475073338746},{"_id":"public/tags/empty-and-isEmpty/index.html","hash":"ce4141a70384cd76646b5207648e6d5e5f610005","modified":1475073338746},{"_id":"public/tags/css3-transition/index.html","hash":"b02d1c164ec2f93a875939c90ac898eaa203d591","modified":1475073338746},{"_id":"public/tags/hexo配置/index.html","hash":"3bcec95be5836667fc6d5303c8279bee9fa876ca","modified":1475073338746},{"_id":"public/tags/hexo/index.html","hash":"7a86833fa2ae2d482abdf11cad41d0a8c330486e","modified":1475073338746},{"_id":"public/tags/二叉树/index.html","hash":"fc087ffc8f49826bfd33e94f45160c574f38c5aa","modified":1475073338746},{"_id":"public/tags/广度优先遍历/index.html","hash":"1f8ed5978cd62dc24d4f86a58548cc0528f44a2e","modified":1475073338746},{"_id":"public/tags/hexo部署/index.html","hash":"b688e2b14e4b95141a28336e46e6669ed0b8bad9","modified":1475073338746},{"_id":"public/tags/gitignore配置/index.html","hash":"c40845dcc895695764490367755698c400172fc8","modified":1475073338746},{"_id":"public/tags/java/index.html","hash":"f54d2b235f64c0bf245a928fcad8543ae644e685","modified":1475073338746},{"_id":"public/2016/07/29/javascript创建对象及继承/index.html","hash":"e50a197ef8f05f2218e27938d3e11290c3f737b3","modified":1475073338746},{"_id":"public/2016/07/28/块级元素和内联元素/index.html","hash":"ce17695b5dfd47174e1d99eeb06e50f1d4864171","modified":1475073338746},{"_id":"public/2016/07/21/gulp/index.html","hash":"db07484acefc074958591582c4ef12a638663d16","modified":1475073338746},{"_id":"public/2016/07/20/将本地项目首次提交到远程git上遇到的问题/index.html","hash":"f011d24a8b9b23f0518d058cfd82244bf10858a1","modified":1475073338746},{"_id":"public/2016/07/20/css3动画/index.html","hash":"41d32a7e967c6b243867632e3476adc2e330f452","modified":1475073338746},{"_id":"public/2016/07/19/property与attribute/index.html","hash":"0c9cb5bd1b5d6276a0c98a8b931b107e84dbf1f4","modified":1475073338746},{"_id":"public/2016/07/19/JavaScript事件/index.html","hash":"d6a9d45ce142561b9ed545838ce69538e8f4ded9","modified":1475073338746},{"_id":"public/2016/07/19/cookie/index.html","hash":"5acd43b46d6ac8c340eff49a27bb5368903928ac","modified":1475073338746},{"_id":"public/2016/06/16/each/index.html","hash":"c93435562f085613cadacee8ecaaeb7c24826fe7","modified":1475073338746},{"_id":"public/2016/06/15/PCA/index.html","hash":"5884d2a6b2e0605b1f68baaebfc846c006e7ab40","modified":1475073338746},{"_id":"public/2016/06/14/bt/index.html","hash":"2fcfd9a45fc51bbd6a1080e753681519fa65a04d","modified":1475073338746},{"_id":"public/2016/06/01/ROC/index.html","hash":"07044745bd83d849b0dd8795eb11e25acba623cc","modified":1475073338746},{"_id":"public/2016/05/24/思考/index.html","hash":"cd16026a101efadf3755199c5452495c46d87c3a","modified":1475073338746},{"_id":"public/2016/05/24/数据库/index.html","hash":"dce417ef4efa23c5fbb2a85fa10475c6b585f76c","modified":1475073338746},{"_id":"public/2016/05/18/CSS3多列布局/index.html","hash":"4b28a204bd8c8e5677baaccfc7bb52e11291865b","modified":1475073338746},{"_id":"public/2016/05/17/BFC/index.html","hash":"1a9f3bcaca302efbe393f85762eac3ff205556f6","modified":1475073338746},{"_id":"public/2016/05/13/flex/index.html","hash":"b19299a286f0dd48a83b7f0abcb479bf63178d05","modified":1475073338746},{"_id":"public/2016/05/06/html标签/index.html","hash":"4d8271158e7bf2cda4faae229c58d264d44bf55c","modified":1475073338746},{"_id":"public/2016/05/05/transition/index.html","hash":"8a07a0f1ec7b4c1b506a8adc2f7af5321a182146","modified":1475073338746},{"_id":"public/2016/05/03/css3选择器整理/index.html","hash":"e66f9716449afac04511604ceda031d67a54b3c3","modified":1475073338746},{"_id":"public/2016/06/16/类数组/index.html","hash":"26c6160b400abd0ed392f7d9f772f9aefef45cf2","modified":1475073338746},{"_id":"public/archives/index.html","hash":"b8a245676ee716de374cb655921ee63118f13f60","modified":1475073338746},{"_id":"public/2016/03/29/pushstate/index.html","hash":"aa763209d28335bf6b2993d78243658a338ac8f9","modified":1475073338746},{"_id":"public/archives/page/2/index.html","hash":"ed1d24e9eca197e51fd1ac9be219f8e80821c1b4","modified":1475073338746},{"_id":"public/archives/page/4/index.html","hash":"5e125fc43b2f2368be80a9941bfce2b51ae21fa9","modified":1475073338746},{"_id":"public/2016/07/05/Variance/index.html","hash":"79ee6b78e1974e5de04d9e19ae5ce9d25f25dd62","modified":1475073338746},{"_id":"public/archives/2016/index.html","hash":"b73feab98f9b51efab626e4f6aff0c1ef59adf8d","modified":1475073338746},{"_id":"public/archives/2016/page/2/index.html","hash":"c1c7452f23e206214312cc6daf23801da693f0d2","modified":1475073338746},{"_id":"public/archives/2016/page/4/index.html","hash":"7d29a047960799b211b2b476fa66e80daf17178d","modified":1475073338746},{"_id":"public/archives/2016/page/3/index.html","hash":"d1eae5f75eb867e4a5374631f5ba8abd1281029b","modified":1475073338746},{"_id":"public/archives/2016/05/index.html","hash":"66d7a492aaef0062e5206c4ba74bf1e75ad1ec9a","modified":1475073338746},{"_id":"public/archives/2016/06/index.html","hash":"80b96c2f267f3798826d56955a611639a0d3ea6f","modified":1475073338762},{"_id":"public/archives/page/3/index.html","hash":"54a09cfddb07afdfc3d8f20d4e5b4024ffb40ab8","modified":1475073338762},{"_id":"public/categories/学习笔记/index.html","hash":"bccfdd12958c6e19a91ddd53d974305cf2318b71","modified":1475073338762},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"279dc6fe407c762200472e1348a85ee194f75ee1","modified":1475073338762},{"_id":"public/categories/学习笔记/page/3/index.html","hash":"9eebc881895676ff8a8131c8146ff9ab5b3aec81","modified":1475073338762},{"_id":"public/categories/学习笔记/前端学习/index.html","hash":"f1e20aa6bd2b17d44d4256cd3572a9a7691f2f98","modified":1475073338762},{"_id":"public/categories/学习笔记/前端学习/page/2/index.html","hash":"8b972adc29c28cc68dc4089ab1c9ac1e1a0e1689","modified":1475073338762},{"_id":"public/index.html","hash":"f792dcacf489bcaf2ceff010d28be138431567af","modified":1475073338762},{"_id":"public/page/2/index.html","hash":"e6580319972367742d05de5960f7bb857e88cd09","modified":1475073338762},{"_id":"public/page/3/index.html","hash":"f9ab0f0b310290c31fb11d6228acf7e9be5488cd","modified":1475073338762},{"_id":"public/page/4/index.html","hash":"546abfadb2ae2c638bc723cf61741b06b561b35a","modified":1475073338762},{"_id":"public/page/5/index.html","hash":"2abac10ca01c1e09ee625f65f6a65a79b09f9a4d","modified":1475073338762},{"_id":"public/archives/2016/07/index.html","hash":"89228acd449c96ef4fa8171422ad858bd8c128fe","modified":1475073338762},{"_id":"public/tags/padding/index.html","hash":"1cf6178ad21142b15b10277cd8a24710acd448a4","modified":1475073338808},{"_id":"public/tags/margin/index.html","hash":"3a510c56a1c15df3f8589a6f5dd65188236a0609","modified":1475073338808},{"_id":"public/img/event_loop.png","hash":"991109df2ef5ae00d95568a69200baa1775ed399","modified":1475073338808},{"_id":"public/CNAME","hash":"526ec2e5b043b2bccf894db6e7ec7e8d1b5f07a9","modified":1475073338808},{"_id":"public/img/flex/1.jpg","hash":"e29ffb5f65f40b3eddf545582c0e86631bbb0fce","modified":1475073338808},{"_id":"public/img/flex/2.jpg","hash":"3846a7211365e4007b1ae30ca18f940513569ccb","modified":1475073338808},{"_id":"public/img/flex/7.jpg","hash":"eaeeb9c69a9d0c79e3c41370e6fc057517799962","modified":1475073338808},{"_id":"public/img/flex/8.jpg","hash":"f83a7c1d4f6696cb40830da32493261e844591a1","modified":1475073338808},{"_id":"public/img/flex/6.jpg","hash":"57168956bfe6f9ddeba2428d7b6ac3dcbaf1c7cc","modified":1475073338808},{"_id":"public/img/flex/5.jpg","hash":"09390cdaaa31e944970f3c8757f4bdfe203649ce","modified":1475073338808},{"_id":"public/img/roc/2.gif","hash":"49789ec23b540cad49535da38d39e11965495c3f","modified":1475073338808},{"_id":"public/img/roc/1.png","hash":"9e71cba98b2cf1655060dcb0cd0e0d2d9e9f4740","modified":1475073338808},{"_id":"public/img/flex/3.jpg","hash":"00520c0855634ca4a12f66a4949d0916a0a84ef8","modified":1475073338808},{"_id":"public/img/roc/3.png","hash":"e9133ff72ab5d0cdaa31566307ff76936e73a61f","modified":1475073338808},{"_id":"public/img/roc/5.png","hash":"72a935068f4b2e1e64b2d0f0d1da65a4247ca58b","modified":1475073338808},{"_id":"public/img/flex/4.jpg","hash":"8ec29b5f3380801ab3c76ccebc579e2bcbf5bec7","modified":1475073338808},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1475073338808},{"_id":"public/img/flex/9.jpg","hash":"02afb6cd53c1ceb2dcd715de3f8a2e318f7cb49c","modified":1475073338808},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1475073338808},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1475073338808},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1475073338808},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1475073338808},{"_id":"public/img/roc/4.gif","hash":"23cf74e8026467c4dd18c2fd020187291cad780a","modified":1475073338808},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1475073338808},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1475073338808},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1475073338808},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1475073338808},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1475073338808},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1475073338808},{"_id":"public/uploads/zhudi.jpg","hash":"b4d438b5b8d6b69d2fc8458bbac13b2563680b0e","modified":1475073338808},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1475073338808},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1475073338808},{"_id":"public/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1475073338808},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1475073338808},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1475073338808},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1475073338808},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1475073338808},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1475073338808},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1475073338808},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1475073338808},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1475073338808},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1475073338808},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1475073343948},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1475073343963},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1475073343979},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1475073344010},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1475073344010},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1475073344010},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1475073344010},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1475073344010},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1475073344010},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1475073344010},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1475073344010},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1475073344010},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1475073344010},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1475073344010},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1475073344010},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1475073344010},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1475073344010},{"_id":"public/js/src/utils.js","hash":"a3a3375de818964f4cbed4d0e2c2f97ccee7199e","modified":1475073344010},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1475073344010},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1475073344010},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1475073344010},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1475073344010},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1475073344010},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1475073344010},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1475073344010},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1475073344010},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1475073344010},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1475073344010},{"_id":"public/css/main.css","hash":"8288cf1e399ef02abc1f0e6cf40257f417f3340d","modified":1475073344010},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1475073344010},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1475073344010},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1475073344010},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1475073344010},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1475073344010},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1475073344010},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1475073344010},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1475073344010},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1475073344010},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1475073344010},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1475073344041},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1475073344041},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1475073344088},{"_id":"public/img/3.jpg","hash":"6fedbd33722bfa225714020cac3a0dc959ecbe4b","modified":1475073344088},{"_id":"public/img/4.jpg","hash":"39a4de4757a664bc8037c1c0f06b07fb08471928","modified":1475073344088},{"_id":"public/img/2.jpg","hash":"ed51490bf3eb63a261de74886d43694623fff3b1","modified":1475073344088},{"_id":"public/img/1.jpg","hash":"1ee536df019f16546a28515c962ecc0c2e8604e0","modified":1475073344104}],"Category":[{"name":"学习笔记","_id":"citn0kmfk00061kvsi1xbpon6"},{"name":"数据挖掘","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmgf000f1kvs6x5r6umt"},{"name":"前端学习","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmhc000r1kvsk7tylaai"},{"name":"git学习","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmji001q1kvs1pq6qucx"},{"name":"数据结构","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmjy001y1kvs3zf2acm9"},{"name":"javascript","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmkt002d1kvstonuir2v"},{"name":"java","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmlo002p1kvshyzdxpi7"},{"name":"随手日记","_id":"citn0kmmz00391kvsc0rkr2vx"},{"name":"数据库","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmnf003i1kvsif1yi9jo"},{"name":"hexo学习","parent":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmoq00461kvsb3tpd9sd"}],"Data":[],"Page":[{"title":"categories","date":"2016-05-05T08:57:12.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-05-05 16:57:12\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-05-05T12:36:14.453Z","path":"categories/index.html","layout":"page","_id":"citn0kmf400011kvspwexxejh","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-05-05T08:24:03.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-05-05 16:24:03\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-05-05T12:36:14.454Z","path":"tags/index.html","layout":"page","_id":"citn0kmf400031kvsmebcimx9","content":"","excerpt":"","more":""}],"Post":[{"title":"jquery事件","_content":"","source":"_drafts/jquery事件.md","raw":"---\ntitle: jquery事件\ntags:\n---\n","slug":"jquery事件","published":0,"date":"2016-06-21T13:33:13.509Z","updated":"2016-06-21T13:33:27.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kme900001kvsp2l4rhjw","content":"","excerpt":"","more":""},{"title":"决策树算法学习","date":"2016-04-28T06:20:45.000Z","_content":"\n  今天主要从以下几个方面学习决策树算法：\n  1. 决策树算法的原理\n  2. 决策树算法的优缺点\n  3. 常用的决策树算法\n  4. 分裂属性的判定\n  5. 模型的误差\n  6. 决策树算法的剪枝策略\n \n\n<!-- more -->\n\n## 决策树算法原理\n\n  传统的数据分类操作通常有以下两个步骤\n\n## 决策树算法的优缺点\n### 决策树算法的优点\n1. 使用者不需要\n### 决策树算法的缺点\n1. \n\n## 常用决策树算法\n## 最佳分类属性的判定\n## 模型的误差\n一般情况下，我们会把数据分成训练数据集合测试数据集，通过训练数据集训练模型，然后通过测试数据集测试模型。模型在训练数据上的误差叫训练误差，模型在测试数据上的误差成为泛化误差，泛化误差是模型在未知记录上的期望误差。一个好的模型应该有低训练误差和低泛化误差。\n一种最常见的情况是，模型在训练数据集上误差小，但是泛化误差大，常称为模型的过度拟合。导致模型过度拟合的原因主要有以下两点：\n1. 噪声；\n2. 样本缺乏代表性；\n为解决模型的过度拟合问题，我们经常使用对决策树后剪枝的方法，这样需要我们在建立模型的过程中，尽量建立一棵大树，然后基于数据的支持度和业务的理解对树进行剪枝。\n## 决策树剪枝策略","source":"_drafts/决策树算法学习.md","raw":"---\ntitle: 决策树算法学习\ndate: 2016-04-28 14:20:45\ntags: \n  - 数据挖掘\ncategories:\n  - 学习笔记\n  - 数据挖掘\n---\n\n  今天主要从以下几个方面学习决策树算法：\n  1. 决策树算法的原理\n  2. 决策树算法的优缺点\n  3. 常用的决策树算法\n  4. 分裂属性的判定\n  5. 模型的误差\n  6. 决策树算法的剪枝策略\n \n\n<!-- more -->\n\n## 决策树算法原理\n\n  传统的数据分类操作通常有以下两个步骤\n\n## 决策树算法的优缺点\n### 决策树算法的优点\n1. 使用者不需要\n### 决策树算法的缺点\n1. \n\n## 常用决策树算法\n## 最佳分类属性的判定\n## 模型的误差\n一般情况下，我们会把数据分成训练数据集合测试数据集，通过训练数据集训练模型，然后通过测试数据集测试模型。模型在训练数据上的误差叫训练误差，模型在测试数据上的误差成为泛化误差，泛化误差是模型在未知记录上的期望误差。一个好的模型应该有低训练误差和低泛化误差。\n一种最常见的情况是，模型在训练数据集上误差小，但是泛化误差大，常称为模型的过度拟合。导致模型过度拟合的原因主要有以下两点：\n1. 噪声；\n2. 样本缺乏代表性；\n为解决模型的过度拟合问题，我们经常使用对决策树后剪枝的方法，这样需要我们在建立模型的过程中，尽量建立一棵大树，然后基于数据的支持度和业务的理解对树进行剪枝。\n## 决策树剪枝策略","slug":"决策树算法学习","published":0,"updated":"2016-05-14T10:52:53.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmf400021kvszzu7s1vi","content":"<p>  今天主要从以下几个方面学习决策树算法：</p>\n<ol>\n<li>决策树算法的原理</li>\n<li>决策树算法的优缺点</li>\n<li>常用的决策树算法</li>\n<li>分裂属性的判定</li>\n<li>模型的误差</li>\n<li>决策树算法的剪枝策略</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"决策树算法原理\"><a href=\"#决策树算法原理\" class=\"headerlink\" title=\"决策树算法原理\"></a>决策树算法原理</h2><p>  传统的数据分类操作通常有以下两个步骤</p>\n<h2 id=\"决策树算法的优缺点\"><a href=\"#决策树算法的优缺点\" class=\"headerlink\" title=\"决策树算法的优缺点\"></a>决策树算法的优缺点</h2><h3 id=\"决策树算法的优点\"><a href=\"#决策树算法的优点\" class=\"headerlink\" title=\"决策树算法的优点\"></a>决策树算法的优点</h3><ol>\n<li>使用者不需要<h3 id=\"决策树算法的缺点\"><a href=\"#决策树算法的缺点\" class=\"headerlink\" title=\"决策树算法的缺点\"></a>决策树算法的缺点</h3></li>\n<li></li>\n</ol>\n<h2 id=\"常用决策树算法\"><a href=\"#常用决策树算法\" class=\"headerlink\" title=\"常用决策树算法\"></a>常用决策树算法</h2><h2 id=\"最佳分类属性的判定\"><a href=\"#最佳分类属性的判定\" class=\"headerlink\" title=\"最佳分类属性的判定\"></a>最佳分类属性的判定</h2><h2 id=\"模型的误差\"><a href=\"#模型的误差\" class=\"headerlink\" title=\"模型的误差\"></a>模型的误差</h2><p>一般情况下，我们会把数据分成训练数据集合测试数据集，通过训练数据集训练模型，然后通过测试数据集测试模型。模型在训练数据上的误差叫训练误差，模型在测试数据上的误差成为泛化误差，泛化误差是模型在未知记录上的期望误差。一个好的模型应该有低训练误差和低泛化误差。<br>一种最常见的情况是，模型在训练数据集上误差小，但是泛化误差大，常称为模型的过度拟合。导致模型过度拟合的原因主要有以下两点：</p>\n<ol>\n<li>噪声；</li>\n<li>样本缺乏代表性；<br>为解决模型的过度拟合问题，我们经常使用对决策树后剪枝的方法，这样需要我们在建立模型的过程中，尽量建立一棵大树，然后基于数据的支持度和业务的理解对树进行剪枝。<h2 id=\"决策树剪枝策略\"><a href=\"#决策树剪枝策略\" class=\"headerlink\" title=\"决策树剪枝策略\"></a>决策树剪枝策略</h2></li>\n</ol>\n","excerpt":"<p>  今天主要从以下几个方面学习决策树算法：</p>\n<ol>\n<li>决策树算法的原理</li>\n<li>决策树算法的优缺点</li>\n<li>常用的决策树算法</li>\n<li>分裂属性的判定</li>\n<li>模型的误差</li>\n<li>决策树算法的剪枝策略</li>\n</ol>","more":"<h2 id=\"决策树算法原理\"><a href=\"#决策树算法原理\" class=\"headerlink\" title=\"决策树算法原理\"></a>决策树算法原理</h2><p>  传统的数据分类操作通常有以下两个步骤</p>\n<h2 id=\"决策树算法的优缺点\"><a href=\"#决策树算法的优缺点\" class=\"headerlink\" title=\"决策树算法的优缺点\"></a>决策树算法的优缺点</h2><h3 id=\"决策树算法的优点\"><a href=\"#决策树算法的优点\" class=\"headerlink\" title=\"决策树算法的优点\"></a>决策树算法的优点</h3><ol>\n<li>使用者不需要<h3 id=\"决策树算法的缺点\"><a href=\"#决策树算法的缺点\" class=\"headerlink\" title=\"决策树算法的缺点\"></a>决策树算法的缺点</h3></li>\n<li></li>\n</ol>\n<h2 id=\"常用决策树算法\"><a href=\"#常用决策树算法\" class=\"headerlink\" title=\"常用决策树算法\"></a>常用决策树算法</h2><h2 id=\"最佳分类属性的判定\"><a href=\"#最佳分类属性的判定\" class=\"headerlink\" title=\"最佳分类属性的判定\"></a>最佳分类属性的判定</h2><h2 id=\"模型的误差\"><a href=\"#模型的误差\" class=\"headerlink\" title=\"模型的误差\"></a>模型的误差</h2><p>一般情况下，我们会把数据分成训练数据集合测试数据集，通过训练数据集训练模型，然后通过测试数据集测试模型。模型在训练数据上的误差叫训练误差，模型在测试数据上的误差成为泛化误差，泛化误差是模型在未知记录上的期望误差。一个好的模型应该有低训练误差和低泛化误差。<br>一种最常见的情况是，模型在训练数据集上误差小，但是泛化误差大，常称为模型的过度拟合。导致模型过度拟合的原因主要有以下两点：</p>\n<ol>\n<li>噪声；</li>\n<li>样本缺乏代表性；<br>为解决模型的过度拟合问题，我们经常使用对决策树后剪枝的方法，这样需要我们在建立模型的过程中，尽量建立一棵大树，然后基于数据的支持度和业务的理解对树进行剪枝。<h2 id=\"决策树剪枝策略\"><a href=\"#决策树剪枝策略\" class=\"headerlink\" title=\"决策树剪枝策略\"></a>决策树剪枝策略</h2></li>\n</ol>"},{"title":"生活启示录","_content":"问题：他老觉得我跟男生走的近，而且还控制不住，还自己意识不到\n      我自己确实自己觉得我没有跟男生走的多近，我也问了我周围的人，她们也没觉得我跟哪个男生走的近了。\n问题抽取与分析：\n一 为什么男朋友老是怀疑我跟其他男生走的近？\n1. 刚跟他在一起时我表现的另外两个男生比他重要，在他心里留下了阴影。\n问题分析：其实这个问题怪我，说实话我这个人一直都没有安全感，我老是害怕对方没那么在乎我，没那么喜欢我，这也是为什么我一吵架就说分手，其实是平时就特别害怕分手，因为特别害怕，才老是说分手，至于为什么老是害怕被抛弃，我也不知道，可能是小时候受过什么创伤吧，具体原因估计得看心理医生。所以刚跟他在一起时，我就故意说一些跟其他男生的事，其实心里就是想告诉他没有他也有别人要我，想让他别那么轻易的放弃我，但是我没有想到他那时候真的挺在乎我的，大家都不知道，我其实心里面潜意识中就是这个世界上没有人会真的爱我，没有人会真的在乎我，尽管我不想承认。我还老是跟他说我肯定会遇到比你好的，可是我心里想的真的是世界上没有谁会真的爱我，你要是跟我分手就证明了我的想法，那我就找个我不爱的，省得为他伤心。我表现的很在乎另外两个人的样子其实都是装的，不知道出于什么心里，就是为了想看看我在你心里是不是很重要吧。后来有次你问我，你说让我在你跟他们两个之间选，问我选谁，我说我都不选，那时我就是觉得我不确定你是不是真的爱我，我当时天真的以为你如果真的爱我就不会因为任何事情离开我，而且我那个时候表现出来的是他们真的很重要，你怎么会逼我做这种决定，那个时候真的是太不成熟了，其实后来我看到了你写的日记，我才知道你真的很受伤，那个时候我是真的不懂爱。\n2. 写着写着发现其实没有2了，一切都是因为那个时候留下的阴影，也许是现在只要跟哪个男生接触的多些，就会让他想起那个时候，可能那个时候对他伤的真的很重，我应该理解的，就像他快毕业时那样对我，虽然都过去，但是只要他一生气，我潜意识中就会想起来，这么看来也可以理解了。有些伤确实是很难，或者没有办法弥补的。\n3. 继续写下去发现还真有个问题，我觉得人脉很重要，有时候请别人吃饭什么的其实我也没想着跟他要有多好，想着的就是维持人脉，等以后有用的着的地方的时候好有个人能用。针对这一点，我觉得我也不能接受他跟别的女生走的近，那我也应该不跟其他的男生有任何关系，这点很公平，其实我之前觉得委屈委屈的是我觉得你不信任我，不是我不跟男生交往觉得委屈。其实在一起这么久了，有些事情不能简单的用委屈不委屈来判断，就比如洗衣服这件事，我以前觉得我以后绝对不会给一个男生洗衣服，但是当我在你那里，看你工作那么辛苦，我就是很心疼你，想为你做点什么，你说我给你洗衣服绝不觉得自己委屈？你老说我现在不跟男生交往觉得委屈，可是我知道我跟其他男生走太近你会难过，我不想让你难过，所以我不愿意跟其他男生走的很近，只有周朝华我觉得你应该知道我不可能喜欢他，才跟他有些交集，但跟他也是很清楚的，我不会欠他任何东西，我用他帮我取快递，我也会以其他的方式补偿他，我不想亏欠除了你以外的任何人。我心甘情愿不跟别的男生有交集，就像你心甘情愿我我做一些事情，你觉得委屈么？\n\n二 今后的路该怎么走？\n\n跟你在一起这两年多，我觉得我们还算快乐，你也满足了我对男朋友的全部幻想，我也在努力的为你付出我能付出的一切，我在成长，我希望以后能做一个好妻子，我觉得你也能看到我的改变，做些改变不能说什么委屈不委屈的，我喜欢你，我跟你在一起很快乐，我心甘情愿的做些改变让我们的感情便的更好，让我们相处的更愉快，我觉得你也相信我没有跟别的男生有什么关系，我希望你能放下过去，也为我做一些改变，不是让你放弃你的原则，而是更相信我一些，体谅我一些，我也保证以后不再跟其他男生发生像逛街，单独吃饭这种事。其他方面，以后也能多照顾我一些，关心我一些，理解我一些，我舍不得让你难过，你怎么舍得让我难过。这是我的爱情观，如果我们的爱情观不一样，你离开我也不会挽留，但是还是感谢你让我有了这样的爱情观。\n\n三 总结\n其实哭闹都不是解决问题的方法，有些事情还真的得冷静下来好好想想，有些问题，不解决真的没有办法在一起。","source":"_drafts/生活启示录.md","raw":"---\ntitle: 生活启示录\ntags:\n---\n问题：他老觉得我跟男生走的近，而且还控制不住，还自己意识不到\n      我自己确实自己觉得我没有跟男生走的多近，我也问了我周围的人，她们也没觉得我跟哪个男生走的近了。\n问题抽取与分析：\n一 为什么男朋友老是怀疑我跟其他男生走的近？\n1. 刚跟他在一起时我表现的另外两个男生比他重要，在他心里留下了阴影。\n问题分析：其实这个问题怪我，说实话我这个人一直都没有安全感，我老是害怕对方没那么在乎我，没那么喜欢我，这也是为什么我一吵架就说分手，其实是平时就特别害怕分手，因为特别害怕，才老是说分手，至于为什么老是害怕被抛弃，我也不知道，可能是小时候受过什么创伤吧，具体原因估计得看心理医生。所以刚跟他在一起时，我就故意说一些跟其他男生的事，其实心里就是想告诉他没有他也有别人要我，想让他别那么轻易的放弃我，但是我没有想到他那时候真的挺在乎我的，大家都不知道，我其实心里面潜意识中就是这个世界上没有人会真的爱我，没有人会真的在乎我，尽管我不想承认。我还老是跟他说我肯定会遇到比你好的，可是我心里想的真的是世界上没有谁会真的爱我，你要是跟我分手就证明了我的想法，那我就找个我不爱的，省得为他伤心。我表现的很在乎另外两个人的样子其实都是装的，不知道出于什么心里，就是为了想看看我在你心里是不是很重要吧。后来有次你问我，你说让我在你跟他们两个之间选，问我选谁，我说我都不选，那时我就是觉得我不确定你是不是真的爱我，我当时天真的以为你如果真的爱我就不会因为任何事情离开我，而且我那个时候表现出来的是他们真的很重要，你怎么会逼我做这种决定，那个时候真的是太不成熟了，其实后来我看到了你写的日记，我才知道你真的很受伤，那个时候我是真的不懂爱。\n2. 写着写着发现其实没有2了，一切都是因为那个时候留下的阴影，也许是现在只要跟哪个男生接触的多些，就会让他想起那个时候，可能那个时候对他伤的真的很重，我应该理解的，就像他快毕业时那样对我，虽然都过去，但是只要他一生气，我潜意识中就会想起来，这么看来也可以理解了。有些伤确实是很难，或者没有办法弥补的。\n3. 继续写下去发现还真有个问题，我觉得人脉很重要，有时候请别人吃饭什么的其实我也没想着跟他要有多好，想着的就是维持人脉，等以后有用的着的地方的时候好有个人能用。针对这一点，我觉得我也不能接受他跟别的女生走的近，那我也应该不跟其他的男生有任何关系，这点很公平，其实我之前觉得委屈委屈的是我觉得你不信任我，不是我不跟男生交往觉得委屈。其实在一起这么久了，有些事情不能简单的用委屈不委屈来判断，就比如洗衣服这件事，我以前觉得我以后绝对不会给一个男生洗衣服，但是当我在你那里，看你工作那么辛苦，我就是很心疼你，想为你做点什么，你说我给你洗衣服绝不觉得自己委屈？你老说我现在不跟男生交往觉得委屈，可是我知道我跟其他男生走太近你会难过，我不想让你难过，所以我不愿意跟其他男生走的很近，只有周朝华我觉得你应该知道我不可能喜欢他，才跟他有些交集，但跟他也是很清楚的，我不会欠他任何东西，我用他帮我取快递，我也会以其他的方式补偿他，我不想亏欠除了你以外的任何人。我心甘情愿不跟别的男生有交集，就像你心甘情愿我我做一些事情，你觉得委屈么？\n\n二 今后的路该怎么走？\n\n跟你在一起这两年多，我觉得我们还算快乐，你也满足了我对男朋友的全部幻想，我也在努力的为你付出我能付出的一切，我在成长，我希望以后能做一个好妻子，我觉得你也能看到我的改变，做些改变不能说什么委屈不委屈的，我喜欢你，我跟你在一起很快乐，我心甘情愿的做些改变让我们的感情便的更好，让我们相处的更愉快，我觉得你也相信我没有跟别的男生有什么关系，我希望你能放下过去，也为我做一些改变，不是让你放弃你的原则，而是更相信我一些，体谅我一些，我也保证以后不再跟其他男生发生像逛街，单独吃饭这种事。其他方面，以后也能多照顾我一些，关心我一些，理解我一些，我舍不得让你难过，你怎么舍得让我难过。这是我的爱情观，如果我们的爱情观不一样，你离开我也不会挽留，但是还是感谢你让我有了这样的爱情观。\n\n三 总结\n其实哭闹都不是解决问题的方法，有些事情还真的得冷静下来好好想想，有些问题，不解决真的没有办法在一起。","slug":"生活启示录","published":0,"date":"2016-07-05T15:40:48.337Z","updated":"2016-07-05T15:40:48.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmfk00041kvs13m976tm","content":"<p>问题：他老觉得我跟男生走的近，而且还控制不住，还自己意识不到<br>      我自己确实自己觉得我没有跟男生走的多近，我也问了我周围的人，她们也没觉得我跟哪个男生走的近了。<br>问题抽取与分析：<br>一 为什么男朋友老是怀疑我跟其他男生走的近？</p>\n<ol>\n<li>刚跟他在一起时我表现的另外两个男生比他重要，在他心里留下了阴影。<br>问题分析：其实这个问题怪我，说实话我这个人一直都没有安全感，我老是害怕对方没那么在乎我，没那么喜欢我，这也是为什么我一吵架就说分手，其实是平时就特别害怕分手，因为特别害怕，才老是说分手，至于为什么老是害怕被抛弃，我也不知道，可能是小时候受过什么创伤吧，具体原因估计得看心理医生。所以刚跟他在一起时，我就故意说一些跟其他男生的事，其实心里就是想告诉他没有他也有别人要我，想让他别那么轻易的放弃我，但是我没有想到他那时候真的挺在乎我的，大家都不知道，我其实心里面潜意识中就是这个世界上没有人会真的爱我，没有人会真的在乎我，尽管我不想承认。我还老是跟他说我肯定会遇到比你好的，可是我心里想的真的是世界上没有谁会真的爱我，你要是跟我分手就证明了我的想法，那我就找个我不爱的，省得为他伤心。我表现的很在乎另外两个人的样子其实都是装的，不知道出于什么心里，就是为了想看看我在你心里是不是很重要吧。后来有次你问我，你说让我在你跟他们两个之间选，问我选谁，我说我都不选，那时我就是觉得我不确定你是不是真的爱我，我当时天真的以为你如果真的爱我就不会因为任何事情离开我，而且我那个时候表现出来的是他们真的很重要，你怎么会逼我做这种决定，那个时候真的是太不成熟了，其实后来我看到了你写的日记，我才知道你真的很受伤，那个时候我是真的不懂爱。</li>\n<li>写着写着发现其实没有2了，一切都是因为那个时候留下的阴影，也许是现在只要跟哪个男生接触的多些，就会让他想起那个时候，可能那个时候对他伤的真的很重，我应该理解的，就像他快毕业时那样对我，虽然都过去，但是只要他一生气，我潜意识中就会想起来，这么看来也可以理解了。有些伤确实是很难，或者没有办法弥补的。</li>\n<li>继续写下去发现还真有个问题，我觉得人脉很重要，有时候请别人吃饭什么的其实我也没想着跟他要有多好，想着的就是维持人脉，等以后有用的着的地方的时候好有个人能用。针对这一点，我觉得我也不能接受他跟别的女生走的近，那我也应该不跟其他的男生有任何关系，这点很公平，其实我之前觉得委屈委屈的是我觉得你不信任我，不是我不跟男生交往觉得委屈。其实在一起这么久了，有些事情不能简单的用委屈不委屈来判断，就比如洗衣服这件事，我以前觉得我以后绝对不会给一个男生洗衣服，但是当我在你那里，看你工作那么辛苦，我就是很心疼你，想为你做点什么，你说我给你洗衣服绝不觉得自己委屈？你老说我现在不跟男生交往觉得委屈，可是我知道我跟其他男生走太近你会难过，我不想让你难过，所以我不愿意跟其他男生走的很近，只有周朝华我觉得你应该知道我不可能喜欢他，才跟他有些交集，但跟他也是很清楚的，我不会欠他任何东西，我用他帮我取快递，我也会以其他的方式补偿他，我不想亏欠除了你以外的任何人。我心甘情愿不跟别的男生有交集，就像你心甘情愿我我做一些事情，你觉得委屈么？</li>\n</ol>\n<p>二 今后的路该怎么走？</p>\n<p>跟你在一起这两年多，我觉得我们还算快乐，你也满足了我对男朋友的全部幻想，我也在努力的为你付出我能付出的一切，我在成长，我希望以后能做一个好妻子，我觉得你也能看到我的改变，做些改变不能说什么委屈不委屈的，我喜欢你，我跟你在一起很快乐，我心甘情愿的做些改变让我们的感情便的更好，让我们相处的更愉快，我觉得你也相信我没有跟别的男生有什么关系，我希望你能放下过去，也为我做一些改变，不是让你放弃你的原则，而是更相信我一些，体谅我一些，我也保证以后不再跟其他男生发生像逛街，单独吃饭这种事。其他方面，以后也能多照顾我一些，关心我一些，理解我一些，我舍不得让你难过，你怎么舍得让我难过。这是我的爱情观，如果我们的爱情观不一样，你离开我也不会挽留，但是还是感谢你让我有了这样的爱情观。</p>\n<p>三 总结<br>其实哭闹都不是解决问题的方法，有些事情还真的得冷静下来好好想想，有些问题，不解决真的没有办法在一起。</p>\n","excerpt":"","more":"<p>问题：他老觉得我跟男生走的近，而且还控制不住，还自己意识不到<br>      我自己确实自己觉得我没有跟男生走的多近，我也问了我周围的人，她们也没觉得我跟哪个男生走的近了。<br>问题抽取与分析：<br>一 为什么男朋友老是怀疑我跟其他男生走的近？</p>\n<ol>\n<li>刚跟他在一起时我表现的另外两个男生比他重要，在他心里留下了阴影。<br>问题分析：其实这个问题怪我，说实话我这个人一直都没有安全感，我老是害怕对方没那么在乎我，没那么喜欢我，这也是为什么我一吵架就说分手，其实是平时就特别害怕分手，因为特别害怕，才老是说分手，至于为什么老是害怕被抛弃，我也不知道，可能是小时候受过什么创伤吧，具体原因估计得看心理医生。所以刚跟他在一起时，我就故意说一些跟其他男生的事，其实心里就是想告诉他没有他也有别人要我，想让他别那么轻易的放弃我，但是我没有想到他那时候真的挺在乎我的，大家都不知道，我其实心里面潜意识中就是这个世界上没有人会真的爱我，没有人会真的在乎我，尽管我不想承认。我还老是跟他说我肯定会遇到比你好的，可是我心里想的真的是世界上没有谁会真的爱我，你要是跟我分手就证明了我的想法，那我就找个我不爱的，省得为他伤心。我表现的很在乎另外两个人的样子其实都是装的，不知道出于什么心里，就是为了想看看我在你心里是不是很重要吧。后来有次你问我，你说让我在你跟他们两个之间选，问我选谁，我说我都不选，那时我就是觉得我不确定你是不是真的爱我，我当时天真的以为你如果真的爱我就不会因为任何事情离开我，而且我那个时候表现出来的是他们真的很重要，你怎么会逼我做这种决定，那个时候真的是太不成熟了，其实后来我看到了你写的日记，我才知道你真的很受伤，那个时候我是真的不懂爱。</li>\n<li>写着写着发现其实没有2了，一切都是因为那个时候留下的阴影，也许是现在只要跟哪个男生接触的多些，就会让他想起那个时候，可能那个时候对他伤的真的很重，我应该理解的，就像他快毕业时那样对我，虽然都过去，但是只要他一生气，我潜意识中就会想起来，这么看来也可以理解了。有些伤确实是很难，或者没有办法弥补的。</li>\n<li>继续写下去发现还真有个问题，我觉得人脉很重要，有时候请别人吃饭什么的其实我也没想着跟他要有多好，想着的就是维持人脉，等以后有用的着的地方的时候好有个人能用。针对这一点，我觉得我也不能接受他跟别的女生走的近，那我也应该不跟其他的男生有任何关系，这点很公平，其实我之前觉得委屈委屈的是我觉得你不信任我，不是我不跟男生交往觉得委屈。其实在一起这么久了，有些事情不能简单的用委屈不委屈来判断，就比如洗衣服这件事，我以前觉得我以后绝对不会给一个男生洗衣服，但是当我在你那里，看你工作那么辛苦，我就是很心疼你，想为你做点什么，你说我给你洗衣服绝不觉得自己委屈？你老说我现在不跟男生交往觉得委屈，可是我知道我跟其他男生走太近你会难过，我不想让你难过，所以我不愿意跟其他男生走的很近，只有周朝华我觉得你应该知道我不可能喜欢他，才跟他有些交集，但跟他也是很清楚的，我不会欠他任何东西，我用他帮我取快递，我也会以其他的方式补偿他，我不想亏欠除了你以外的任何人。我心甘情愿不跟别的男生有交集，就像你心甘情愿我我做一些事情，你觉得委屈么？</li>\n</ol>\n<p>二 今后的路该怎么走？</p>\n<p>跟你在一起这两年多，我觉得我们还算快乐，你也满足了我对男朋友的全部幻想，我也在努力的为你付出我能付出的一切，我在成长，我希望以后能做一个好妻子，我觉得你也能看到我的改变，做些改变不能说什么委屈不委屈的，我喜欢你，我跟你在一起很快乐，我心甘情愿的做些改变让我们的感情便的更好，让我们相处的更愉快，我觉得你也相信我没有跟别的男生有什么关系，我希望你能放下过去，也为我做一些改变，不是让你放弃你的原则，而是更相信我一些，体谅我一些，我也保证以后不再跟其他男生发生像逛街，单独吃饭这种事。其他方面，以后也能多照顾我一些，关心我一些，理解我一些，我舍不得让你难过，你怎么舍得让我难过。这是我的爱情观，如果我们的爱情观不一样，你离开我也不会挽留，但是还是感谢你让我有了这样的爱情观。</p>\n<p>三 总结<br>其实哭闹都不是解决问题的方法，有些事情还真的得冷静下来好好想想，有些问题，不解决真的没有办法在一起。</p>\n"},{"title":"JavaScript事件","date":"2016-07-19T06:17:02.000Z","_content":"# 事件介绍\n\n1. JavaScript和html的交互是通过事件完成的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。\n2. 事件流是指从页面中接收事件的顺序\n3. IE是事件冒泡流：事件开始时从具体的元素接收，逐级向上传播到较为不具体的节点（文档）\n   Netscape是事件捕获流：不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件\n4. 所有现代浏览器都支持事件冒泡，可以放心的使用事件冒泡，在有特殊需要时再使用事件捕获。\n<!-- more -->\n\n# DOM事件流\n\n“DOM2级事件”规定事件流包括三个阶段：事件捕获阶段，出于目标阶段和事件冒泡阶段。\n第一阶段是事件捕获，为截获事件提供了机会，最后一个阶段是冒泡阶段，可以在这阶段对事件作出响应。\n在DOM事件流中，实际的目标在捕获阶段不会接收到事件。下一阶段是“出于目标”阶段，于是事件在目标上发生，并在事件处理中被看成冒泡阶段的一部分。\n\n# 事件处理程序\n\n响应某个事件的函数叫做事件处理程序（或事件侦听器）。\n\n一 DOM0级事件处理程序：\n将一个函数赋值给一个事件处理程序属性。这种方式有两个优点：\n1. 简单\n2. 具有跨浏览器的优势\n使用DOM级方法指定的事件处理程序被认为是元素的方法。因此，这时的事件处理程序是在元素的作用域中运行的，即，程序中的this指向当前元素。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。\n\n二 DOM2级事件处理程序\naddEventListener()和removeEventListener()\n有三个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值，true是在捕获阶段调用，false是在冒泡阶段调用。\n优点：\n可以添加多个事件处理程序，同一事件的事件处理程序按添加的顺序执行。\n\n三 ie中的事件处理程序(ie8及以前)\nattachEvent()和detachEvent()\n\n在ie中使用attachEvent()添加事件处理程序与DOM0级方法添加的方式的主要区别在于：\n1. 在使用DOM0级方法添加的时候，事件处理程序的作用域是其所属的元素作用域，而使用attachEvent方式添加，事件处理程序会在全局作用域中运行。\n2. 也可以添加多个事件处理程序，不过<font color=\"red\">*不以添加的顺序执行，而以相反的顺序执行*</font>\n\n# 事件对象Event\n\n在触发DOM上的某个事件时，会自动产生一个Event对象，这个对象包含着所有与事件有关的信息，兼容DOM的浏览器会将一个event对象传入事件处理程序中，无论指定事件处理程序时使用的是什么方法。\n\n在事件处理程序内部，对象this的值始终等于currentTarget的值。\n\ncurrentTarget 只读，其事件处理程序当前正在处理事件的那个元素。我觉得就是绑定事件处理程序的元素。\ntarget 只读，事件的目标\nstopPropagation()方法用于立即停止事件在DOM中的传播，即取消进一步的事件捕获或冒泡。如\n\n\tdocument.getElementsByTagName('ul')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t\t// e.stopPropagation();\n\t\t}\n\t\tdocument.getElementsByTagName('body')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t}\n\n输出UL BODY，但是\n\n\tdocument.getElementsByTagName('ul')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t\te.stopPropagation();\n\t\t}\n\t\tdocument.getElementsByTagName('body')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t}\n只输出UL，事件在ul之后不会继续向上传播。\n\neventPhase()输出事件正在处于事件流的哪个阶段，1代表事件捕获阶段，2代码处于目标对象，3代表冒泡阶段\n\n# 可以冒泡的事件和不能冒泡的事件\n不能冒泡的事件\nabort\nblur\nerror\nfocus\nload\nmouseenter\nmouseleave\nresize\nunload\n可以冒泡的事件\nbeforeinput\nclick\ncompositionstart\ncompositionupdate\ncompositionend\ndblclick\nfocusin\nfocusout\ninput\nkeydown\nkeyup\nmousedown\nmousemove\nmouseout\t\nmouseover\nmouseup\nscroll\nselect\nwheel","source":"_posts/JavaScript事件.md","raw":"---\ntitle: JavaScript事件\ndate: 2016-07-19 14:17:02\ntags: \n  - javascript事件\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n# 事件介绍\n\n1. JavaScript和html的交互是通过事件完成的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。\n2. 事件流是指从页面中接收事件的顺序\n3. IE是事件冒泡流：事件开始时从具体的元素接收，逐级向上传播到较为不具体的节点（文档）\n   Netscape是事件捕获流：不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件\n4. 所有现代浏览器都支持事件冒泡，可以放心的使用事件冒泡，在有特殊需要时再使用事件捕获。\n<!-- more -->\n\n# DOM事件流\n\n“DOM2级事件”规定事件流包括三个阶段：事件捕获阶段，出于目标阶段和事件冒泡阶段。\n第一阶段是事件捕获，为截获事件提供了机会，最后一个阶段是冒泡阶段，可以在这阶段对事件作出响应。\n在DOM事件流中，实际的目标在捕获阶段不会接收到事件。下一阶段是“出于目标”阶段，于是事件在目标上发生，并在事件处理中被看成冒泡阶段的一部分。\n\n# 事件处理程序\n\n响应某个事件的函数叫做事件处理程序（或事件侦听器）。\n\n一 DOM0级事件处理程序：\n将一个函数赋值给一个事件处理程序属性。这种方式有两个优点：\n1. 简单\n2. 具有跨浏览器的优势\n使用DOM级方法指定的事件处理程序被认为是元素的方法。因此，这时的事件处理程序是在元素的作用域中运行的，即，程序中的this指向当前元素。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。\n\n二 DOM2级事件处理程序\naddEventListener()和removeEventListener()\n有三个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值，true是在捕获阶段调用，false是在冒泡阶段调用。\n优点：\n可以添加多个事件处理程序，同一事件的事件处理程序按添加的顺序执行。\n\n三 ie中的事件处理程序(ie8及以前)\nattachEvent()和detachEvent()\n\n在ie中使用attachEvent()添加事件处理程序与DOM0级方法添加的方式的主要区别在于：\n1. 在使用DOM0级方法添加的时候，事件处理程序的作用域是其所属的元素作用域，而使用attachEvent方式添加，事件处理程序会在全局作用域中运行。\n2. 也可以添加多个事件处理程序，不过<font color=\"red\">*不以添加的顺序执行，而以相反的顺序执行*</font>\n\n# 事件对象Event\n\n在触发DOM上的某个事件时，会自动产生一个Event对象，这个对象包含着所有与事件有关的信息，兼容DOM的浏览器会将一个event对象传入事件处理程序中，无论指定事件处理程序时使用的是什么方法。\n\n在事件处理程序内部，对象this的值始终等于currentTarget的值。\n\ncurrentTarget 只读，其事件处理程序当前正在处理事件的那个元素。我觉得就是绑定事件处理程序的元素。\ntarget 只读，事件的目标\nstopPropagation()方法用于立即停止事件在DOM中的传播，即取消进一步的事件捕获或冒泡。如\n\n\tdocument.getElementsByTagName('ul')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t\t// e.stopPropagation();\n\t\t}\n\t\tdocument.getElementsByTagName('body')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t}\n\n输出UL BODY，但是\n\n\tdocument.getElementsByTagName('ul')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t\te.stopPropagation();\n\t\t}\n\t\tdocument.getElementsByTagName('body')[0].onclick=function(e){\n\t\t\tconsole.log(this.nodeName);\n\t\t}\n只输出UL，事件在ul之后不会继续向上传播。\n\neventPhase()输出事件正在处于事件流的哪个阶段，1代表事件捕获阶段，2代码处于目标对象，3代表冒泡阶段\n\n# 可以冒泡的事件和不能冒泡的事件\n不能冒泡的事件\nabort\nblur\nerror\nfocus\nload\nmouseenter\nmouseleave\nresize\nunload\n可以冒泡的事件\nbeforeinput\nclick\ncompositionstart\ncompositionupdate\ncompositionend\ndblclick\nfocusin\nfocusout\ninput\nkeydown\nkeyup\nmousedown\nmousemove\nmouseout\t\nmouseover\nmouseup\nscroll\nselect\nwheel","slug":"JavaScript事件","published":1,"updated":"2016-07-19T13:20:52.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmfk00071kvsqgu63x5g","content":"<h1 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h1><ol>\n<li>JavaScript和html的交互是通过事件完成的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</li>\n<li>事件流是指从页面中接收事件的顺序</li>\n<li>IE是事件冒泡流：事件开始时从具体的元素接收，逐级向上传播到较为不具体的节点（文档）<br>Netscape是事件捕获流：不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件</li>\n<li>所有现代浏览器都支持事件冒泡，可以放心的使用事件冒泡，在有特殊需要时再使用事件捕获。<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h1><p>“DOM2级事件”规定事件流包括三个阶段：事件捕获阶段，出于目标阶段和事件冒泡阶段。<br>第一阶段是事件捕获，为截获事件提供了机会，最后一个阶段是冒泡阶段，可以在这阶段对事件作出响应。<br>在DOM事件流中，实际的目标在捕获阶段不会接收到事件。下一阶段是“出于目标”阶段，于是事件在目标上发生，并在事件处理中被看成冒泡阶段的一部分。</p>\n<h1 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h1><p>响应某个事件的函数叫做事件处理程序（或事件侦听器）。</p>\n<p>一 DOM0级事件处理程序：<br>将一个函数赋值给一个事件处理程序属性。这种方式有两个优点：</p>\n<ol>\n<li>简单</li>\n<li>具有跨浏览器的优势<br>使用DOM级方法指定的事件处理程序被认为是元素的方法。因此，这时的事件处理程序是在元素的作用域中运行的，即，程序中的this指向当前元素。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</li>\n</ol>\n<p>二 DOM2级事件处理程序<br>addEventListener()和removeEventListener()<br>有三个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值，true是在捕获阶段调用，false是在冒泡阶段调用。<br>优点：<br>可以添加多个事件处理程序，同一事件的事件处理程序按添加的顺序执行。</p>\n<p>三 ie中的事件处理程序(ie8及以前)<br>attachEvent()和detachEvent()</p>\n<p>在ie中使用attachEvent()添加事件处理程序与DOM0级方法添加的方式的主要区别在于：</p>\n<ol>\n<li>在使用DOM0级方法添加的时候，事件处理程序的作用域是其所属的元素作用域，而使用attachEvent方式添加，事件处理程序会在全局作用域中运行。</li>\n<li>也可以添加多个事件处理程序，不过<font color=\"red\"><em>不以添加的顺序执行，而以相反的顺序执行</em></font></li>\n</ol>\n<h1 id=\"事件对象Event\"><a href=\"#事件对象Event\" class=\"headerlink\" title=\"事件对象Event\"></a>事件对象Event</h1><p>在触发DOM上的某个事件时，会自动产生一个Event对象，这个对象包含着所有与事件有关的信息，兼容DOM的浏览器会将一个event对象传入事件处理程序中，无论指定事件处理程序时使用的是什么方法。</p>\n<p>在事件处理程序内部，对象this的值始终等于currentTarget的值。</p>\n<p>currentTarget 只读，其事件处理程序当前正在处理事件的那个元素。我觉得就是绑定事件处理程序的元素。<br>target 只读，事件的目标<br>stopPropagation()方法用于立即停止事件在DOM中的传播，即取消进一步的事件捕获或冒泡。如</p>\n<pre><code>document.getElementsByTagName(&apos;ul&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n        // e.stopPropagation();\n    }\n    document.getElementsByTagName(&apos;body&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n    }\n</code></pre><p>输出UL BODY，但是</p>\n<pre><code>document.getElementsByTagName(&apos;ul&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n        e.stopPropagation();\n    }\n    document.getElementsByTagName(&apos;body&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n    }\n</code></pre><p>只输出UL，事件在ul之后不会继续向上传播。</p>\n<p>eventPhase()输出事件正在处于事件流的哪个阶段，1代表事件捕获阶段，2代码处于目标对象，3代表冒泡阶段</p>\n<h1 id=\"可以冒泡的事件和不能冒泡的事件\"><a href=\"#可以冒泡的事件和不能冒泡的事件\" class=\"headerlink\" title=\"可以冒泡的事件和不能冒泡的事件\"></a>可以冒泡的事件和不能冒泡的事件</h1><p>不能冒泡的事件<br>abort<br>blur<br>error<br>focus<br>load<br>mouseenter<br>mouseleave<br>resize<br>unload<br>可以冒泡的事件<br>beforeinput<br>click<br>compositionstart<br>compositionupdate<br>compositionend<br>dblclick<br>focusin<br>focusout<br>input<br>keydown<br>keyup<br>mousedown<br>mousemove<br>mouseout<br>mouseover<br>mouseup<br>scroll<br>select<br>wheel</p>\n","excerpt":"<h1 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h1><ol>\n<li>JavaScript和html的交互是通过事件完成的。事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</li>\n<li>事件流是指从页面中接收事件的顺序</li>\n<li>IE是事件冒泡流：事件开始时从具体的元素接收，逐级向上传播到较为不具体的节点（文档）<br>Netscape是事件捕获流：不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件</li>\n<li>所有现代浏览器都支持事件冒泡，可以放心的使用事件冒泡，在有特殊需要时再使用事件捕获。","more":"</li>\n</ol>\n<h1 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h1><p>“DOM2级事件”规定事件流包括三个阶段：事件捕获阶段，出于目标阶段和事件冒泡阶段。<br>第一阶段是事件捕获，为截获事件提供了机会，最后一个阶段是冒泡阶段，可以在这阶段对事件作出响应。<br>在DOM事件流中，实际的目标在捕获阶段不会接收到事件。下一阶段是“出于目标”阶段，于是事件在目标上发生，并在事件处理中被看成冒泡阶段的一部分。</p>\n<h1 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h1><p>响应某个事件的函数叫做事件处理程序（或事件侦听器）。</p>\n<p>一 DOM0级事件处理程序：<br>将一个函数赋值给一个事件处理程序属性。这种方式有两个优点：</p>\n<ol>\n<li>简单</li>\n<li>具有跨浏览器的优势<br>使用DOM级方法指定的事件处理程序被认为是元素的方法。因此，这时的事件处理程序是在元素的作用域中运行的，即，程序中的this指向当前元素。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</li>\n</ol>\n<p>二 DOM2级事件处理程序<br>addEventListener()和removeEventListener()<br>有三个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值，true是在捕获阶段调用，false是在冒泡阶段调用。<br>优点：<br>可以添加多个事件处理程序，同一事件的事件处理程序按添加的顺序执行。</p>\n<p>三 ie中的事件处理程序(ie8及以前)<br>attachEvent()和detachEvent()</p>\n<p>在ie中使用attachEvent()添加事件处理程序与DOM0级方法添加的方式的主要区别在于：</p>\n<ol>\n<li>在使用DOM0级方法添加的时候，事件处理程序的作用域是其所属的元素作用域，而使用attachEvent方式添加，事件处理程序会在全局作用域中运行。</li>\n<li>也可以添加多个事件处理程序，不过<font color=\"red\"><em>不以添加的顺序执行，而以相反的顺序执行</em></font></li>\n</ol>\n<h1 id=\"事件对象Event\"><a href=\"#事件对象Event\" class=\"headerlink\" title=\"事件对象Event\"></a>事件对象Event</h1><p>在触发DOM上的某个事件时，会自动产生一个Event对象，这个对象包含着所有与事件有关的信息，兼容DOM的浏览器会将一个event对象传入事件处理程序中，无论指定事件处理程序时使用的是什么方法。</p>\n<p>在事件处理程序内部，对象this的值始终等于currentTarget的值。</p>\n<p>currentTarget 只读，其事件处理程序当前正在处理事件的那个元素。我觉得就是绑定事件处理程序的元素。<br>target 只读，事件的目标<br>stopPropagation()方法用于立即停止事件在DOM中的传播，即取消进一步的事件捕获或冒泡。如</p>\n<pre><code>document.getElementsByTagName(&apos;ul&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n        // e.stopPropagation();\n    }\n    document.getElementsByTagName(&apos;body&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n    }\n</code></pre><p>输出UL BODY，但是</p>\n<pre><code>document.getElementsByTagName(&apos;ul&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n        e.stopPropagation();\n    }\n    document.getElementsByTagName(&apos;body&apos;)[0].onclick=function(e){\n        console.log(this.nodeName);\n    }\n</code></pre><p>只输出UL，事件在ul之后不会继续向上传播。</p>\n<p>eventPhase()输出事件正在处于事件流的哪个阶段，1代表事件捕获阶段，2代码处于目标对象，3代表冒泡阶段</p>\n<h1 id=\"可以冒泡的事件和不能冒泡的事件\"><a href=\"#可以冒泡的事件和不能冒泡的事件\" class=\"headerlink\" title=\"可以冒泡的事件和不能冒泡的事件\"></a>可以冒泡的事件和不能冒泡的事件</h1><p>不能冒泡的事件<br>abort<br>blur<br>error<br>focus<br>load<br>mouseenter<br>mouseleave<br>resize<br>unload<br>可以冒泡的事件<br>beforeinput<br>click<br>compositionstart<br>compositionupdate<br>compositionend<br>dblclick<br>focusin<br>focusout<br>input<br>keydown<br>keyup<br>mousedown<br>mousemove<br>mouseout<br>mouseover<br>mouseup<br>scroll<br>select<br>wheel</p>"},{"title":"降维方法之PCA","date":"2016-06-15T02:33:23.000Z","_content":"# 为什么要降维\n\n  在数据挖掘中，实际起作用的特征往往是未知的，因此在挖掘的过程中为了保证结果的准确性往往会引入大量的特征，但是这些特征包含的信息量各不相同，有些甚至与结果完全不相关，另外，特征之间也不一定是彼此独立的，有些是有交叉的，有共性的，相关的。在很多的应用中，数据特征数量十分庞大，不移除这些无关的特征会预测算法也不会有好的运行效果。\n<!-- more -->\n  通过特征选取，即对特征进行降维，可以减少预测变量的数量，有效地提高算法运行速度，提升预测准确度。降维主要通过两个方面进行，一是去除与结果无关的特征，一是合并相关特征。降维的方法有很多，本文主要介绍主成分分析法。\n\n# 主成分分析法简介\n\n  主成分分析（principal components analysis，PCA）又称：主分量分析，主成分回归分析法。主成分分析是设法将原来众多具有一定相关性（比如P个指标），重新组合成一组新的互相无关的综合指标来代替原来的指标。即主要通过消除相关特征来达到降维的目的。主成分分析实际就是将一些相关变量通过线性组合组合成单一变量来达到降维的目的。\n\n# 使用主成分分析法降维的优缺点\n1. 优点：\n\n （1）可消除评估指标之间的相关影响。因为主成分分析法在对原始数据指标变量进行变换后形成了彼此相互独立的主成分，而且实践证明指标间相关程度越高，主成分分析效果越好。\n\n （2）可减少指标选择的工作量，对于其他评估方法，由于难以消除评估指标间的相关影响，所以选择指标时要花费不少精力，而主成分分析法由于可以消除这种相关影响，所以在指标选择上相对容易些。\n\n （3）主成分分析中各主成分是按方差大小依次排列顺序的，在分析问题时，可以舍弃一部分主成分，只取前面方差较大的几个主成分来代表原变量，从而减少了计算工作量。用主成分分析法作综合评估时，由于选择的原则是累计贡献率≥85%，不至于因为节省了工作量却把关键指标漏掉而影响评估结果。\n\n2. 缺点：\n\n  主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义那么清楚、确切，这是变量降维过程中不得不付出的代价。因此，提取的主成分个数m通常应明显小于原始变量个数p（除非p本身较小），否则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。\n\n# 几何解释\n\n  寻求原指标的线性组合Fi\nF1 = a11X1+a21X2+...+ap1Xp\nF2 = a12X1+a22X2+...+ap2Xp\n...\n  满足如下条件：\n  （1）每个主成分的系数平方和为1，\n  （2）主成分之间互相独立，即无重叠信息cov（Fi,Fj）= 0\n  （3）主成分的方差依次递减，重要性依次递减\n\n# PCA步骤\n\n1. 对原始数据标准化即每一维的数据都减去该维的均值，变换之后每一维的均值都变成了0\n2. 计算相关系数矩阵\n3. 计算协方差矩阵的特征值与特征向量\n4. 选取大的特征值对应的特征向量，得到新的数据集\n\n# 知识准备\n\n1. 对角矩阵(diagonal matrix)是一个主对角线之外的元素皆为 0 的矩阵。对角线上的元素可以为 0 或其他值。矩阵可对角化的充分必要条件为n阶矩阵有n个先行无关的特征向量，或矩阵的每个特征值得重数等于对应特征子空间的（几何）维数\n2. 相似矩阵：设A，B为n阶矩阵，如果有n阶可逆矩阵P存在，使得P^(-1)*A*P=B,则称矩阵A与B相似，记为A~B。若A与B相似，则A与B有着相同的特征方程和特征值。\n3. 若矩阵可对角化，则可按下列步骤来实现:\n(1) 求出的全部特征值;\n(2) 对每一个特征值,设其重数为1,则对应齐次方程组的基础解系由个向量构成, 即为对应的线性无关的特征向量；\n(3) 上面求出的特征向量恰好为矩阵的个线性无关的特征向量;\n4. 因子载荷量\n主成分与变量间的相关系数即因子载荷量的大小和它前面的正负号直接反映了主成分与相关变量之间关系的密切程度和方向，从而可以说明各主成分的意义。\n\n# 问题\n1. 对训练数据进行降维后，如何对测试数据进行降维？\n\n# 比较好的文章\n\nhttp://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html\nhttp://my.oschina.net/gujianhan/blog/225241\nhttp://www.cnblogs.com/zhangchaoyang/articles/2222048.html\nhttp://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from\nhttp://blog.csdn.net/qq1987924/article/details/45965431\nhttp://blog.csdn.net/rogerzhanglijie/article/details/8251359  \n* http://www.tuicool.com/articles/7BN7n2","source":"_posts/PCA.md","raw":"---\ntitle: 降维方法之PCA\ndate: 2016-06-15 10:33:23\ntags: \n  - 数据挖掘\n  - 降维\ncategories:\n  - 学习笔记\n  - 数据挖掘\n---\n# 为什么要降维\n\n  在数据挖掘中，实际起作用的特征往往是未知的，因此在挖掘的过程中为了保证结果的准确性往往会引入大量的特征，但是这些特征包含的信息量各不相同，有些甚至与结果完全不相关，另外，特征之间也不一定是彼此独立的，有些是有交叉的，有共性的，相关的。在很多的应用中，数据特征数量十分庞大，不移除这些无关的特征会预测算法也不会有好的运行效果。\n<!-- more -->\n  通过特征选取，即对特征进行降维，可以减少预测变量的数量，有效地提高算法运行速度，提升预测准确度。降维主要通过两个方面进行，一是去除与结果无关的特征，一是合并相关特征。降维的方法有很多，本文主要介绍主成分分析法。\n\n# 主成分分析法简介\n\n  主成分分析（principal components analysis，PCA）又称：主分量分析，主成分回归分析法。主成分分析是设法将原来众多具有一定相关性（比如P个指标），重新组合成一组新的互相无关的综合指标来代替原来的指标。即主要通过消除相关特征来达到降维的目的。主成分分析实际就是将一些相关变量通过线性组合组合成单一变量来达到降维的目的。\n\n# 使用主成分分析法降维的优缺点\n1. 优点：\n\n （1）可消除评估指标之间的相关影响。因为主成分分析法在对原始数据指标变量进行变换后形成了彼此相互独立的主成分，而且实践证明指标间相关程度越高，主成分分析效果越好。\n\n （2）可减少指标选择的工作量，对于其他评估方法，由于难以消除评估指标间的相关影响，所以选择指标时要花费不少精力，而主成分分析法由于可以消除这种相关影响，所以在指标选择上相对容易些。\n\n （3）主成分分析中各主成分是按方差大小依次排列顺序的，在分析问题时，可以舍弃一部分主成分，只取前面方差较大的几个主成分来代表原变量，从而减少了计算工作量。用主成分分析法作综合评估时，由于选择的原则是累计贡献率≥85%，不至于因为节省了工作量却把关键指标漏掉而影响评估结果。\n\n2. 缺点：\n\n  主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义那么清楚、确切，这是变量降维过程中不得不付出的代价。因此，提取的主成分个数m通常应明显小于原始变量个数p（除非p本身较小），否则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。\n\n# 几何解释\n\n  寻求原指标的线性组合Fi\nF1 = a11X1+a21X2+...+ap1Xp\nF2 = a12X1+a22X2+...+ap2Xp\n...\n  满足如下条件：\n  （1）每个主成分的系数平方和为1，\n  （2）主成分之间互相独立，即无重叠信息cov（Fi,Fj）= 0\n  （3）主成分的方差依次递减，重要性依次递减\n\n# PCA步骤\n\n1. 对原始数据标准化即每一维的数据都减去该维的均值，变换之后每一维的均值都变成了0\n2. 计算相关系数矩阵\n3. 计算协方差矩阵的特征值与特征向量\n4. 选取大的特征值对应的特征向量，得到新的数据集\n\n# 知识准备\n\n1. 对角矩阵(diagonal matrix)是一个主对角线之外的元素皆为 0 的矩阵。对角线上的元素可以为 0 或其他值。矩阵可对角化的充分必要条件为n阶矩阵有n个先行无关的特征向量，或矩阵的每个特征值得重数等于对应特征子空间的（几何）维数\n2. 相似矩阵：设A，B为n阶矩阵，如果有n阶可逆矩阵P存在，使得P^(-1)*A*P=B,则称矩阵A与B相似，记为A~B。若A与B相似，则A与B有着相同的特征方程和特征值。\n3. 若矩阵可对角化，则可按下列步骤来实现:\n(1) 求出的全部特征值;\n(2) 对每一个特征值,设其重数为1,则对应齐次方程组的基础解系由个向量构成, 即为对应的线性无关的特征向量；\n(3) 上面求出的特征向量恰好为矩阵的个线性无关的特征向量;\n4. 因子载荷量\n主成分与变量间的相关系数即因子载荷量的大小和它前面的正负号直接反映了主成分与相关变量之间关系的密切程度和方向，从而可以说明各主成分的意义。\n\n# 问题\n1. 对训练数据进行降维后，如何对测试数据进行降维？\n\n# 比较好的文章\n\nhttp://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html\nhttp://my.oschina.net/gujianhan/blog/225241\nhttp://www.cnblogs.com/zhangchaoyang/articles/2222048.html\nhttp://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from\nhttp://blog.csdn.net/qq1987924/article/details/45965431\nhttp://blog.csdn.net/rogerzhanglijie/article/details/8251359  \n* http://www.tuicool.com/articles/7BN7n2","slug":"PCA","published":1,"updated":"2016-06-21T13:29:06.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmg000081kvspdlau59q","content":"<h1 id=\"为什么要降维\"><a href=\"#为什么要降维\" class=\"headerlink\" title=\"为什么要降维\"></a>为什么要降维</h1><p>  在数据挖掘中，实际起作用的特征往往是未知的，因此在挖掘的过程中为了保证结果的准确性往往会引入大量的特征，但是这些特征包含的信息量各不相同，有些甚至与结果完全不相关，另外，特征之间也不一定是彼此独立的，有些是有交叉的，有共性的，相关的。在很多的应用中，数据特征数量十分庞大，不移除这些无关的特征会预测算法也不会有好的运行效果。<br><a id=\"more\"></a><br>  通过特征选取，即对特征进行降维，可以减少预测变量的数量，有效地提高算法运行速度，提升预测准确度。降维主要通过两个方面进行，一是去除与结果无关的特征，一是合并相关特征。降维的方法有很多，本文主要介绍主成分分析法。</p>\n<h1 id=\"主成分分析法简介\"><a href=\"#主成分分析法简介\" class=\"headerlink\" title=\"主成分分析法简介\"></a>主成分分析法简介</h1><p>  主成分分析（principal components analysis，PCA）又称：主分量分析，主成分回归分析法。主成分分析是设法将原来众多具有一定相关性（比如P个指标），重新组合成一组新的互相无关的综合指标来代替原来的指标。即主要通过消除相关特征来达到降维的目的。主成分分析实际就是将一些相关变量通过线性组合组合成单一变量来达到降维的目的。</p>\n<h1 id=\"使用主成分分析法降维的优缺点\"><a href=\"#使用主成分分析法降维的优缺点\" class=\"headerlink\" title=\"使用主成分分析法降维的优缺点\"></a>使用主成分分析法降维的优缺点</h1><ol>\n<li><p>优点：</p>\n<p>（1）可消除评估指标之间的相关影响。因为主成分分析法在对原始数据指标变量进行变换后形成了彼此相互独立的主成分，而且实践证明指标间相关程度越高，主成分分析效果越好。</p>\n<p>（2）可减少指标选择的工作量，对于其他评估方法，由于难以消除评估指标间的相关影响，所以选择指标时要花费不少精力，而主成分分析法由于可以消除这种相关影响，所以在指标选择上相对容易些。</p>\n<p>（3）主成分分析中各主成分是按方差大小依次排列顺序的，在分析问题时，可以舍弃一部分主成分，只取前面方差较大的几个主成分来代表原变量，从而减少了计算工作量。用主成分分析法作综合评估时，由于选择的原则是累计贡献率≥85%，不至于因为节省了工作量却把关键指标漏掉而影响评估结果。</p>\n</li>\n<li><p>缺点：</p>\n<p>主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义那么清楚、确切，这是变量降维过程中不得不付出的代价。因此，提取的主成分个数m通常应明显小于原始变量个数p（除非p本身较小），否则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。</p>\n</li>\n</ol>\n<h1 id=\"几何解释\"><a href=\"#几何解释\" class=\"headerlink\" title=\"几何解释\"></a>几何解释</h1><p>  寻求原指标的线性组合Fi<br>F1 = a11X1+a21X2+…+ap1Xp<br>F2 = a12X1+a22X2+…+ap2Xp<br>…<br>  满足如下条件：<br>  （1）每个主成分的系数平方和为1，<br>  （2）主成分之间互相独立，即无重叠信息cov（Fi,Fj）= 0<br>  （3）主成分的方差依次递减，重要性依次递减</p>\n<h1 id=\"PCA步骤\"><a href=\"#PCA步骤\" class=\"headerlink\" title=\"PCA步骤\"></a>PCA步骤</h1><ol>\n<li>对原始数据标准化即每一维的数据都减去该维的均值，变换之后每一维的均值都变成了0</li>\n<li>计算相关系数矩阵</li>\n<li>计算协方差矩阵的特征值与特征向量</li>\n<li>选取大的特征值对应的特征向量，得到新的数据集</li>\n</ol>\n<h1 id=\"知识准备\"><a href=\"#知识准备\" class=\"headerlink\" title=\"知识准备\"></a>知识准备</h1><ol>\n<li>对角矩阵(diagonal matrix)是一个主对角线之外的元素皆为 0 的矩阵。对角线上的元素可以为 0 或其他值。矩阵可对角化的充分必要条件为n阶矩阵有n个先行无关的特征向量，或矩阵的每个特征值得重数等于对应特征子空间的（几何）维数</li>\n<li>相似矩阵：设A，B为n阶矩阵，如果有n阶可逆矩阵P存在，使得P^(-1)<em>A</em>P=B,则称矩阵A与B相似，记为A~B。若A与B相似，则A与B有着相同的特征方程和特征值。</li>\n<li>若矩阵可对角化，则可按下列步骤来实现:<br>(1) 求出的全部特征值;<br>(2) 对每一个特征值,设其重数为1,则对应齐次方程组的基础解系由个向量构成, 即为对应的线性无关的特征向量；<br>(3) 上面求出的特征向量恰好为矩阵的个线性无关的特征向量;</li>\n<li>因子载荷量<br>主成分与变量间的相关系数即因子载荷量的大小和它前面的正负号直接反映了主成分与相关变量之间关系的密切程度和方向，从而可以说明各主成分的意义。</li>\n</ol>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>对训练数据进行降维后，如何对测试数据进行降维？</li>\n</ol>\n<h1 id=\"比较好的文章\"><a href=\"#比较好的文章\" class=\"headerlink\" title=\"比较好的文章\"></a>比较好的文章</h1><p><a href=\"http://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html</a><br><a href=\"http://my.oschina.net/gujianhan/blog/225241\" target=\"_blank\" rel=\"external\">http://my.oschina.net/gujianhan/blog/225241</a><br><a href=\"http://www.cnblogs.com/zhangchaoyang/articles/2222048.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zhangchaoyang/articles/2222048.html</a><br><a href=\"http://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from</a><br><a href=\"http://blog.csdn.net/qq1987924/article/details/45965431\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/qq1987924/article/details/45965431</a><br><a href=\"http://blog.csdn.net/rogerzhanglijie/article/details/8251359\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/rogerzhanglijie/article/details/8251359</a>  </p>\n<ul>\n<li><a href=\"http://www.tuicool.com/articles/7BN7n2\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/7BN7n2</a></li>\n</ul>\n","excerpt":"<h1 id=\"为什么要降维\"><a href=\"#为什么要降维\" class=\"headerlink\" title=\"为什么要降维\"></a>为什么要降维</h1><p>  在数据挖掘中，实际起作用的特征往往是未知的，因此在挖掘的过程中为了保证结果的准确性往往会引入大量的特征，但是这些特征包含的信息量各不相同，有些甚至与结果完全不相关，另外，特征之间也不一定是彼此独立的，有些是有交叉的，有共性的，相关的。在很多的应用中，数据特征数量十分庞大，不移除这些无关的特征会预测算法也不会有好的运行效果。<br>","more":"<br>  通过特征选取，即对特征进行降维，可以减少预测变量的数量，有效地提高算法运行速度，提升预测准确度。降维主要通过两个方面进行，一是去除与结果无关的特征，一是合并相关特征。降维的方法有很多，本文主要介绍主成分分析法。</p>\n<h1 id=\"主成分分析法简介\"><a href=\"#主成分分析法简介\" class=\"headerlink\" title=\"主成分分析法简介\"></a>主成分分析法简介</h1><p>  主成分分析（principal components analysis，PCA）又称：主分量分析，主成分回归分析法。主成分分析是设法将原来众多具有一定相关性（比如P个指标），重新组合成一组新的互相无关的综合指标来代替原来的指标。即主要通过消除相关特征来达到降维的目的。主成分分析实际就是将一些相关变量通过线性组合组合成单一变量来达到降维的目的。</p>\n<h1 id=\"使用主成分分析法降维的优缺点\"><a href=\"#使用主成分分析法降维的优缺点\" class=\"headerlink\" title=\"使用主成分分析法降维的优缺点\"></a>使用主成分分析法降维的优缺点</h1><ol>\n<li><p>优点：</p>\n<p>（1）可消除评估指标之间的相关影响。因为主成分分析法在对原始数据指标变量进行变换后形成了彼此相互独立的主成分，而且实践证明指标间相关程度越高，主成分分析效果越好。</p>\n<p>（2）可减少指标选择的工作量，对于其他评估方法，由于难以消除评估指标间的相关影响，所以选择指标时要花费不少精力，而主成分分析法由于可以消除这种相关影响，所以在指标选择上相对容易些。</p>\n<p>（3）主成分分析中各主成分是按方差大小依次排列顺序的，在分析问题时，可以舍弃一部分主成分，只取前面方差较大的几个主成分来代表原变量，从而减少了计算工作量。用主成分分析法作综合评估时，由于选择的原则是累计贡献率≥85%，不至于因为节省了工作量却把关键指标漏掉而影响评估结果。</p>\n</li>\n<li><p>缺点：</p>\n<p>主成分的解释其含义一般多少带有点模糊性，不像原始变量的含义那么清楚、确切，这是变量降维过程中不得不付出的代价。因此，提取的主成分个数m通常应明显小于原始变量个数p（除非p本身较小），否则维数降低的“利”可能抵不过主成分含义不如原始变量清楚的“弊”。</p>\n</li>\n</ol>\n<h1 id=\"几何解释\"><a href=\"#几何解释\" class=\"headerlink\" title=\"几何解释\"></a>几何解释</h1><p>  寻求原指标的线性组合Fi<br>F1 = a11X1+a21X2+…+ap1Xp<br>F2 = a12X1+a22X2+…+ap2Xp<br>…<br>  满足如下条件：<br>  （1）每个主成分的系数平方和为1，<br>  （2）主成分之间互相独立，即无重叠信息cov（Fi,Fj）= 0<br>  （3）主成分的方差依次递减，重要性依次递减</p>\n<h1 id=\"PCA步骤\"><a href=\"#PCA步骤\" class=\"headerlink\" title=\"PCA步骤\"></a>PCA步骤</h1><ol>\n<li>对原始数据标准化即每一维的数据都减去该维的均值，变换之后每一维的均值都变成了0</li>\n<li>计算相关系数矩阵</li>\n<li>计算协方差矩阵的特征值与特征向量</li>\n<li>选取大的特征值对应的特征向量，得到新的数据集</li>\n</ol>\n<h1 id=\"知识准备\"><a href=\"#知识准备\" class=\"headerlink\" title=\"知识准备\"></a>知识准备</h1><ol>\n<li>对角矩阵(diagonal matrix)是一个主对角线之外的元素皆为 0 的矩阵。对角线上的元素可以为 0 或其他值。矩阵可对角化的充分必要条件为n阶矩阵有n个先行无关的特征向量，或矩阵的每个特征值得重数等于对应特征子空间的（几何）维数</li>\n<li>相似矩阵：设A，B为n阶矩阵，如果有n阶可逆矩阵P存在，使得P^(-1)<em>A</em>P=B,则称矩阵A与B相似，记为A~B。若A与B相似，则A与B有着相同的特征方程和特征值。</li>\n<li>若矩阵可对角化，则可按下列步骤来实现:<br>(1) 求出的全部特征值;<br>(2) 对每一个特征值,设其重数为1,则对应齐次方程组的基础解系由个向量构成, 即为对应的线性无关的特征向量；<br>(3) 上面求出的特征向量恰好为矩阵的个线性无关的特征向量;</li>\n<li>因子载荷量<br>主成分与变量间的相关系数即因子载荷量的大小和它前面的正负号直接反映了主成分与相关变量之间关系的密切程度和方向，从而可以说明各主成分的意义。</li>\n</ol>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>对训练数据进行降维后，如何对测试数据进行降维？</li>\n</ol>\n<h1 id=\"比较好的文章\"><a href=\"#比较好的文章\" class=\"headerlink\" title=\"比较好的文章\"></a>比较好的文章</h1><p><a href=\"http://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html\">http://blog.sina.com.cn/s/blog_61b8694b0101jg4f.html</a><br><a href=\"http://my.oschina.net/gujianhan/blog/225241\">http://my.oschina.net/gujianhan/blog/225241</a><br><a href=\"http://www.cnblogs.com/zhangchaoyang/articles/2222048.html\">http://www.cnblogs.com/zhangchaoyang/articles/2222048.html</a><br><a href=\"http://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from\">http://wenku.baidu.com/view/f786f6be1a37f111f1855bf7.html?from</a><br><a href=\"http://blog.csdn.net/qq1987924/article/details/45965431\">http://blog.csdn.net/qq1987924/article/details/45965431</a><br><a href=\"http://blog.csdn.net/rogerzhanglijie/article/details/8251359\">http://blog.csdn.net/rogerzhanglijie/article/details/8251359</a>  </p>\n<ul>\n<li><a href=\"http://www.tuicool.com/articles/7BN7n2\">http://www.tuicool.com/articles/7BN7n2</a></li>\n</ul>"},{"title":"mongodb","_content":"本文介绍一些与mongodb相关的package\n## mongodb\nThe official MongoDB driver for Node.js\n## mongoose\nMongoose MongoDB ODM\nMongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.\n\n## connect-mongo \nMongoDB session store for Express and Connect","source":"_drafts/mongodb.md","raw":"---\ntitle: mongodb\ntags: mongodb\n---\n本文介绍一些与mongodb相关的package\n## mongodb\nThe official MongoDB driver for Node.js\n## mongoose\nMongoose MongoDB ODM\nMongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.\n\n## connect-mongo \nMongoDB session store for Express and Connect","slug":"mongodb","published":0,"date":"2016-09-03T14:30:43.968Z","updated":"2016-09-03T14:33:04.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmg0000a1kvsgvbmc3bm","content":"<p>本文介绍一些与mongodb相关的package</p>\n<h2 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h2><p>The official MongoDB driver for Node.js</p>\n<h2 id=\"mongoose\"><a href=\"#mongoose\" class=\"headerlink\" title=\"mongoose\"></a>mongoose</h2><p>Mongoose MongoDB ODM<br>Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.</p>\n<h2 id=\"connect-mongo\"><a href=\"#connect-mongo\" class=\"headerlink\" title=\"connect-mongo\"></a>connect-mongo</h2><p>MongoDB session store for Express and Connect</p>\n","excerpt":"","more":"<p>本文介绍一些与mongodb相关的package</p>\n<h2 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h2><p>The official MongoDB driver for Node.js</p>\n<h2 id=\"mongoose\"><a href=\"#mongoose\" class=\"headerlink\" title=\"mongoose\"></a>mongoose</h2><p>Mongoose MongoDB ODM<br>Mongoose is a MongoDB object modeling tool designed to work in an asynchronous environment.</p>\n<h2 id=\"connect-mongo\"><a href=\"#connect-mongo\" class=\"headerlink\" title=\"connect-mongo\"></a>connect-mongo</h2><p>MongoDB session store for Express and Connect</p>\n"},{"title":"CSS3多列布局","date":"2016-05-18T09:21:45.000Z","_content":"# 主要属性\n## 1 break-after、break-before、break-inside\n描述页面、列或者区域形成一个盒子后的中断行为（即是否中断以及如何中断），如果没有形成一个盒子，这个实行将会被忽略。\n每一个可能的断点（即每一个元素的边界）都是受三个属性的影响：前一个元素的break-after值，下一个元素的break-before值，以包含元素的break-inside值。\n<!-- more -->\n规定断点要遵循以下的规则：\n1. 如果三个值中的任何一个值是强制中断值，即left, right, page, column 或者region，这个值具有优先级，如果有多个强制型的中断值同时出现，那么在流中最后一个出现的值生效。（即break-before的值的优先级高于break-after, break-after的优先级高于break-inside）\n2. 这三个值中的任意一个是避免中断的值，即avoid, avoid-page, avoid-region, avoid-column，那么应用的地方就不会被中断。\n\n一旦应用了强制中断，当需要的时候可以添加软中断，但是不能应用在一个使用了aviod值的元素边界上。\n\n\tInitial value\tauto\n\tApplies to\tblock-level elements\n\tInherited\tno\n\tMedia\tpaged\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n### values\n\n\tauto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\n\n## 2 columns-count\ncolumn-count属性描述元素列的个数。\n\n\tInitial value\tauto\n\tApplies to\tnon-replaced block elements (except table elements), table-cell or inline-block elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas specified\n\tAnimatable\tyes, as an integer\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 3 column-fill\ncolumn-fill属性描述内容是如何被分配到各列中的。\n### values\n\n\tauto | balance\nbalance:每行高度相同。\nauto:只占据内容需要的空间。\n\n\tInitial value\tbalance\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual, but, in continuous media, has no effect in overflow columns\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 4 column-gap\n描述列之间的间距。\n### values\n\n\t<length> | normal\nnormal:浏览器默认间距\n\n\tInitial value\tnormal\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tthe absolute length or the keyword normal\n\tAnimatable\tyes, as a length\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 5 column-row\n在多列布局中column-row指定指定列之间的分割线，是 column-rule-width, column-rule-style and column-rule-color.的简写形式。\n\n\tInitial value\tas each of the properties of the shorthand:\n\tcolumn-rule-width: medium\n\tcolumn-rule-style: none\n\tcolumn-rule-color: currentColor\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas each of the properties of the shorthand:\n\tcolumn-rule-color: If the value is translucent, the computed value will be the rgba() corresponding one. If it isn't, it will be the rgb() corresponding one. The transparent keyword maps to rgba(0,0,0,0).\n\tcolumn-rule-style: as specified\n\tcolumn-rule-width: the absolute length; 0 if the column-rule-style is none or hidden\n\tAnimatable\tas each of the properties of the shorthand:\n\tcolumn-rule-color: yes, as a color\n\tcolumn-rule-style: no\n\tcolumn-rule-width: yes, as a length\n\tCanonical order\torder of appearance in the formal grammar of the values\n### values\n\n\t\t<'column-rule-width'>\n\t\t<length>|thin|medium|thick\n\t\t<'column-rule-style'>\n\t\tnone | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\n\t\t<'column-rule-color'>\n\t\tIs a <color> value.\n\n*取值相当于border*\n\n## 6 column-span\n当一个元素的column-span属性被设置为all时，它可以让这个元素跨越所有列，当一个元素跨越超过一个列时，这个元素叫spanning element。\n\n\tInitial value\tnone\n\tApplies to\tin-flow block-level elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n\n### values\n\tnone | all\n如：\n\n\th1, h2 {\n\t  column-span: all;\n\t}\n## 7 column-width\ncolumn-width在没有column-count的情况下用来计算应该有多少列。比如容器的宽度为500px，column-gap为0，column-width设为400，则只能显示一列，且列的实际宽度为500px。如果column-width设为250px,则显示两列，每列宽度为250px。这时候将column-count设为1则显示一列，设为2显示两列，设为3还是显示两列。（所以应该是每列的最小宽度）\n## 8 columns\ncolumn-width，column-count的缩写\n\n\tInitial value\tas each of the properties of the shorthand:\n\tcolumn-width: auto\n\tcolumn-count: auto\n\tApplies to\tnon-replaced block elements (except table elements), table-cell or inline-block elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas each of the properties of the shorthand:\n\tcolumn-width: the absolute length, zero or larger\n\tcolumn-count: as specified\n\tAnimatable\tas each of the properties of the shorthand:\n\tcolumn-width: yes, as a length\n\tcolumn-count: yes, as an integer\n\tCanonical order\torder of appearance in the formal grammar of the values\n\n<'column-width'> || <'column-count'>\n\n演示 http://slygg.cn/shly/IFE/task_12/index.html","source":"_posts/CSS3多列布局.md","raw":"---\ntitle: CSS3多列布局\ndate: 2016-05-18 17:21:45\ntags: \n  - css3\n  - css3多列布局\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n# 主要属性\n## 1 break-after、break-before、break-inside\n描述页面、列或者区域形成一个盒子后的中断行为（即是否中断以及如何中断），如果没有形成一个盒子，这个实行将会被忽略。\n每一个可能的断点（即每一个元素的边界）都是受三个属性的影响：前一个元素的break-after值，下一个元素的break-before值，以包含元素的break-inside值。\n<!-- more -->\n规定断点要遵循以下的规则：\n1. 如果三个值中的任何一个值是强制中断值，即left, right, page, column 或者region，这个值具有优先级，如果有多个强制型的中断值同时出现，那么在流中最后一个出现的值生效。（即break-before的值的优先级高于break-after, break-after的优先级高于break-inside）\n2. 这三个值中的任意一个是避免中断的值，即avoid, avoid-page, avoid-region, avoid-column，那么应用的地方就不会被中断。\n\n一旦应用了强制中断，当需要的时候可以添加软中断，但是不能应用在一个使用了aviod值的元素边界上。\n\n\tInitial value\tauto\n\tApplies to\tblock-level elements\n\tInherited\tno\n\tMedia\tpaged\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n### values\n\n\tauto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\n\n## 2 columns-count\ncolumn-count属性描述元素列的个数。\n\n\tInitial value\tauto\n\tApplies to\tnon-replaced block elements (except table elements), table-cell or inline-block elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas specified\n\tAnimatable\tyes, as an integer\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 3 column-fill\ncolumn-fill属性描述内容是如何被分配到各列中的。\n### values\n\n\tauto | balance\nbalance:每行高度相同。\nauto:只占据内容需要的空间。\n\n\tInitial value\tbalance\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual, but, in continuous media, has no effect in overflow columns\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 4 column-gap\n描述列之间的间距。\n### values\n\n\t<length> | normal\nnormal:浏览器默认间距\n\n\tInitial value\tnormal\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tthe absolute length or the keyword normal\n\tAnimatable\tyes, as a length\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n## 5 column-row\n在多列布局中column-row指定指定列之间的分割线，是 column-rule-width, column-rule-style and column-rule-color.的简写形式。\n\n\tInitial value\tas each of the properties of the shorthand:\n\tcolumn-rule-width: medium\n\tcolumn-rule-style: none\n\tcolumn-rule-color: currentColor\n\tApplies to\tmulticol elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas each of the properties of the shorthand:\n\tcolumn-rule-color: If the value is translucent, the computed value will be the rgba() corresponding one. If it isn't, it will be the rgb() corresponding one. The transparent keyword maps to rgba(0,0,0,0).\n\tcolumn-rule-style: as specified\n\tcolumn-rule-width: the absolute length; 0 if the column-rule-style is none or hidden\n\tAnimatable\tas each of the properties of the shorthand:\n\tcolumn-rule-color: yes, as a color\n\tcolumn-rule-style: no\n\tcolumn-rule-width: yes, as a length\n\tCanonical order\torder of appearance in the formal grammar of the values\n### values\n\n\t\t<'column-rule-width'>\n\t\t<length>|thin|medium|thick\n\t\t<'column-rule-style'>\n\t\tnone | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\n\t\t<'column-rule-color'>\n\t\tIs a <color> value.\n\n*取值相当于border*\n\n## 6 column-span\n当一个元素的column-span属性被设置为all时，它可以让这个元素跨越所有列，当一个元素跨越超过一个列时，这个元素叫spanning element。\n\n\tInitial value\tnone\n\tApplies to\tin-flow block-level elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas specified\n\tAnimatable\tno\n\tCanonical order\tthe unique non-ambiguous order defined by the formal grammar\n\n### values\n\tnone | all\n如：\n\n\th1, h2 {\n\t  column-span: all;\n\t}\n## 7 column-width\ncolumn-width在没有column-count的情况下用来计算应该有多少列。比如容器的宽度为500px，column-gap为0，column-width设为400，则只能显示一列，且列的实际宽度为500px。如果column-width设为250px,则显示两列，每列宽度为250px。这时候将column-count设为1则显示一列，设为2显示两列，设为3还是显示两列。（所以应该是每列的最小宽度）\n## 8 columns\ncolumn-width，column-count的缩写\n\n\tInitial value\tas each of the properties of the shorthand:\n\tcolumn-width: auto\n\tcolumn-count: auto\n\tApplies to\tnon-replaced block elements (except table elements), table-cell or inline-block elements\n\tInherited\tno\n\tMedia\tvisual\n\tComputed value\tas each of the properties of the shorthand:\n\tcolumn-width: the absolute length, zero or larger\n\tcolumn-count: as specified\n\tAnimatable\tas each of the properties of the shorthand:\n\tcolumn-width: yes, as a length\n\tcolumn-count: yes, as an integer\n\tCanonical order\torder of appearance in the formal grammar of the values\n\n<'column-width'> || <'column-count'>\n\n演示 http://slygg.cn/shly/IFE/task_12/index.html","slug":"CSS3多列布局","published":1,"updated":"2016-05-24T13:20:55.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmgf000d1kvsv9qb4f3l","content":"<h1 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h1><h2 id=\"1-break-after、break-before、break-inside\"><a href=\"#1-break-after、break-before、break-inside\" class=\"headerlink\" title=\"1 break-after、break-before、break-inside\"></a>1 break-after、break-before、break-inside</h2><p>描述页面、列或者区域形成一个盒子后的中断行为（即是否中断以及如何中断），如果没有形成一个盒子，这个实行将会被忽略。<br>每一个可能的断点（即每一个元素的边界）都是受三个属性的影响：前一个元素的break-after值，下一个元素的break-before值，以包含元素的break-inside值。<br><a id=\"more\"></a><br>规定断点要遵循以下的规则：</p>\n<ol>\n<li>如果三个值中的任何一个值是强制中断值，即left, right, page, column 或者region，这个值具有优先级，如果有多个强制型的中断值同时出现，那么在流中最后一个出现的值生效。（即break-before的值的优先级高于break-after, break-after的优先级高于break-inside）</li>\n<li>这三个值中的任意一个是避免中断的值，即avoid, avoid-page, avoid-region, avoid-column，那么应用的地方就不会被中断。</li>\n</ol>\n<p>一旦应用了强制中断，当需要的时候可以添加软中断，但是不能应用在一个使用了aviod值的元素边界上。</p>\n<pre><code>Initial value    auto\nApplies to    block-level elements\nInherited    no\nMedia    paged\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h3 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\n</code></pre><h2 id=\"2-columns-count\"><a href=\"#2-columns-count\" class=\"headerlink\" title=\"2 columns-count\"></a>2 columns-count</h2><p>column-count属性描述元素列的个数。</p>\n<pre><code>Initial value    auto\nApplies to    non-replaced block elements (except table elements), table-cell or inline-block elements\nInherited    no\nMedia    visual\nComputed value    as specified\nAnimatable    yes, as an integer\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"3-column-fill\"><a href=\"#3-column-fill\" class=\"headerlink\" title=\"3 column-fill\"></a>3 column-fill</h2><p>column-fill属性描述内容是如何被分配到各列中的。</p>\n<h3 id=\"values-1\"><a href=\"#values-1\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>auto | balance\n</code></pre><p>balance:每行高度相同。<br>auto:只占据内容需要的空间。</p>\n<pre><code>Initial value    balance\nApplies to    multicol elements\nInherited    no\nMedia    visual, but, in continuous media, has no effect in overflow columns\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"4-column-gap\"><a href=\"#4-column-gap\" class=\"headerlink\" title=\"4 column-gap\"></a>4 column-gap</h2><p>描述列之间的间距。</p>\n<h3 id=\"values-2\"><a href=\"#values-2\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>&lt;length&gt; | normal\n</code></pre><p>normal:浏览器默认间距</p>\n<pre><code>Initial value    normal\nApplies to    multicol elements\nInherited    no\nMedia    visual\nComputed value    the absolute length or the keyword normal\nAnimatable    yes, as a length\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"5-column-row\"><a href=\"#5-column-row\" class=\"headerlink\" title=\"5 column-row\"></a>5 column-row</h2><p>在多列布局中column-row指定指定列之间的分割线，是 column-rule-width, column-rule-style and column-rule-color.的简写形式。</p>\n<pre><code>Initial value    as each of the properties of the shorthand:\ncolumn-rule-width: medium\ncolumn-rule-style: none\ncolumn-rule-color: currentColor\nApplies to    multicol elements\nInherited    no\nMedia    visual\nComputed value    as each of the properties of the shorthand:\ncolumn-rule-color: If the value is translucent, the computed value will be the rgba() corresponding one. If it isn&apos;t, it will be the rgb() corresponding one. The transparent keyword maps to rgba(0,0,0,0).\ncolumn-rule-style: as specified\ncolumn-rule-width: the absolute length; 0 if the column-rule-style is none or hidden\nAnimatable    as each of the properties of the shorthand:\ncolumn-rule-color: yes, as a color\ncolumn-rule-style: no\ncolumn-rule-width: yes, as a length\nCanonical order    order of appearance in the formal grammar of the values\n</code></pre><h3 id=\"values-3\"><a href=\"#values-3\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>&lt;&apos;column-rule-width&apos;&gt;\n&lt;length&gt;|thin|medium|thick\n&lt;&apos;column-rule-style&apos;&gt;\nnone | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\n&lt;&apos;column-rule-color&apos;&gt;\nIs a &lt;color&gt; value.\n</code></pre><p><em>取值相当于border</em></p>\n<h2 id=\"6-column-span\"><a href=\"#6-column-span\" class=\"headerlink\" title=\"6 column-span\"></a>6 column-span</h2><p>当一个元素的column-span属性被设置为all时，它可以让这个元素跨越所有列，当一个元素跨越超过一个列时，这个元素叫spanning element。</p>\n<pre><code>Initial value    none\nApplies to    in-flow block-level elements\nInherited    no\nMedia    visual\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h3 id=\"values-4\"><a href=\"#values-4\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>none | all\n</code></pre><p>如：</p>\n<pre><code>h1, h2 {\n  column-span: all;\n}\n</code></pre><h2 id=\"7-column-width\"><a href=\"#7-column-width\" class=\"headerlink\" title=\"7 column-width\"></a>7 column-width</h2><p>column-width在没有column-count的情况下用来计算应该有多少列。比如容器的宽度为500px，column-gap为0，column-width设为400，则只能显示一列，且列的实际宽度为500px。如果column-width设为250px,则显示两列，每列宽度为250px。这时候将column-count设为1则显示一列，设为2显示两列，设为3还是显示两列。（所以应该是每列的最小宽度）</p>\n<h2 id=\"8-columns\"><a href=\"#8-columns\" class=\"headerlink\" title=\"8 columns\"></a>8 columns</h2><p>column-width，column-count的缩写</p>\n<pre><code>Initial value    as each of the properties of the shorthand:\ncolumn-width: auto\ncolumn-count: auto\nApplies to    non-replaced block elements (except table elements), table-cell or inline-block elements\nInherited    no\nMedia    visual\nComputed value    as each of the properties of the shorthand:\ncolumn-width: the absolute length, zero or larger\ncolumn-count: as specified\nAnimatable    as each of the properties of the shorthand:\ncolumn-width: yes, as a length\ncolumn-count: yes, as an integer\nCanonical order    order of appearance in the formal grammar of the values\n</code></pre><p>&lt;’column-width’&gt; || &lt;’column-count’&gt;</p>\n<p>演示 <a href=\"http://slygg.cn/shly/IFE/task_12/index.html\" target=\"_blank\" rel=\"external\">http://slygg.cn/shly/IFE/task_12/index.html</a></p>\n","excerpt":"<h1 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h1><h2 id=\"1-break-after、break-before、break-inside\"><a href=\"#1-break-after、break-before、break-inside\" class=\"headerlink\" title=\"1 break-after、break-before、break-inside\"></a>1 break-after、break-before、break-inside</h2><p>描述页面、列或者区域形成一个盒子后的中断行为（即是否中断以及如何中断），如果没有形成一个盒子，这个实行将会被忽略。<br>每一个可能的断点（即每一个元素的边界）都是受三个属性的影响：前一个元素的break-after值，下一个元素的break-before值，以包含元素的break-inside值。<br>","more":"<br>规定断点要遵循以下的规则：</p>\n<ol>\n<li>如果三个值中的任何一个值是强制中断值，即left, right, page, column 或者region，这个值具有优先级，如果有多个强制型的中断值同时出现，那么在流中最后一个出现的值生效。（即break-before的值的优先级高于break-after, break-after的优先级高于break-inside）</li>\n<li>这三个值中的任意一个是避免中断的值，即avoid, avoid-page, avoid-region, avoid-column，那么应用的地方就不会被中断。</li>\n</ol>\n<p>一旦应用了强制中断，当需要的时候可以添加软中断，但是不能应用在一个使用了aviod值的元素边界上。</p>\n<pre><code>Initial value    auto\nApplies to    block-level elements\nInherited    no\nMedia    paged\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h3 id=\"values\"><a href=\"#values\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region\n</code></pre><h2 id=\"2-columns-count\"><a href=\"#2-columns-count\" class=\"headerlink\" title=\"2 columns-count\"></a>2 columns-count</h2><p>column-count属性描述元素列的个数。</p>\n<pre><code>Initial value    auto\nApplies to    non-replaced block elements (except table elements), table-cell or inline-block elements\nInherited    no\nMedia    visual\nComputed value    as specified\nAnimatable    yes, as an integer\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"3-column-fill\"><a href=\"#3-column-fill\" class=\"headerlink\" title=\"3 column-fill\"></a>3 column-fill</h2><p>column-fill属性描述内容是如何被分配到各列中的。</p>\n<h3 id=\"values-1\"><a href=\"#values-1\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>auto | balance\n</code></pre><p>balance:每行高度相同。<br>auto:只占据内容需要的空间。</p>\n<pre><code>Initial value    balance\nApplies to    multicol elements\nInherited    no\nMedia    visual, but, in continuous media, has no effect in overflow columns\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"4-column-gap\"><a href=\"#4-column-gap\" class=\"headerlink\" title=\"4 column-gap\"></a>4 column-gap</h2><p>描述列之间的间距。</p>\n<h3 id=\"values-2\"><a href=\"#values-2\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>&lt;length&gt; | normal\n</code></pre><p>normal:浏览器默认间距</p>\n<pre><code>Initial value    normal\nApplies to    multicol elements\nInherited    no\nMedia    visual\nComputed value    the absolute length or the keyword normal\nAnimatable    yes, as a length\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h2 id=\"5-column-row\"><a href=\"#5-column-row\" class=\"headerlink\" title=\"5 column-row\"></a>5 column-row</h2><p>在多列布局中column-row指定指定列之间的分割线，是 column-rule-width, column-rule-style and column-rule-color.的简写形式。</p>\n<pre><code>Initial value    as each of the properties of the shorthand:\ncolumn-rule-width: medium\ncolumn-rule-style: none\ncolumn-rule-color: currentColor\nApplies to    multicol elements\nInherited    no\nMedia    visual\nComputed value    as each of the properties of the shorthand:\ncolumn-rule-color: If the value is translucent, the computed value will be the rgba() corresponding one. If it isn&apos;t, it will be the rgb() corresponding one. The transparent keyword maps to rgba(0,0,0,0).\ncolumn-rule-style: as specified\ncolumn-rule-width: the absolute length; 0 if the column-rule-style is none or hidden\nAnimatable    as each of the properties of the shorthand:\ncolumn-rule-color: yes, as a color\ncolumn-rule-style: no\ncolumn-rule-width: yes, as a length\nCanonical order    order of appearance in the formal grammar of the values\n</code></pre><h3 id=\"values-3\"><a href=\"#values-3\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>&lt;&apos;column-rule-width&apos;&gt;\n&lt;length&gt;|thin|medium|thick\n&lt;&apos;column-rule-style&apos;&gt;\nnone | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\n&lt;&apos;column-rule-color&apos;&gt;\nIs a &lt;color&gt; value.\n</code></pre><p><em>取值相当于border</em></p>\n<h2 id=\"6-column-span\"><a href=\"#6-column-span\" class=\"headerlink\" title=\"6 column-span\"></a>6 column-span</h2><p>当一个元素的column-span属性被设置为all时，它可以让这个元素跨越所有列，当一个元素跨越超过一个列时，这个元素叫spanning element。</p>\n<pre><code>Initial value    none\nApplies to    in-flow block-level elements\nInherited    no\nMedia    visual\nComputed value    as specified\nAnimatable    no\nCanonical order    the unique non-ambiguous order defined by the formal grammar\n</code></pre><h3 id=\"values-4\"><a href=\"#values-4\" class=\"headerlink\" title=\"values\"></a>values</h3><pre><code>none | all\n</code></pre><p>如：</p>\n<pre><code>h1, h2 {\n  column-span: all;\n}\n</code></pre><h2 id=\"7-column-width\"><a href=\"#7-column-width\" class=\"headerlink\" title=\"7 column-width\"></a>7 column-width</h2><p>column-width在没有column-count的情况下用来计算应该有多少列。比如容器的宽度为500px，column-gap为0，column-width设为400，则只能显示一列，且列的实际宽度为500px。如果column-width设为250px,则显示两列，每列宽度为250px。这时候将column-count设为1则显示一列，设为2显示两列，设为3还是显示两列。（所以应该是每列的最小宽度）</p>\n<h2 id=\"8-columns\"><a href=\"#8-columns\" class=\"headerlink\" title=\"8 columns\"></a>8 columns</h2><p>column-width，column-count的缩写</p>\n<pre><code>Initial value    as each of the properties of the shorthand:\ncolumn-width: auto\ncolumn-count: auto\nApplies to    non-replaced block elements (except table elements), table-cell or inline-block elements\nInherited    no\nMedia    visual\nComputed value    as each of the properties of the shorthand:\ncolumn-width: the absolute length, zero or larger\ncolumn-count: as specified\nAnimatable    as each of the properties of the shorthand:\ncolumn-width: yes, as a length\ncolumn-count: yes, as an integer\nCanonical order    order of appearance in the formal grammar of the values\n</code></pre><p>&lt;’column-width’&gt; || &lt;’column-count’&gt;</p>\n<p>演示 <a href=\"http://slygg.cn/shly/IFE/task_12/index.html\">http://slygg.cn/shly/IFE/task_12/index.html</a></p>"},{"title":"CSS中的BFC","date":"2016-05-17T07:49:22.000Z","_content":"本文主要参考  http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\n\n# 什么是BFC\nBFC（Block Formatting Context）块级格式化上下文。W3C定义如下：“浮动，绝对定位元素，inline-blocks, table-cells, table-captions,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。”\n<!-- more -->\nBFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。\n一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：\n\n1. float的值不为none；\n2. position的值不为static或者relative；（还有absolute和fixed）\n3. display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个；\n4. overflow的值不为visible\n*根元素也会生成一个BFC*\n\n# BFC布局规则\n\n1. 内部的Box会在垂直方向，一个接一个地放置。\n2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC的区域不会与float box重叠。\n5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算BFC的高度时，浮动元素也参与计算\n\n# BFC的用处\n1. BFC中的盒子对齐  \nW3C描述如下：\n在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。\n（一个盒子的边框会由于浮动而收缩的意思是，如果将float属性的值设置为left或right，元素就会向其父元素的左侧或右侧靠紧，同时默认情况下，盒子的宽度不在伸展，而是根据盒子里面的内容的宽度来确定。）\n所有属于同一个BFC的盒子都左对齐（左至右的格式），他们的左外边框紧贴着包含块的左边框。在最后一个盒子里我们可以看到尽管那里有一个浮动元素（棕色）在它的左边，另一个元素（绿色）仍然紧贴着包含块的左边框。\n2. 使用BFC来防止外边距折叠\n毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。\n3. 使用BFC来包含浮动：一个BFC可以包含浮动\n4. 使用BFC来防止文字环绕\n首先解释为什么会产生文字环绕的现象。当一个元素浮动之后，它就会脱离当前的文档流，它后面的盒子会越过它与前一个盒子对齐，在同一个BFC中，后面这个盒子的左边框会与包含框的左边框重合。而这个浮动的盒子会漂浮在后面盒子的上方，后面的盒子的文本行会进行收缩来为浮动元素提供空间。随着文字的增多，超过了浮动元素的高度时，文本行不需要收缩了，就产生了环绕的效果。当给后面盒子创建一个新的BFC后，它左边框变不需要紧挨着包含框，整个盒子收缩而不只是文本行收缩，所以就不会再产生文字环绕的现象。\n\n5. 在多列布局中使用BFC\n\n\t\t.column{\n\t\t    width: 31.33%;\n\t\t    background-color: green;\n\t\t    float: left;\n\t\t    margin: 0 1%;\n\t\t}\n\t\t.column:last-child{\n\t\t    float: none;\n\t\t    overflow: hidden; \n\t\t}\n\n# BFC模式的触发\n\n一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。但注意：\n\n1. display:table可能会产生一些问题\n2. overflow:scroll可能会显示不必要的滚动条\n3. float:left将会把元素置于容器的左边，其他元素环绕着它\n4. overflow:hidden将会剪切掉溢出的元素\n","source":"_posts/BFC.md","raw":"---\ntitle: CSS中的BFC\ndate: 2016-05-17 15:49:22\ntags: \n  - BFC\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n本文主要参考  http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\n\n# 什么是BFC\nBFC（Block Formatting Context）块级格式化上下文。W3C定义如下：“浮动，绝对定位元素，inline-blocks, table-cells, table-captions,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。”\n<!-- more -->\nBFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。\n一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：\n\n1. float的值不为none；\n2. position的值不为static或者relative；（还有absolute和fixed）\n3. display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个；\n4. overflow的值不为visible\n*根元素也会生成一个BFC*\n\n# BFC布局规则\n\n1. 内部的Box会在垂直方向，一个接一个地放置。\n2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n4. BFC的区域不会与float box重叠。\n5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n6. 计算BFC的高度时，浮动元素也参与计算\n\n# BFC的用处\n1. BFC中的盒子对齐  \nW3C描述如下：\n在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。\n（一个盒子的边框会由于浮动而收缩的意思是，如果将float属性的值设置为left或right，元素就会向其父元素的左侧或右侧靠紧，同时默认情况下，盒子的宽度不在伸展，而是根据盒子里面的内容的宽度来确定。）\n所有属于同一个BFC的盒子都左对齐（左至右的格式），他们的左外边框紧贴着包含块的左边框。在最后一个盒子里我们可以看到尽管那里有一个浮动元素（棕色）在它的左边，另一个元素（绿色）仍然紧贴着包含块的左边框。\n2. 使用BFC来防止外边距折叠\n毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。\n3. 使用BFC来包含浮动：一个BFC可以包含浮动\n4. 使用BFC来防止文字环绕\n首先解释为什么会产生文字环绕的现象。当一个元素浮动之后，它就会脱离当前的文档流，它后面的盒子会越过它与前一个盒子对齐，在同一个BFC中，后面这个盒子的左边框会与包含框的左边框重合。而这个浮动的盒子会漂浮在后面盒子的上方，后面的盒子的文本行会进行收缩来为浮动元素提供空间。随着文字的增多，超过了浮动元素的高度时，文本行不需要收缩了，就产生了环绕的效果。当给后面盒子创建一个新的BFC后，它左边框变不需要紧挨着包含框，整个盒子收缩而不只是文本行收缩，所以就不会再产生文字环绕的现象。\n\n5. 在多列布局中使用BFC\n\n\t\t.column{\n\t\t    width: 31.33%;\n\t\t    background-color: green;\n\t\t    float: left;\n\t\t    margin: 0 1%;\n\t\t}\n\t\t.column:last-child{\n\t\t    float: none;\n\t\t    overflow: hidden; \n\t\t}\n\n# BFC模式的触发\n\n一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。但注意：\n\n1. display:table可能会产生一些问题\n2. overflow:scroll可能会显示不必要的滚动条\n3. float:left将会把元素置于容器的左边，其他元素环绕着它\n4. overflow:hidden将会剪切掉溢出的元素\n","slug":"BFC","published":1,"updated":"2016-05-17T14:16:37.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmgf000e1kvsjotm0jx0","content":"<p>本文主要参考  <a href=\"http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"external\">http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html</a></p>\n<h1 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h1><p>BFC（Block Formatting Context）块级格式化上下文。W3C定义如下：“浮动，绝对定位元素，inline-blocks, table-cells, table-captions,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。”<br><a id=\"more\"></a><br>BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。<br>一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：</p>\n<ol>\n<li>float的值不为none；</li>\n<li>position的值不为static或者relative；（还有absolute和fixed）</li>\n<li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个；</li>\n<li>overflow的值不为visible<br><em>根元素也会生成一个BFC</em></li>\n</ol>\n<h1 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则\"></a>BFC布局规则</h1><ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h1 id=\"BFC的用处\"><a href=\"#BFC的用处\" class=\"headerlink\" title=\"BFC的用处\"></a>BFC的用处</h1><ol>\n<li>BFC中的盒子对齐<br>W3C描述如下：<br>在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。<br>（一个盒子的边框会由于浮动而收缩的意思是，如果将float属性的值设置为left或right，元素就会向其父元素的左侧或右侧靠紧，同时默认情况下，盒子的宽度不在伸展，而是根据盒子里面的内容的宽度来确定。）<br>所有属于同一个BFC的盒子都左对齐（左至右的格式），他们的左外边框紧贴着包含块的左边框。在最后一个盒子里我们可以看到尽管那里有一个浮动元素（棕色）在它的左边，另一个元素（绿色）仍然紧贴着包含块的左边框。</li>\n<li>使用BFC来防止外边距折叠<br>毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。</li>\n<li>使用BFC来包含浮动：一个BFC可以包含浮动</li>\n<li><p>使用BFC来防止文字环绕<br>首先解释为什么会产生文字环绕的现象。当一个元素浮动之后，它就会脱离当前的文档流，它后面的盒子会越过它与前一个盒子对齐，在同一个BFC中，后面这个盒子的左边框会与包含框的左边框重合。而这个浮动的盒子会漂浮在后面盒子的上方，后面的盒子的文本行会进行收缩来为浮动元素提供空间。随着文字的增多，超过了浮动元素的高度时，文本行不需要收缩了，就产生了环绕的效果。当给后面盒子创建一个新的BFC后，它左边框变不需要紧挨着包含框，整个盒子收缩而不只是文本行收缩，所以就不会再产生文字环绕的现象。</p>\n</li>\n<li><p>在多列布局中使用BFC</p>\n<pre><code>.column{\n    width: 31.33%;\n    background-color: green;\n    float: left;\n    margin: 0 1%;\n}\n.column:last-child{\n    float: none;\n    overflow: hidden; \n}\n</code></pre></li>\n</ol>\n<h1 id=\"BFC模式的触发\"><a href=\"#BFC模式的触发\" class=\"headerlink\" title=\"BFC模式的触发\"></a>BFC模式的触发</h1><p>一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。但注意：</p>\n<ol>\n<li>display:table可能会产生一些问题</li>\n<li>overflow:scroll可能会显示不必要的滚动条</li>\n<li>float:left将会把元素置于容器的左边，其他元素环绕着它</li>\n<li>overflow:hidden将会剪切掉溢出的元素</li>\n</ol>\n","excerpt":"<p>本文主要参考  <a href=\"http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\">http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html</a></p>\n<h1 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h1><p>BFC（Block Formatting Context）块级格式化上下文。W3C定义如下：“浮动，绝对定位元素，inline-blocks, table-cells, table-captions,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。”<br>","more":"<br>BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。<br>一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：</p>\n<ol>\n<li>float的值不为none；</li>\n<li>position的值不为static或者relative；（还有absolute和fixed）</li>\n<li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个；</li>\n<li>overflow的值不为visible<br><em>根元素也会生成一个BFC</em></li>\n</ol>\n<h1 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则\"></a>BFC布局规则</h1><ol>\n<li>内部的Box会在垂直方向，一个接一个地放置。</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>\n<li>BFC的区域不会与float box重叠。</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h1 id=\"BFC的用处\"><a href=\"#BFC的用处\" class=\"headerlink\" title=\"BFC的用处\"></a>BFC的用处</h1><ol>\n<li>BFC中的盒子对齐<br>W3C描述如下：<br>在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。<br>（一个盒子的边框会由于浮动而收缩的意思是，如果将float属性的值设置为left或right，元素就会向其父元素的左侧或右侧靠紧，同时默认情况下，盒子的宽度不在伸展，而是根据盒子里面的内容的宽度来确定。）<br>所有属于同一个BFC的盒子都左对齐（左至右的格式），他们的左外边框紧贴着包含块的左边框。在最后一个盒子里我们可以看到尽管那里有一个浮动元素（棕色）在它的左边，另一个元素（绿色）仍然紧贴着包含块的左边框。</li>\n<li>使用BFC来防止外边距折叠<br>毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。</li>\n<li>使用BFC来包含浮动：一个BFC可以包含浮动</li>\n<li><p>使用BFC来防止文字环绕<br>首先解释为什么会产生文字环绕的现象。当一个元素浮动之后，它就会脱离当前的文档流，它后面的盒子会越过它与前一个盒子对齐，在同一个BFC中，后面这个盒子的左边框会与包含框的左边框重合。而这个浮动的盒子会漂浮在后面盒子的上方，后面的盒子的文本行会进行收缩来为浮动元素提供空间。随着文字的增多，超过了浮动元素的高度时，文本行不需要收缩了，就产生了环绕的效果。当给后面盒子创建一个新的BFC后，它左边框变不需要紧挨着包含框，整个盒子收缩而不只是文本行收缩，所以就不会再产生文字环绕的现象。</p>\n</li>\n<li><p>在多列布局中使用BFC</p>\n<pre><code>.column{\n    width: 31.33%;\n    background-color: green;\n    float: left;\n    margin: 0 1%;\n}\n.column:last-child{\n    float: none;\n    overflow: hidden; \n}\n</code></pre></li>\n</ol>\n<h1 id=\"BFC模式的触发\"><a href=\"#BFC模式的触发\" class=\"headerlink\" title=\"BFC模式的触发\"></a>BFC模式的触发</h1><p>一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。但注意：</p>\n<ol>\n<li>display:table可能会产生一些问题</li>\n<li>overflow:scroll可能会显示不必要的滚动条</li>\n<li>float:left将会把元素置于容器的左边，其他元素环绕着它</li>\n<li>overflow:hidden将会剪切掉溢出的元素</li>\n</ol>"},{"title":"ROC与AUC","date":"2016-06-01T12:51:06.000Z","_content":"这篇文章只要是介绍分类算法评估标准，介绍标准之前首先介绍一下评价算法的前提，混淆矩阵，如图\n<!--more-->\n![混淆矩阵](/img/roc/1.png)\n目前常用的评价一个分类算法好坏的标准有：\n1. Accuracy：表示预测结果的精确度，预测正确的样本数除以总样本数。（TP+TN）/(TP+FP+FN+TN)\n2. precision，准确率，表示预测结果中，预测为正样本的样本中，正确预测为正样本的概率；TP/(TP+FP)\n3. recall，召回率，表示在原始样本的正样本中，最后被正确预测为正样本的概率；TP/(TP+FN)\n4. specificity，常常称作特异性，它研究的样本集是原始样本中的负样本，表示的是在这些负样本中最后被正确预测为负样本的概率。TN/(FP+TN)\n还有就是这篇文章里面要介绍的ROC曲线和AUC\n\n# 什么是ROC？\n\nROC全称Receiver Operating Characteristic,翻译为\"接受者操作特性曲线\",即ROC为二维平面上的一条曲线，\n横坐标：FPR 假阳率（1-sp） =FP/(TN+FP)\n纵坐标：TPR 真阳率（ recall ）= TP/(TP+FN)\n如图\n![ROC曲线](/img/roc/2.gif)\n\n# ROC曲线有什么优点？\n\n提供不同试验之间在共同标尺下的直观的比较，ROC曲线越凸越近左上角表明其诊断价值越大，利于不同指标间的比较。该方法简单、直观，通过图示可观察分析方法的临床准确性，并可用肉眼作出判断。\n\n# 什么是AUC\nAUC的值就是处于ROC curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。\n0.5~0.7之间时有较低准确性\n0.7~0.9之间有一定准确性\n0.9以上有较高准确性。\n\n![AUC](/img/roc/3.png)\n\n# AUC计算方式\n1. 积分的思想，逐步求面积\n2. 一个关于AUC的很有趣的性质是，它和Wilcoxon-Mann-Witney Test是等价的。Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score。\n统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2 )。n为样本数(即n=M+N)\n![AUC](/img/roc/4.gif)\n3. 方法二的简化，首先把所有样本按照score排序,依次用rank表示他们,如最大score的样本,rank=n(n=N+M),其次为n-1。那么对于正样本中rank最大的样本,rank_max,有M-1个其他正样本比他score小,那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)\n![AUC](/img/roc/5.png)\n\n# ROC与AUC与其他评价方法相比的好处？\nROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。\n","source":"_posts/ROC.md","raw":"---\ntitle: ROC与AUC\ndate: 2016-06-01 20:51:06\ntags: \n  - 数据挖掘\n  - 算法评价指标\ncategories:\n  - 学习笔记\n  - 数据挖掘\n---\n这篇文章只要是介绍分类算法评估标准，介绍标准之前首先介绍一下评价算法的前提，混淆矩阵，如图\n<!--more-->\n![混淆矩阵](/img/roc/1.png)\n目前常用的评价一个分类算法好坏的标准有：\n1. Accuracy：表示预测结果的精确度，预测正确的样本数除以总样本数。（TP+TN）/(TP+FP+FN+TN)\n2. precision，准确率，表示预测结果中，预测为正样本的样本中，正确预测为正样本的概率；TP/(TP+FP)\n3. recall，召回率，表示在原始样本的正样本中，最后被正确预测为正样本的概率；TP/(TP+FN)\n4. specificity，常常称作特异性，它研究的样本集是原始样本中的负样本，表示的是在这些负样本中最后被正确预测为负样本的概率。TN/(FP+TN)\n还有就是这篇文章里面要介绍的ROC曲线和AUC\n\n# 什么是ROC？\n\nROC全称Receiver Operating Characteristic,翻译为\"接受者操作特性曲线\",即ROC为二维平面上的一条曲线，\n横坐标：FPR 假阳率（1-sp） =FP/(TN+FP)\n纵坐标：TPR 真阳率（ recall ）= TP/(TP+FN)\n如图\n![ROC曲线](/img/roc/2.gif)\n\n# ROC曲线有什么优点？\n\n提供不同试验之间在共同标尺下的直观的比较，ROC曲线越凸越近左上角表明其诊断价值越大，利于不同指标间的比较。该方法简单、直观，通过图示可观察分析方法的临床准确性，并可用肉眼作出判断。\n\n# 什么是AUC\nAUC的值就是处于ROC curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。\n0.5~0.7之间时有较低准确性\n0.7~0.9之间有一定准确性\n0.9以上有较高准确性。\n\n![AUC](/img/roc/3.png)\n\n# AUC计算方式\n1. 积分的思想，逐步求面积\n2. 一个关于AUC的很有趣的性质是，它和Wilcoxon-Mann-Witney Test是等价的。Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score。\n统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2 )。n为样本数(即n=M+N)\n![AUC](/img/roc/4.gif)\n3. 方法二的简化，首先把所有样本按照score排序,依次用rank表示他们,如最大score的样本,rank=n(n=N+M),其次为n-1。那么对于正样本中rank最大的样本,rank_max,有M-1个其他正样本比他score小,那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)\n![AUC](/img/roc/5.png)\n\n# ROC与AUC与其他评价方法相比的好处？\nROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。\n","slug":"ROC","published":1,"updated":"2016-06-14T13:16:10.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmgw000i1kvsypnp99m2","content":"<p>这篇文章只要是介绍分类算法评估标准，介绍标准之前首先介绍一下评价算法的前提，混淆矩阵，如图<br><a id=\"more\"></a><br><img src=\"/img/roc/1.png\" alt=\"混淆矩阵\"><br>目前常用的评价一个分类算法好坏的标准有：</p>\n<ol>\n<li>Accuracy：表示预测结果的精确度，预测正确的样本数除以总样本数。（TP+TN）/(TP+FP+FN+TN)</li>\n<li>precision，准确率，表示预测结果中，预测为正样本的样本中，正确预测为正样本的概率；TP/(TP+FP)</li>\n<li>recall，召回率，表示在原始样本的正样本中，最后被正确预测为正样本的概率；TP/(TP+FN)</li>\n<li>specificity，常常称作特异性，它研究的样本集是原始样本中的负样本，表示的是在这些负样本中最后被正确预测为负样本的概率。TN/(FP+TN)<br>还有就是这篇文章里面要介绍的ROC曲线和AUC</li>\n</ol>\n<h1 id=\"什么是ROC？\"><a href=\"#什么是ROC？\" class=\"headerlink\" title=\"什么是ROC？\"></a>什么是ROC？</h1><p>ROC全称Receiver Operating Characteristic,翻译为”接受者操作特性曲线”,即ROC为二维平面上的一条曲线，<br>横坐标：FPR 假阳率（1-sp） =FP/(TN+FP)<br>纵坐标：TPR 真阳率（ recall ）= TP/(TP+FN)<br>如图<br><img src=\"/img/roc/2.gif\" alt=\"ROC曲线\"></p>\n<h1 id=\"ROC曲线有什么优点？\"><a href=\"#ROC曲线有什么优点？\" class=\"headerlink\" title=\"ROC曲线有什么优点？\"></a>ROC曲线有什么优点？</h1><p>提供不同试验之间在共同标尺下的直观的比较，ROC曲线越凸越近左上角表明其诊断价值越大，利于不同指标间的比较。该方法简单、直观，通过图示可观察分析方法的临床准确性，并可用肉眼作出判断。</p>\n<h1 id=\"什么是AUC\"><a href=\"#什么是AUC\" class=\"headerlink\" title=\"什么是AUC\"></a>什么是AUC</h1><p>AUC的值就是处于ROC curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。<br>0.5~0.7之间时有较低准确性<br>0.7~0.9之间有一定准确性<br>0.9以上有较高准确性。</p>\n<p><img src=\"/img/roc/3.png\" alt=\"AUC\"></p>\n<h1 id=\"AUC计算方式\"><a href=\"#AUC计算方式\" class=\"headerlink\" title=\"AUC计算方式\"></a>AUC计算方式</h1><ol>\n<li>积分的思想，逐步求面积</li>\n<li>一个关于AUC的很有趣的性质是，它和Wilcoxon-Mann-Witney Test是等价的。Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score。<br>统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2 )。n为样本数(即n=M+N)<br><img src=\"/img/roc/4.gif\" alt=\"AUC\"></li>\n<li>方法二的简化，首先把所有样本按照score排序,依次用rank表示他们,如最大score的样本,rank=n(n=N+M),其次为n-1。那么对于正样本中rank最大的样本,rank_max,有M-1个其他正样本比他score小,那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)<br><img src=\"/img/roc/5.png\" alt=\"AUC\"></li>\n</ol>\n<h1 id=\"ROC与AUC与其他评价方法相比的好处？\"><a href=\"#ROC与AUC与其他评价方法相比的好处？\" class=\"headerlink\" title=\"ROC与AUC与其他评价方法相比的好处？\"></a>ROC与AUC与其他评价方法相比的好处？</h1><p>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。</p>\n","excerpt":"<p>这篇文章只要是介绍分类算法评估标准，介绍标准之前首先介绍一下评价算法的前提，混淆矩阵，如图<br>","more":"<br><img src=\"/img/roc/1.png\" alt=\"混淆矩阵\"><br>目前常用的评价一个分类算法好坏的标准有：</p>\n<ol>\n<li>Accuracy：表示预测结果的精确度，预测正确的样本数除以总样本数。（TP+TN）/(TP+FP+FN+TN)</li>\n<li>precision，准确率，表示预测结果中，预测为正样本的样本中，正确预测为正样本的概率；TP/(TP+FP)</li>\n<li>recall，召回率，表示在原始样本的正样本中，最后被正确预测为正样本的概率；TP/(TP+FN)</li>\n<li>specificity，常常称作特异性，它研究的样本集是原始样本中的负样本，表示的是在这些负样本中最后被正确预测为负样本的概率。TN/(FP+TN)<br>还有就是这篇文章里面要介绍的ROC曲线和AUC</li>\n</ol>\n<h1 id=\"什么是ROC？\"><a href=\"#什么是ROC？\" class=\"headerlink\" title=\"什么是ROC？\"></a>什么是ROC？</h1><p>ROC全称Receiver Operating Characteristic,翻译为”接受者操作特性曲线”,即ROC为二维平面上的一条曲线，<br>横坐标：FPR 假阳率（1-sp） =FP/(TN+FP)<br>纵坐标：TPR 真阳率（ recall ）= TP/(TP+FN)<br>如图<br><img src=\"/img/roc/2.gif\" alt=\"ROC曲线\"></p>\n<h1 id=\"ROC曲线有什么优点？\"><a href=\"#ROC曲线有什么优点？\" class=\"headerlink\" title=\"ROC曲线有什么优点？\"></a>ROC曲线有什么优点？</h1><p>提供不同试验之间在共同标尺下的直观的比较，ROC曲线越凸越近左上角表明其诊断价值越大，利于不同指标间的比较。该方法简单、直观，通过图示可观察分析方法的临床准确性，并可用肉眼作出判断。</p>\n<h1 id=\"什么是AUC\"><a href=\"#什么是AUC\" class=\"headerlink\" title=\"什么是AUC\"></a>什么是AUC</h1><p>AUC的值就是处于ROC curve下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的performance。<br>0.5~0.7之间时有较低准确性<br>0.7~0.9之间有一定准确性<br>0.9以上有较高准确性。</p>\n<p><img src=\"/img/roc/3.png\" alt=\"AUC\"></p>\n<h1 id=\"AUC计算方式\"><a href=\"#AUC计算方式\" class=\"headerlink\" title=\"AUC计算方式\"></a>AUC计算方式</h1><ol>\n<li>积分的思想，逐步求面积</li>\n<li>一个关于AUC的很有趣的性质是，它和Wilcoxon-Mann-Witney Test是等价的。Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score。<br>统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2 )。n为样本数(即n=M+N)<br><img src=\"/img/roc/4.gif\" alt=\"AUC\"></li>\n<li>方法二的简化，首先把所有样本按照score排序,依次用rank表示他们,如最大score的样本,rank=n(n=N+M),其次为n-1。那么对于正样本中rank最大的样本,rank_max,有M-1个其他正样本比他score小,那么就有(rank_max-1)-(M-1)个负样本比他score小。其次为(rank_second-1)-(M-2)<br><img src=\"/img/roc/5.png\" alt=\"AUC\"></li>\n</ol>\n<h1 id=\"ROC与AUC与其他评价方法相比的好处？\"><a href=\"#ROC与AUC与其他评价方法相比的好处？\" class=\"headerlink\" title=\"ROC与AUC与其他评价方法相比的好处？\"></a>ROC与AUC与其他评价方法相比的好处？</h1><p>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现类不平衡（class imbalance）现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化。</p>"},{"title":"makeArray","_content":"\n// results is for internal usage only\n\tmakeArray: function( array, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( array != null ) {\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\t// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n\t\t\tvar type = jQuery.type( array );\n\n\t\t\tif ( array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( array ) ) {\n\t\t\t\tpush.call( ret, array );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, array );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tselector this","source":"_drafts/makeArray.md","raw":"---\ntitle: makeArray\ntags:\n - jQuery源码\ncategories:\n - 学习笔记\n - 前端学习\n---\n\n// results is for internal usage only\n\tmakeArray: function( array, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( array != null ) {\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\t// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n\t\t\tvar type = jQuery.type( array );\n\n\t\t\tif ( array.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( array ) ) {\n\t\t\t\tpush.call( ret, array );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, array );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tselector this","slug":"makeArray","published":0,"date":"2016-07-17T14:36:15.933Z","updated":"2016-07-17T14:41:06.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmgw000j1kvsgz91mosl","content":"<p>// results is for internal usage only<br>    makeArray: function( array, results ) {<br>        var ret = results || [];</p>\n<pre><code>    if ( array != null ) {\n        // The window, strings (and functions) also have &apos;length&apos;\n        // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n        var type = jQuery.type( array );\n\n        if ( array.length == null || type === &quot;string&quot; || type === &quot;function&quot; || type === &quot;regexp&quot; || jQuery.isWindow( array ) ) {\n            push.call( ret, array );\n        } else {\n            jQuery.merge( ret, array );\n        }\n    }\n\n    return ret;\n}\n\nselector this\n</code></pre>","excerpt":"","more":"<p>// results is for internal usage only<br>    makeArray: function( array, results ) {<br>        var ret = results || [];</p>\n<pre><code>    if ( array != null ) {\n        // The window, strings (and functions) also have &apos;length&apos;\n        // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n        var type = jQuery.type( array );\n\n        if ( array.length == null || type === &quot;string&quot; || type === &quot;function&quot; || type === &quot;regexp&quot; || jQuery.isWindow( array ) ) {\n            push.call( ret, array );\n        } else {\n            jQuery.merge( ret, array );\n        }\n    }\n\n    return ret;\n}\n\nselector this\n</code></pre>"},{"title":"css3选择器整理","date":"2016-05-03T08:17:58.000Z","_content":"### 一 基本选择器（基本兼容所有浏览器）\n\n通配选择器 *\n元素选择器 E\n类选择器 .class\nID选择器 #id\n组群选择器\n<!-- more -->\n### 二 层次选择器\n\nE F 后代选择器 （基本兼容所有浏览器）\nE>F 子选择器 （ie7+）\nE+F 相邻兄弟选择器（ie7+）\nE~F 通用选择器匹配位于元素E之后的所有F元素（ie7+）\n\n### 三 伪类选择器\n\n1. 动态伪类选择器:link,:visited,:hover,:active, :focus\n2. 目标伪类选择器:target\n3. 语言伪类选择器E:lang(language)（ie8+）\n4. UI元素状态伪类选择器E:checked E:enabled E:disabled（ie9+）\n5. 结构伪类选择器（ie9+）\n\n 5.1 E:first-child\n 5.2 E:last-child\n 5.3 E:root在html文档中始终为html\n 5.4 E F:nth-child(n) n的起始值为1 F的父元素的第二个子元素\n 5.5 E F:nth-last-child(n)\n 5.6 E:nth-of-type(n)选择父元素内具有指定类型的第n个E元素\n 5.7 E:nth-of-type(n)选择父元素内具有指定类型的倒数第n个E元素\n 5.8 E:first-of-type\n 5.9 E:last-of-type\n 5.10 E:empty\n 5.11 E:only-child父元素只包含一个子元素，且该子元素匹配E元素\n 5.12 E:only-of-type父元素只包含一个同类型的子元素，且该子元素匹配E元素\n\n6. 否定伪类选择器:not()(ie9+)\n\n### 四 伪元素\n\n:first-line,:first-letter,:before,:after，为了与伪类进行区分，CSS3中对此进行了调整，由单冒号变成了双冒号，\n\n::first-line,::first-letter,::before,::after另外新增加了一个伪元素::selection，用于匹配突出显示的文本。\n\n::selection仅接收两个属性 background和color。 ie系列中只有ie9支持，FireFox需要加上其私有属性-moz\n\n如：\n\n\t\t::selection{\n\t\tbackground-color:red;\n\t\tcolor:#FFFFFF;\n\t\t}\n\t\t::-moz-selection{\n\t\tbackground-color:red;\n\t\tcolor:#FFFFFF;\n\t\t}\n\n\n### 五  属性选择器（ie7+）\n\nE[attr]具有attr属性的元素\nE[attr = val]\nE[attr |= val]具有val或者以val-开头\nE[attr ~= val] attr有多个空格分隔的值其中一个为val\nE[attr*=val]attr的任意位置包含了val\nE[attr^=val]属性值以val开头\nE[attr$=val]属性以val结尾\n选择器优先级：\n\n !important>内联>id>class>tag\n\n组合使用选择器的情况下，选择器的权重计算方式为：\n\n标签的权重为1，class的权重为10，id的权重为100\n\n如\n\n\t\tdiv //权重为1\n\t\t.A  //权重为10\n\t\t#A //权重为100\n\t\tdiv.A //权重为11\n相同权重的情况下后面定义的样式会覆盖前面定义的样式，但与html中class的定义的先后无关。如\n\n\t\t<div>\n\t\t    <p class = \"B A\">这里面是文字</p>\n\t\t</div>\n\t\t.A{\n\t\tcolor:red;}\n\t\t.B{\n\t\tcolor:blue;\n\t\t}\n这时因为B的样式信息比A后定义，所以样式信息B会覆盖样式信息A，所以p中的文字会显示为蓝色。与AB在class中定义的顺序无关。\n","source":"_posts/css3选择器整理.md","raw":"---\ntitle: css3选择器整理\ndate: 2016-05-03 16:17:58\ntags: \n  - css3\n  - css3选择器\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n### 一 基本选择器（基本兼容所有浏览器）\n\n通配选择器 *\n元素选择器 E\n类选择器 .class\nID选择器 #id\n组群选择器\n<!-- more -->\n### 二 层次选择器\n\nE F 后代选择器 （基本兼容所有浏览器）\nE>F 子选择器 （ie7+）\nE+F 相邻兄弟选择器（ie7+）\nE~F 通用选择器匹配位于元素E之后的所有F元素（ie7+）\n\n### 三 伪类选择器\n\n1. 动态伪类选择器:link,:visited,:hover,:active, :focus\n2. 目标伪类选择器:target\n3. 语言伪类选择器E:lang(language)（ie8+）\n4. UI元素状态伪类选择器E:checked E:enabled E:disabled（ie9+）\n5. 结构伪类选择器（ie9+）\n\n 5.1 E:first-child\n 5.2 E:last-child\n 5.3 E:root在html文档中始终为html\n 5.4 E F:nth-child(n) n的起始值为1 F的父元素的第二个子元素\n 5.5 E F:nth-last-child(n)\n 5.6 E:nth-of-type(n)选择父元素内具有指定类型的第n个E元素\n 5.7 E:nth-of-type(n)选择父元素内具有指定类型的倒数第n个E元素\n 5.8 E:first-of-type\n 5.9 E:last-of-type\n 5.10 E:empty\n 5.11 E:only-child父元素只包含一个子元素，且该子元素匹配E元素\n 5.12 E:only-of-type父元素只包含一个同类型的子元素，且该子元素匹配E元素\n\n6. 否定伪类选择器:not()(ie9+)\n\n### 四 伪元素\n\n:first-line,:first-letter,:before,:after，为了与伪类进行区分，CSS3中对此进行了调整，由单冒号变成了双冒号，\n\n::first-line,::first-letter,::before,::after另外新增加了一个伪元素::selection，用于匹配突出显示的文本。\n\n::selection仅接收两个属性 background和color。 ie系列中只有ie9支持，FireFox需要加上其私有属性-moz\n\n如：\n\n\t\t::selection{\n\t\tbackground-color:red;\n\t\tcolor:#FFFFFF;\n\t\t}\n\t\t::-moz-selection{\n\t\tbackground-color:red;\n\t\tcolor:#FFFFFF;\n\t\t}\n\n\n### 五  属性选择器（ie7+）\n\nE[attr]具有attr属性的元素\nE[attr = val]\nE[attr |= val]具有val或者以val-开头\nE[attr ~= val] attr有多个空格分隔的值其中一个为val\nE[attr*=val]attr的任意位置包含了val\nE[attr^=val]属性值以val开头\nE[attr$=val]属性以val结尾\n选择器优先级：\n\n !important>内联>id>class>tag\n\n组合使用选择器的情况下，选择器的权重计算方式为：\n\n标签的权重为1，class的权重为10，id的权重为100\n\n如\n\n\t\tdiv //权重为1\n\t\t.A  //权重为10\n\t\t#A //权重为100\n\t\tdiv.A //权重为11\n相同权重的情况下后面定义的样式会覆盖前面定义的样式，但与html中class的定义的先后无关。如\n\n\t\t<div>\n\t\t    <p class = \"B A\">这里面是文字</p>\n\t\t</div>\n\t\t.A{\n\t\tcolor:red;}\n\t\t.B{\n\t\tcolor:blue;\n\t\t}\n这时因为B的样式信息比A后定义，所以样式信息B会覆盖样式信息A，所以p中的文字会显示为蓝色。与AB在class中定义的顺序无关。\n","slug":"css3选择器整理","published":1,"updated":"2016-05-05T14:39:24.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmgw000m1kvs68fpiqwp","content":"<h3 id=\"一-基本选择器（基本兼容所有浏览器）\"><a href=\"#一-基本选择器（基本兼容所有浏览器）\" class=\"headerlink\" title=\"一 基本选择器（基本兼容所有浏览器）\"></a>一 基本选择器（基本兼容所有浏览器）</h3><p>通配选择器 *<br>元素选择器 E<br>类选择器 .class<br>ID选择器 #id<br>组群选择器<br><a id=\"more\"></a></p>\n<h3 id=\"二-层次选择器\"><a href=\"#二-层次选择器\" class=\"headerlink\" title=\"二 层次选择器\"></a>二 层次选择器</h3><p>E F 后代选择器 （基本兼容所有浏览器）<br>E&gt;F 子选择器 （ie7+）<br>E+F 相邻兄弟选择器（ie7+）<br>E~F 通用选择器匹配位于元素E之后的所有F元素（ie7+）</p>\n<h3 id=\"三-伪类选择器\"><a href=\"#三-伪类选择器\" class=\"headerlink\" title=\"三 伪类选择器\"></a>三 伪类选择器</h3><ol>\n<li>动态伪类选择器:link,:visited,:hover,:active, :focus</li>\n<li>目标伪类选择器:target</li>\n<li>语言伪类选择器E:lang(language)（ie8+）</li>\n<li>UI元素状态伪类选择器E:checked E:enabled E:disabled（ie9+）</li>\n<li><p>结构伪类选择器（ie9+）</p>\n<p>5.1 E:first-child<br>5.2 E:last-child<br>5.3 E:root在html文档中始终为html<br>5.4 E F:nth-child(n) n的起始值为1 F的父元素的第二个子元素<br>5.5 E F:nth-last-child(n)<br>5.6 E:nth-of-type(n)选择父元素内具有指定类型的第n个E元素<br>5.7 E:nth-of-type(n)选择父元素内具有指定类型的倒数第n个E元素<br>5.8 E:first-of-type<br>5.9 E:last-of-type<br>5.10 E:empty<br>5.11 E:only-child父元素只包含一个子元素，且该子元素匹配E元素<br>5.12 E:only-of-type父元素只包含一个同类型的子元素，且该子元素匹配E元素</p>\n</li>\n<li><p>否定伪类选择器:not()(ie9+)</p>\n</li>\n</ol>\n<h3 id=\"四-伪元素\"><a href=\"#四-伪元素\" class=\"headerlink\" title=\"四 伪元素\"></a>四 伪元素</h3><p>:first-line,:first-letter,:before,:after，为了与伪类进行区分，CSS3中对此进行了调整，由单冒号变成了双冒号，</p>\n<p>::first-line,::first-letter,::before,::after另外新增加了一个伪元素::selection，用于匹配突出显示的文本。</p>\n<p>::selection仅接收两个属性 background和color。 ie系列中只有ie9支持，FireFox需要加上其私有属性-moz</p>\n<p>如：</p>\n<pre><code>::selection{\nbackground-color:red;\ncolor:#FFFFFF;\n}\n::-moz-selection{\nbackground-color:red;\ncolor:#FFFFFF;\n}\n</code></pre><h3 id=\"五-属性选择器（ie7-）\"><a href=\"#五-属性选择器（ie7-）\" class=\"headerlink\" title=\"五  属性选择器（ie7+）\"></a>五  属性选择器（ie7+）</h3><p>E[attr]具有attr属性的元素<br>E[attr = val]<br>E[attr |= val]具有val或者以val-开头<br>E[attr ~= val] attr有多个空格分隔的值其中一个为val<br>E[attr*=val]attr的任意位置包含了val<br>E[attr^=val]属性值以val开头<br>E[attr$=val]属性以val结尾<br>选择器优先级：</p>\n<p> !important&gt;内联&gt;id&gt;class&gt;tag</p>\n<p>组合使用选择器的情况下，选择器的权重计算方式为：</p>\n<p>标签的权重为1，class的权重为10，id的权重为100</p>\n<p>如</p>\n<pre><code>div //权重为1\n.A  //权重为10\n#A //权重为100\ndiv.A //权重为11\n</code></pre><p>相同权重的情况下后面定义的样式会覆盖前面定义的样式，但与html中class的定义的先后无关。如</p>\n<pre><code>&lt;div&gt;\n    &lt;p class = &quot;B A&quot;&gt;这里面是文字&lt;/p&gt;\n&lt;/div&gt;\n.A{\ncolor:red;}\n.B{\ncolor:blue;\n}\n</code></pre><p>这时因为B的样式信息比A后定义，所以样式信息B会覆盖样式信息A，所以p中的文字会显示为蓝色。与AB在class中定义的顺序无关。</p>\n","excerpt":"<h3 id=\"一-基本选择器（基本兼容所有浏览器）\"><a href=\"#一-基本选择器（基本兼容所有浏览器）\" class=\"headerlink\" title=\"一 基本选择器（基本兼容所有浏览器）\"></a>一 基本选择器（基本兼容所有浏览器）</h3><p>通配选择器 *<br>元素选择器 E<br>类选择器 .class<br>ID选择器 #id<br>组群选择器<br>","more":"</p>\n<h3 id=\"二-层次选择器\"><a href=\"#二-层次选择器\" class=\"headerlink\" title=\"二 层次选择器\"></a>二 层次选择器</h3><p>E F 后代选择器 （基本兼容所有浏览器）<br>E&gt;F 子选择器 （ie7+）<br>E+F 相邻兄弟选择器（ie7+）<br>E~F 通用选择器匹配位于元素E之后的所有F元素（ie7+）</p>\n<h3 id=\"三-伪类选择器\"><a href=\"#三-伪类选择器\" class=\"headerlink\" title=\"三 伪类选择器\"></a>三 伪类选择器</h3><ol>\n<li>动态伪类选择器:link,:visited,:hover,:active, :focus</li>\n<li>目标伪类选择器:target</li>\n<li>语言伪类选择器E:lang(language)（ie8+）</li>\n<li>UI元素状态伪类选择器E:checked E:enabled E:disabled（ie9+）</li>\n<li><p>结构伪类选择器（ie9+）</p>\n<p>5.1 E:first-child<br>5.2 E:last-child<br>5.3 E:root在html文档中始终为html<br>5.4 E F:nth-child(n) n的起始值为1 F的父元素的第二个子元素<br>5.5 E F:nth-last-child(n)<br>5.6 E:nth-of-type(n)选择父元素内具有指定类型的第n个E元素<br>5.7 E:nth-of-type(n)选择父元素内具有指定类型的倒数第n个E元素<br>5.8 E:first-of-type<br>5.9 E:last-of-type<br>5.10 E:empty<br>5.11 E:only-child父元素只包含一个子元素，且该子元素匹配E元素<br>5.12 E:only-of-type父元素只包含一个同类型的子元素，且该子元素匹配E元素</p>\n</li>\n<li><p>否定伪类选择器:not()(ie9+)</p>\n</li>\n</ol>\n<h3 id=\"四-伪元素\"><a href=\"#四-伪元素\" class=\"headerlink\" title=\"四 伪元素\"></a>四 伪元素</h3><p>:first-line,:first-letter,:before,:after，为了与伪类进行区分，CSS3中对此进行了调整，由单冒号变成了双冒号，</p>\n<p>::first-line,::first-letter,::before,::after另外新增加了一个伪元素::selection，用于匹配突出显示的文本。</p>\n<p>::selection仅接收两个属性 background和color。 ie系列中只有ie9支持，FireFox需要加上其私有属性-moz</p>\n<p>如：</p>\n<pre><code>::selection{\nbackground-color:red;\ncolor:#FFFFFF;\n}\n::-moz-selection{\nbackground-color:red;\ncolor:#FFFFFF;\n}\n</code></pre><h3 id=\"五-属性选择器（ie7-）\"><a href=\"#五-属性选择器（ie7-）\" class=\"headerlink\" title=\"五  属性选择器（ie7+）\"></a>五  属性选择器（ie7+）</h3><p>E[attr]具有attr属性的元素<br>E[attr = val]<br>E[attr |= val]具有val或者以val-开头<br>E[attr ~= val] attr有多个空格分隔的值其中一个为val<br>E[attr*=val]attr的任意位置包含了val<br>E[attr^=val]属性值以val开头<br>E[attr$=val]属性以val结尾<br>选择器优先级：</p>\n<p> !important&gt;内联&gt;id&gt;class&gt;tag</p>\n<p>组合使用选择器的情况下，选择器的权重计算方式为：</p>\n<p>标签的权重为1，class的权重为10，id的权重为100</p>\n<p>如</p>\n<pre><code>div //权重为1\n.A  //权重为10\n#A //权重为100\ndiv.A //权重为11\n</code></pre><p>相同权重的情况下后面定义的样式会覆盖前面定义的样式，但与html中class的定义的先后无关。如</p>\n<pre><code>&lt;div&gt;\n    &lt;p class = &quot;B A&quot;&gt;这里面是文字&lt;/p&gt;\n&lt;/div&gt;\n.A{\ncolor:red;}\n.B{\ncolor:blue;\n}\n</code></pre><p>这时因为B的样式信息比A后定义，所以样式信息B会覆盖样式信息A，所以p中的文字会显示为蓝色。与AB在class中定义的顺序无关。</p>"},{"layout":"机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)","title":"Variance","date":"2016-07-05T15:42:15.000Z","_content":"作者：orange prince\n链接：http://www.zhihu.com/question/27068705/answer/35151681\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先 Error = Bias + Variance\nError反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。\n<!-- more -->\n\n举一个例子，一次打靶实验，目标是为了打到10环，但是实际上只打到了7环，那么这里面的Error就是3。具体分析打到7环的原因，可能有两方面：一是瞄准出了问题，比如实际上射击瞄准的是9环而不是10环；二是枪本身的稳定性有问题，虽然瞄准的是9环，但是只打到了7环。那么在上面一次射击实验中，Bias就是1,反应的是模型期望与真实目标的差距，而在这次试验中，由于Variance所带来的误差就是2，即虽然瞄准的是9环，但由于本身模型缺乏稳定性，造成了实际结果与模型期望之间的差距。\n\n在一个实际系统中，Bias与Variance往往是不能兼得的。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，我们总是希望试图用有限训练样本去估计无限的真实数据。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成过拟合，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。Bias与Variance两者之间的trade-off是机器学习的基本主题之一，机会可以在各种机器模型中发现它的影子。\n\n具体到K-fold Cross Validation的场景，其实是很好的理解的。首先看Variance的变化，还是举打靶的例子。假设我把抢瞄准在10环，虽然每一次射击都有偏差，但是这个偏差的方向是随机的，也就是有可能向上，也有可能向下。那么试验次数越多，应该上下的次数越接近，那么我们把所有射击的目标取一个平均值，也应该离中心更加接近。更加微观的分析，模型的预测值与期望产生较大偏差，在模型固定的情况下，原因还是出在数据上，比如说产生了某一些异常点。在最极端情况下，我们假设只有一个点是异常的，如果只训练一个模型，那么这个点会对整个模型带来影响，使得学习出的模型具有很大的variance。但是如果采用k-fold Cross Validation进行训练，只有1个模型会受到这个异常数据的影响，而其余k-1个模型都是正常的。在平均之后，这个异常数据的影响就大大减少了。相比之下，模型的bias是可以直接建模的，只需要保证模型在训练样本上训练误差最小就可以保证bias比较小，而要达到这个目的，就必须是用所有数据一起训练，才能达到模型的最优解。因此，k-fold Cross Validation的目标函数破坏了前面的情形，所以模型的Bias必然要会增大。","source":"_posts/Variance.md","raw":"layout: 机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)\ntitle: Variance\ndate: 2016-07-05 23:42:15\ntags:\n---\n作者：orange prince\n链接：http://www.zhihu.com/question/27068705/answer/35151681\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先 Error = Bias + Variance\nError反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。\n<!-- more -->\n\n举一个例子，一次打靶实验，目标是为了打到10环，但是实际上只打到了7环，那么这里面的Error就是3。具体分析打到7环的原因，可能有两方面：一是瞄准出了问题，比如实际上射击瞄准的是9环而不是10环；二是枪本身的稳定性有问题，虽然瞄准的是9环，但是只打到了7环。那么在上面一次射击实验中，Bias就是1,反应的是模型期望与真实目标的差距，而在这次试验中，由于Variance所带来的误差就是2，即虽然瞄准的是9环，但由于本身模型缺乏稳定性，造成了实际结果与模型期望之间的差距。\n\n在一个实际系统中，Bias与Variance往往是不能兼得的。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，我们总是希望试图用有限训练样本去估计无限的真实数据。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成过拟合，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。Bias与Variance两者之间的trade-off是机器学习的基本主题之一，机会可以在各种机器模型中发现它的影子。\n\n具体到K-fold Cross Validation的场景，其实是很好的理解的。首先看Variance的变化，还是举打靶的例子。假设我把抢瞄准在10环，虽然每一次射击都有偏差，但是这个偏差的方向是随机的，也就是有可能向上，也有可能向下。那么试验次数越多，应该上下的次数越接近，那么我们把所有射击的目标取一个平均值，也应该离中心更加接近。更加微观的分析，模型的预测值与期望产生较大偏差，在模型固定的情况下，原因还是出在数据上，比如说产生了某一些异常点。在最极端情况下，我们假设只有一个点是异常的，如果只训练一个模型，那么这个点会对整个模型带来影响，使得学习出的模型具有很大的variance。但是如果采用k-fold Cross Validation进行训练，只有1个模型会受到这个异常数据的影响，而其余k-1个模型都是正常的。在平均之后，这个异常数据的影响就大大减少了。相比之下，模型的bias是可以直接建模的，只需要保证模型在训练样本上训练误差最小就可以保证bias比较小，而要达到这个目的，就必须是用所有数据一起训练，才能达到模型的最优解。因此，k-fold Cross Validation的目标函数破坏了前面的情形，所以模型的Bias必然要会增大。","slug":"Variance","published":1,"updated":"2016-07-17T12:25:39.699Z","comments":1,"photos":[],"link":"","_id":"citn0kmhc000o1kvsp94it78l","content":"<p>作者：orange prince<br>链接：<a href=\"http://www.zhihu.com/question/27068705/answer/35151681\" target=\"_blank\" rel=\"external\">http://www.zhihu.com/question/27068705/answer/35151681</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>首先 Error = Bias + Variance<br>Error反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。<br><a id=\"more\"></a></p>\n<p>举一个例子，一次打靶实验，目标是为了打到10环，但是实际上只打到了7环，那么这里面的Error就是3。具体分析打到7环的原因，可能有两方面：一是瞄准出了问题，比如实际上射击瞄准的是9环而不是10环；二是枪本身的稳定性有问题，虽然瞄准的是9环，但是只打到了7环。那么在上面一次射击实验中，Bias就是1,反应的是模型期望与真实目标的差距，而在这次试验中，由于Variance所带来的误差就是2，即虽然瞄准的是9环，但由于本身模型缺乏稳定性，造成了实际结果与模型期望之间的差距。</p>\n<p>在一个实际系统中，Bias与Variance往往是不能兼得的。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，我们总是希望试图用有限训练样本去估计无限的真实数据。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成过拟合，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。Bias与Variance两者之间的trade-off是机器学习的基本主题之一，机会可以在各种机器模型中发现它的影子。</p>\n<p>具体到K-fold Cross Validation的场景，其实是很好的理解的。首先看Variance的变化，还是举打靶的例子。假设我把抢瞄准在10环，虽然每一次射击都有偏差，但是这个偏差的方向是随机的，也就是有可能向上，也有可能向下。那么试验次数越多，应该上下的次数越接近，那么我们把所有射击的目标取一个平均值，也应该离中心更加接近。更加微观的分析，模型的预测值与期望产生较大偏差，在模型固定的情况下，原因还是出在数据上，比如说产生了某一些异常点。在最极端情况下，我们假设只有一个点是异常的，如果只训练一个模型，那么这个点会对整个模型带来影响，使得学习出的模型具有很大的variance。但是如果采用k-fold Cross Validation进行训练，只有1个模型会受到这个异常数据的影响，而其余k-1个模型都是正常的。在平均之后，这个异常数据的影响就大大减少了。相比之下，模型的bias是可以直接建模的，只需要保证模型在训练样本上训练误差最小就可以保证bias比较小，而要达到这个目的，就必须是用所有数据一起训练，才能达到模型的最优解。因此，k-fold Cross Validation的目标函数破坏了前面的情形，所以模型的Bias必然要会增大。</p>\n","excerpt":"<p>作者：orange prince<br>链接：<a href=\"http://www.zhihu.com/question/27068705/answer/35151681\">http://www.zhihu.com/question/27068705/answer/35151681</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<p>首先 Error = Bias + Variance<br>Error反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。<br>","more":"</p>\n<p>举一个例子，一次打靶实验，目标是为了打到10环，但是实际上只打到了7环，那么这里面的Error就是3。具体分析打到7环的原因，可能有两方面：一是瞄准出了问题，比如实际上射击瞄准的是9环而不是10环；二是枪本身的稳定性有问题，虽然瞄准的是9环，但是只打到了7环。那么在上面一次射击实验中，Bias就是1,反应的是模型期望与真实目标的差距，而在这次试验中，由于Variance所带来的误差就是2，即虽然瞄准的是9环，但由于本身模型缺乏稳定性，造成了实际结果与模型期望之间的差距。</p>\n<p>在一个实际系统中，Bias与Variance往往是不能兼得的。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，我们总是希望试图用有限训练样本去估计无限的真实数据。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成过拟合，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。Bias与Variance两者之间的trade-off是机器学习的基本主题之一，机会可以在各种机器模型中发现它的影子。</p>\n<p>具体到K-fold Cross Validation的场景，其实是很好的理解的。首先看Variance的变化，还是举打靶的例子。假设我把抢瞄准在10环，虽然每一次射击都有偏差，但是这个偏差的方向是随机的，也就是有可能向上，也有可能向下。那么试验次数越多，应该上下的次数越接近，那么我们把所有射击的目标取一个平均值，也应该离中心更加接近。更加微观的分析，模型的预测值与期望产生较大偏差，在模型固定的情况下，原因还是出在数据上，比如说产生了某一些异常点。在最极端情况下，我们假设只有一个点是异常的，如果只训练一个模型，那么这个点会对整个模型带来影响，使得学习出的模型具有很大的variance。但是如果采用k-fold Cross Validation进行训练，只有1个模型会受到这个异常数据的影响，而其余k-1个模型都是正常的。在平均之后，这个异常数据的影响就大大减少了。相比之下，模型的bias是可以直接建模的，只需要保证模型在训练样本上训练误差最小就可以保证bias比较小，而要达到这个目的，就必须是用所有数据一起训练，才能达到模型的最优解。因此，k-fold Cross Validation的目标函数破坏了前面的情形，所以模型的Bias必然要会增大。</p>"},{"title":"ajax使用","date":"2016-07-20T04:32:50.000Z","_content":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n<!-- more -->\n\n\tfunction getMethod(){\n\t\tvar xhr;\n\t\tif(window.XMLHttpRequest){\n\t\t\txhr = new XMLHttpRequest();\n\t\t}\n\t\telse{\n\t\t\txhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t}\n\t\txhr.open(\"POST\",\"test.js\",true);\n\t\txhr.send();\n        xhr.onreadystatechange = function(){\n        \tif(xhr.readState==4&&xhr.status==200){\n        \t\talert(xhr.responseText);\n        \t}\n        }\n\t}\n\tfunction postMethod(){\n\t\tvar xhr;\n\t\tif(window.XMLHttpRequest){\n\t\t\txhr = new XMLHttpRequest();\n\t\t}\n\t\telse{\n\t\t\txhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t}\n\t\txmlhttp.open(\"POST\",\"ajax_test.asp\",true);\n\t\txmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n\t\txmlhttp.send(\"fname=Bill&lname=Gates\");\n        xhr.onreadystatechange = function(){\n        \tif(xhr.readState==4&&xhr.status==200){\n        \t\talert(xhr.responseText);\n        \t}\n        }\n\t}\n\nXMLHttpRequest 的状态。从 0 到 4 发生变化。\n0: 请求未初始化\n1: 服务器连接已建立\n2: 请求已接收\n3: 请求处理中\n4: 请求已完成，且响应已就绪\nHTTP status\n1xx 消息\n2xx 成功\n3xx 重定向\n4xx 请求错误\n5xx 服务器错误\n\nAjax的优点：\n1）页面无刷新，用户体验非常好。\n2）使用异步方式与服务器通信，具有更加迅速的响应能力。\n3）可以把一些服务器负担的工作转到客户端，利用客户端闲置的能力来处理，减轻服务器负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担。\n4）基于标准化并被广泛支持的技术，不需要下载插件或者小程序。\nAjax的缺点:\n1）Ajax不支持浏览器back按钮。\n2）安全问题， Ajax暴露了与服务器交互的细节。\n3）对搜索引擎的支持比较弱。\n4）破坏了程序的异常机制。\n5）不容易调试。\n","source":"_posts/ajax.md","raw":"---\ntitle: ajax使用\ndate: 2016-07-20 12:32:50\ntags: \n  - ajax\ncategories:\n  - 学习笔记\n  - 前端学习\n---\nAJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n<!-- more -->\n\n\tfunction getMethod(){\n\t\tvar xhr;\n\t\tif(window.XMLHttpRequest){\n\t\t\txhr = new XMLHttpRequest();\n\t\t}\n\t\telse{\n\t\t\txhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t}\n\t\txhr.open(\"POST\",\"test.js\",true);\n\t\txhr.send();\n        xhr.onreadystatechange = function(){\n        \tif(xhr.readState==4&&xhr.status==200){\n        \t\talert(xhr.responseText);\n        \t}\n        }\n\t}\n\tfunction postMethod(){\n\t\tvar xhr;\n\t\tif(window.XMLHttpRequest){\n\t\t\txhr = new XMLHttpRequest();\n\t\t}\n\t\telse{\n\t\t\txhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t}\n\t\txmlhttp.open(\"POST\",\"ajax_test.asp\",true);\n\t\txmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n\t\txmlhttp.send(\"fname=Bill&lname=Gates\");\n        xhr.onreadystatechange = function(){\n        \tif(xhr.readState==4&&xhr.status==200){\n        \t\talert(xhr.responseText);\n        \t}\n        }\n\t}\n\nXMLHttpRequest 的状态。从 0 到 4 发生变化。\n0: 请求未初始化\n1: 服务器连接已建立\n2: 请求已接收\n3: 请求处理中\n4: 请求已完成，且响应已就绪\nHTTP status\n1xx 消息\n2xx 成功\n3xx 重定向\n4xx 请求错误\n5xx 服务器错误\n\nAjax的优点：\n1）页面无刷新，用户体验非常好。\n2）使用异步方式与服务器通信，具有更加迅速的响应能力。\n3）可以把一些服务器负担的工作转到客户端，利用客户端闲置的能力来处理，减轻服务器负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担。\n4）基于标准化并被广泛支持的技术，不需要下载插件或者小程序。\nAjax的缺点:\n1）Ajax不支持浏览器back按钮。\n2）安全问题， Ajax暴露了与服务器交互的细节。\n3）对搜索引擎的支持比较弱。\n4）破坏了程序的异常机制。\n5）不容易调试。\n","slug":"ajax","published":1,"updated":"2016-07-31T10:13:12.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmhc000t1kvsspi695xq","content":"<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。<br><a id=\"more\"></a></p>\n<pre><code>function getMethod(){\n    var xhr;\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }\n    else{\n        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n    }\n    xhr.open(&quot;POST&quot;,&quot;test.js&quot;,true);\n    xhr.send();\n    xhr.onreadystatechange = function(){\n        if(xhr.readState==4&amp;&amp;xhr.status==200){\n            alert(xhr.responseText);\n        }\n    }\n}\nfunction postMethod(){\n    var xhr;\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }\n    else{\n        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n    }\n    xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);\n    xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);\n    xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);\n    xhr.onreadystatechange = function(){\n        if(xhr.readState==4&amp;&amp;xhr.status==200){\n            alert(xhr.responseText);\n        }\n    }\n}\n</code></pre><p>XMLHttpRequest 的状态。从 0 到 4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪<br>HTTP status<br>1xx 消息<br>2xx 成功<br>3xx 重定向<br>4xx 请求错误<br>5xx 服务器错误</p>\n<p>Ajax的优点：<br>1）页面无刷新，用户体验非常好。<br>2）使用异步方式与服务器通信，具有更加迅速的响应能力。<br>3）可以把一些服务器负担的工作转到客户端，利用客户端闲置的能力来处理，减轻服务器负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担。<br>4）基于标准化并被广泛支持的技术，不需要下载插件或者小程序。<br>Ajax的缺点:<br>1）Ajax不支持浏览器back按钮。<br>2）安全问题， Ajax暴露了与服务器交互的细节。<br>3）对搜索引擎的支持比较弱。<br>4）破坏了程序的异常机制。<br>5）不容易调试。</p>\n","excerpt":"<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。<br>","more":"</p>\n<pre><code>function getMethod(){\n    var xhr;\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }\n    else{\n        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n    }\n    xhr.open(&quot;POST&quot;,&quot;test.js&quot;,true);\n    xhr.send();\n    xhr.onreadystatechange = function(){\n        if(xhr.readState==4&amp;&amp;xhr.status==200){\n            alert(xhr.responseText);\n        }\n    }\n}\nfunction postMethod(){\n    var xhr;\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }\n    else{\n        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n    }\n    xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);\n    xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);\n    xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);\n    xhr.onreadystatechange = function(){\n        if(xhr.readState==4&amp;&amp;xhr.status==200){\n            alert(xhr.responseText);\n        }\n    }\n}\n</code></pre><p>XMLHttpRequest 的状态。从 0 到 4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪<br>HTTP status<br>1xx 消息<br>2xx 成功<br>3xx 重定向<br>4xx 请求错误<br>5xx 服务器错误</p>\n<p>Ajax的优点：<br>1）页面无刷新，用户体验非常好。<br>2）使用异步方式与服务器通信，具有更加迅速的响应能力。<br>3）可以把一些服务器负担的工作转到客户端，利用客户端闲置的能力来处理，减轻服务器负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担。<br>4）基于标准化并被广泛支持的技术，不需要下载插件或者小程序。<br>Ajax的缺点:<br>1）Ajax不支持浏览器back按钮。<br>2）安全问题， Ajax暴露了与服务器交互的细节。<br>3）对搜索引擎的支持比较弱。<br>4）破坏了程序的异常机制。<br>5）不容易调试。</p>"},{"title":"css3动画","date":"2016-07-20T08:40:44.000Z","_content":"\n# 什么是 CSS3 中的动画？\n\n动画是使元素从一种样式逐渐变化为另一种样式的效果。\n您可以改变任意多的样式任意多的次数。\n-W3School\n<!-- more -->\n请用百分比来规定变化发生的时间，或用关键词 \"from\" 和 \"to\"，等同于 0% 和 100%。\n0% 是动画的开始，100% 是动画的完成。\n为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。\n\n@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。\nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。\nChrome 和 Safari 需要前缀 -webkit-。\nInternet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。\n\n# 属性\n\n@keyframes\t规定动画。\nanimation\t所有动画属性的简写属性，除了 animation-play-state 属性。\t\nanimation-name\t规定 @keyframes 动画的名称。\t\nanimation-duration\t规定动画完成一个周期所花费的秒或毫秒。默认是 0。\t\nanimation-timing-function\t规定动画的速度曲线。默认是 \"ease\"。\tlinear ease ease-in ease-out ease-in-out\nanimation-delay\t规定动画何时开始。默认是 0。\t\nanimation-iteration-count\t规定动画被播放的次数。默认是 1。\t\nanimation-direction\t规定动画是否在下一周期逆向地播放。默认是 \"normal\"。\t取值 normal或alternate\nanimation-play-state\t规定动画是否正在运行或暂停。默认是 \"running\"。\t取值paused或running\nanimation-fill-mode\t规定对象动画时间之外的状态。\n\n# 例子\n\tdiv\n\t\t{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tposition: absolute;\n\t\t\tleft: 0px;\n\t\t\ttop: 0px;\n\t\t\tbackground:red;\n\t\t\tanimation:myfirst linear 5s;\n\t\t\t/* animation-iteration-count: infinite;\n\t\t\tanimation-direction: alternate;\n\t\t\tanimation-play-state: running; */\n\t\t\t-moz-animation:myfirst linear 5s; /* Firefox */\n\t\t\t/* -moz-animation-iteration-count: infinite;\n\t\t\t-moz-animation-direction: alternate;\n\t\t\t-moz-animation-play-state: running; */\n\t\t\t-webkit-animation:myfirst linear 5s; /* Safari and Chrome */\n\t\t\t/* -webkit-animation-iteration-count: infinite;\n\t\t\t-webkit-animation-direction: alternate;\n\t\t\t-webkit-animation-play-state: running; */\n\t\t\t-o-animation:myfirst linear 5s; /* Opera */\n\t\t\t/* -o-animation-iteration-count: infinite;\n\t\t\t-o-animation-direction: alternate;\n\t\t\t-o-animation-play-state: running; */\n\t\t}\n\n\t@keyframes myfirst\n\t{\n\t\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-moz-keyframes myfirst /* Firefox */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-webkit-keyframes myfirst /* Safari and Chrome */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-o-keyframes myfirst /* Opera */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}","source":"_posts/css3动画.md","raw":"---\ntitle: css3动画\ntags:\n  - CSS3\n  - CSS3动画\ncategories:\n  - 学习笔记\n  - 前端学习\ndate: 2016-07-20 16:40:44\n---\n\n# 什么是 CSS3 中的动画？\n\n动画是使元素从一种样式逐渐变化为另一种样式的效果。\n您可以改变任意多的样式任意多的次数。\n-W3School\n<!-- more -->\n请用百分比来规定变化发生的时间，或用关键词 \"from\" 和 \"to\"，等同于 0% 和 100%。\n0% 是动画的开始，100% 是动画的完成。\n为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。\n\n@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。\nInternet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。\nChrome 和 Safari 需要前缀 -webkit-。\nInternet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。\n\n# 属性\n\n@keyframes\t规定动画。\nanimation\t所有动画属性的简写属性，除了 animation-play-state 属性。\t\nanimation-name\t规定 @keyframes 动画的名称。\t\nanimation-duration\t规定动画完成一个周期所花费的秒或毫秒。默认是 0。\t\nanimation-timing-function\t规定动画的速度曲线。默认是 \"ease\"。\tlinear ease ease-in ease-out ease-in-out\nanimation-delay\t规定动画何时开始。默认是 0。\t\nanimation-iteration-count\t规定动画被播放的次数。默认是 1。\t\nanimation-direction\t规定动画是否在下一周期逆向地播放。默认是 \"normal\"。\t取值 normal或alternate\nanimation-play-state\t规定动画是否正在运行或暂停。默认是 \"running\"。\t取值paused或running\nanimation-fill-mode\t规定对象动画时间之外的状态。\n\n# 例子\n\tdiv\n\t\t{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tposition: absolute;\n\t\t\tleft: 0px;\n\t\t\ttop: 0px;\n\t\t\tbackground:red;\n\t\t\tanimation:myfirst linear 5s;\n\t\t\t/* animation-iteration-count: infinite;\n\t\t\tanimation-direction: alternate;\n\t\t\tanimation-play-state: running; */\n\t\t\t-moz-animation:myfirst linear 5s; /* Firefox */\n\t\t\t/* -moz-animation-iteration-count: infinite;\n\t\t\t-moz-animation-direction: alternate;\n\t\t\t-moz-animation-play-state: running; */\n\t\t\t-webkit-animation:myfirst linear 5s; /* Safari and Chrome */\n\t\t\t/* -webkit-animation-iteration-count: infinite;\n\t\t\t-webkit-animation-direction: alternate;\n\t\t\t-webkit-animation-play-state: running; */\n\t\t\t-o-animation:myfirst linear 5s; /* Opera */\n\t\t\t/* -o-animation-iteration-count: infinite;\n\t\t\t-o-animation-direction: alternate;\n\t\t\t-o-animation-play-state: running; */\n\t\t}\n\n\t@keyframes myfirst\n\t{\n\t\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-moz-keyframes myfirst /* Firefox */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-webkit-keyframes myfirst /* Safari and Chrome */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}\n\n\t@-o-keyframes myfirst /* Opera */\n\t{\n\t0% {\n\t\t\tbackground:red;\n\t\t\tleft: 0px;\n\t\t\ttransform: rotate(0deg);\n\t\t}\n\t\t30%{\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(360deg);\n\t\t\tleft: 300px;\n\t\t}\n\t\t60% {\n\t\t\tbackground:yellow;\n\t\t\ttransform: rotate(720deg);\n\t\t\tleft: 600px;\n\t\t}\n\t\t100% {\n\t\t\tbackground:red;\n\t\t\ttransform: rotate(1080deg);\n\t\t\tleft: 1000px;\n\t\t}\n\t}","slug":"css3动画","published":1,"updated":"2016-07-20T12:35:07.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmhc000w1kvsttc3acwd","content":"<h1 id=\"什么是-CSS3-中的动画？\"><a href=\"#什么是-CSS3-中的动画？\" class=\"headerlink\" title=\"什么是 CSS3 中的动画？\"></a>什么是 CSS3 中的动画？</h1><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>您可以改变任意多的样式任意多的次数。<br>-W3School<br><a id=\"more\"></a><br>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。<br>0% 是动画的开始，100% 是动画的完成。<br>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p>\n<p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。<br>Chrome 和 Safari 需要前缀 -webkit-。<br>Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>@keyframes    规定动画。<br>animation    所有动画属性的简写属性，除了 animation-play-state 属性。<br>animation-name    规定 @keyframes 动画的名称。<br>animation-duration    规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br>animation-timing-function    规定动画的速度曲线。默认是 “ease”。    linear ease ease-in ease-out ease-in-out<br>animation-delay    规定动画何时开始。默认是 0。<br>animation-iteration-count    规定动画被播放的次数。默认是 1。<br>animation-direction    规定动画是否在下一周期逆向地播放。默认是 “normal”。    取值 normal或alternate<br>animation-play-state    规定动画是否正在运行或暂停。默认是 “running”。    取值paused或running<br>animation-fill-mode    规定对象动画时间之外的状态。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><pre><code>div\n    {\n        width:100px;\n        height:100px;\n        position: absolute;\n        left: 0px;\n        top: 0px;\n        background:red;\n        animation:myfirst linear 5s;\n        /* animation-iteration-count: infinite;\n        animation-direction: alternate;\n        animation-play-state: running; */\n        -moz-animation:myfirst linear 5s; /* Firefox */\n        /* -moz-animation-iteration-count: infinite;\n        -moz-animation-direction: alternate;\n        -moz-animation-play-state: running; */\n        -webkit-animation:myfirst linear 5s; /* Safari and Chrome */\n        /* -webkit-animation-iteration-count: infinite;\n        -webkit-animation-direction: alternate;\n        -webkit-animation-play-state: running; */\n        -o-animation:myfirst linear 5s; /* Opera */\n        /* -o-animation-iteration-count: infinite;\n        -o-animation-direction: alternate;\n        -o-animation-play-state: running; */\n    }\n\n@keyframes myfirst\n{\n    0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-webkit-keyframes myfirst /* Safari and Chrome */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-o-keyframes myfirst /* Opera */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n</code></pre>","excerpt":"<h1 id=\"什么是-CSS3-中的动画？\"><a href=\"#什么是-CSS3-中的动画？\" class=\"headerlink\" title=\"什么是 CSS3 中的动画？\"></a>什么是 CSS3 中的动画？</h1><p>动画是使元素从一种样式逐渐变化为另一种样式的效果。<br>您可以改变任意多的样式任意多的次数。<br>-W3School<br>","more":"<br>请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。<br>0% 是动画的开始，100% 是动画的完成。<br>为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。</p>\n<p>@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。<br>Internet Explorer 10、Firefox 以及 Opera 支持 @keyframes 规则和 animation 属性。<br>Chrome 和 Safari 需要前缀 -webkit-。<br>Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。</p>\n<h1 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h1><p>@keyframes    规定动画。<br>animation    所有动画属性的简写属性，除了 animation-play-state 属性。<br>animation-name    规定 @keyframes 动画的名称。<br>animation-duration    规定动画完成一个周期所花费的秒或毫秒。默认是 0。<br>animation-timing-function    规定动画的速度曲线。默认是 “ease”。    linear ease ease-in ease-out ease-in-out<br>animation-delay    规定动画何时开始。默认是 0。<br>animation-iteration-count    规定动画被播放的次数。默认是 1。<br>animation-direction    规定动画是否在下一周期逆向地播放。默认是 “normal”。    取值 normal或alternate<br>animation-play-state    规定动画是否正在运行或暂停。默认是 “running”。    取值paused或running<br>animation-fill-mode    规定对象动画时间之外的状态。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><pre><code>div\n    {\n        width:100px;\n        height:100px;\n        position: absolute;\n        left: 0px;\n        top: 0px;\n        background:red;\n        animation:myfirst linear 5s;\n        /* animation-iteration-count: infinite;\n        animation-direction: alternate;\n        animation-play-state: running; */\n        -moz-animation:myfirst linear 5s; /* Firefox */\n        /* -moz-animation-iteration-count: infinite;\n        -moz-animation-direction: alternate;\n        -moz-animation-play-state: running; */\n        -webkit-animation:myfirst linear 5s; /* Safari and Chrome */\n        /* -webkit-animation-iteration-count: infinite;\n        -webkit-animation-direction: alternate;\n        -webkit-animation-play-state: running; */\n        -o-animation:myfirst linear 5s; /* Opera */\n        /* -o-animation-iteration-count: infinite;\n        -o-animation-direction: alternate;\n        -o-animation-play-state: running; */\n    }\n\n@keyframes myfirst\n{\n    0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-webkit-keyframes myfirst /* Safari and Chrome */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n\n@-o-keyframes myfirst /* Opera */\n{\n0% {\n        background:red;\n        left: 0px;\n        transform: rotate(0deg);\n    }\n    30%{\n        background:yellow;\n        transform: rotate(360deg);\n        left: 300px;\n    }\n    60% {\n        background:yellow;\n        transform: rotate(720deg);\n        left: 600px;\n    }\n    100% {\n        background:red;\n        transform: rotate(1080deg);\n        left: 1000px;\n    }\n}\n</code></pre>"},{"title":"cookie","date":"2016-07-19T05:55:58.000Z","_content":"\n# cookie定义\ncookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。\n# 设置和读取cookie\n通过设置document.cookie设置cookie如\n\n\tdocument.cookie='name=sly';\n\tdocument.cookie=\"age=23\"\n\n<!--  more -->\ncookie设置之后就是一个字符串，通过document.cookie读取，如\n\n\tdocument.cookie  => \"name=sly; age=23\"\n\n还可以设置cookie的有效期，如\n\n\tdocument.cookie='name=sly;expires=date';\n\n下面是完整的设置cookie和获取cookie的方法，来自w3c\n\n\tfunction setCookie(c_name,value,expiredays)\n\t{\n\t\tvar exdate=new Date()\n\t\texdate.setDate(exdate.getDate()+expiredays)\n\t\tdocument.cookie=c_name+ \"=\" +escape(value)+\n\t\t((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString())\n\t}\n\n\tfunction getCookie(c_name)\n\t{\n\tif (document.cookie.length>0)\n\t  {\n\t  c_start=document.cookie.indexOf(c_name + \"=\")\n\t  if (c_start!=-1)\n\t    { \n\t\t    c_start=c_start + c_name.length+1 \n\t\t    c_end=document.cookie.indexOf(\";\",c_start)\n\t\t    if (c_end==-1) c_end=document.cookie.length\n\t\t    return unescape(document.cookie.substring(c_start,c_end))\n\t    } \n\t  }\n\t\treturn \"\"\n\t}\n\n# cookie和webstorage的区别\n1. cookie有大小限制，每个cookie所存放的数据不能超过4kb，如果cookie字符串的长度超过4k，则该属性返回空字符串。webstorage大概可以存储5Mb，不同浏览器不同\n2. cookie是http协议的一部分，cookie数据始终在同源的http请求中携带，浪费带宽，webstorage不会把数据传到服务器端，仅保存在本地。\n3. cookie可以设置过期时间，到了过期时间浏览器就会将cookie删除，如果不设置过期时间则浏览器窗口关闭则删除。\n   localstorage会一直保存在本地，除非手动删除\n   sessionstorage仅在当前浏览器窗口关闭前有效\n4. sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；\n   localStorage 在所有同源窗口中都是共享的；\n   cookie也是在所有同源窗口中都是共享的。\n","source":"_posts/cookie.md","raw":"---\ntitle: cookie\ntags:\n  - cookie\ncategories:\n  - 学习笔记\n  - 前端学习\ndate: 2016-07-19 13:55:58\n---\n\n# cookie定义\ncookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。\n# 设置和读取cookie\n通过设置document.cookie设置cookie如\n\n\tdocument.cookie='name=sly';\n\tdocument.cookie=\"age=23\"\n\n<!--  more -->\ncookie设置之后就是一个字符串，通过document.cookie读取，如\n\n\tdocument.cookie  => \"name=sly; age=23\"\n\n还可以设置cookie的有效期，如\n\n\tdocument.cookie='name=sly;expires=date';\n\n下面是完整的设置cookie和获取cookie的方法，来自w3c\n\n\tfunction setCookie(c_name,value,expiredays)\n\t{\n\t\tvar exdate=new Date()\n\t\texdate.setDate(exdate.getDate()+expiredays)\n\t\tdocument.cookie=c_name+ \"=\" +escape(value)+\n\t\t((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString())\n\t}\n\n\tfunction getCookie(c_name)\n\t{\n\tif (document.cookie.length>0)\n\t  {\n\t  c_start=document.cookie.indexOf(c_name + \"=\")\n\t  if (c_start!=-1)\n\t    { \n\t\t    c_start=c_start + c_name.length+1 \n\t\t    c_end=document.cookie.indexOf(\";\",c_start)\n\t\t    if (c_end==-1) c_end=document.cookie.length\n\t\t    return unescape(document.cookie.substring(c_start,c_end))\n\t    } \n\t  }\n\t\treturn \"\"\n\t}\n\n# cookie和webstorage的区别\n1. cookie有大小限制，每个cookie所存放的数据不能超过4kb，如果cookie字符串的长度超过4k，则该属性返回空字符串。webstorage大概可以存储5Mb，不同浏览器不同\n2. cookie是http协议的一部分，cookie数据始终在同源的http请求中携带，浪费带宽，webstorage不会把数据传到服务器端，仅保存在本地。\n3. cookie可以设置过期时间，到了过期时间浏览器就会将cookie删除，如果不设置过期时间则浏览器窗口关闭则删除。\n   localstorage会一直保存在本地，除非手动删除\n   sessionstorage仅在当前浏览器窗口关闭前有效\n4. sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；\n   localStorage 在所有同源窗口中都是共享的；\n   cookie也是在所有同源窗口中都是共享的。\n","slug":"cookie","published":1,"updated":"2016-07-19T13:20:52.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmhs00101kvsr6u8n6ft","content":"<h1 id=\"cookie定义\"><a href=\"#cookie定义\" class=\"headerlink\" title=\"cookie定义\"></a>cookie定义</h1><p>cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。</p>\n<h1 id=\"设置和读取cookie\"><a href=\"#设置和读取cookie\" class=\"headerlink\" title=\"设置和读取cookie\"></a>设置和读取cookie</h1><p>通过设置document.cookie设置cookie如</p>\n<pre><code>document.cookie=&apos;name=sly&apos;;\ndocument.cookie=&quot;age=23&quot;\n</code></pre><a id=\"more\"></a>\n<p>cookie设置之后就是一个字符串，通过document.cookie读取，如</p>\n<pre><code>document.cookie  =&gt; &quot;name=sly; age=23&quot;\n</code></pre><p>还可以设置cookie的有效期，如</p>\n<pre><code>document.cookie=&apos;name=sly;expires=date&apos;;\n</code></pre><p>下面是完整的设置cookie和获取cookie的方法，来自w3c</p>\n<pre><code>function setCookie(c_name,value,expiredays)\n{\n    var exdate=new Date()\n    exdate.setDate(exdate.getDate()+expiredays)\n    document.cookie=c_name+ &quot;=&quot; +escape(value)+\n    ((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString())\n}\n\nfunction getCookie(c_name)\n{\nif (document.cookie.length&gt;0)\n  {\n  c_start=document.cookie.indexOf(c_name + &quot;=&quot;)\n  if (c_start!=-1)\n    { \n        c_start=c_start + c_name.length+1 \n        c_end=document.cookie.indexOf(&quot;;&quot;,c_start)\n        if (c_end==-1) c_end=document.cookie.length\n        return unescape(document.cookie.substring(c_start,c_end))\n    } \n  }\n    return &quot;&quot;\n}\n</code></pre><h1 id=\"cookie和webstorage的区别\"><a href=\"#cookie和webstorage的区别\" class=\"headerlink\" title=\"cookie和webstorage的区别\"></a>cookie和webstorage的区别</h1><ol>\n<li>cookie有大小限制，每个cookie所存放的数据不能超过4kb，如果cookie字符串的长度超过4k，则该属性返回空字符串。webstorage大概可以存储5Mb，不同浏览器不同</li>\n<li>cookie是http协议的一部分，cookie数据始终在同源的http请求中携带，浪费带宽，webstorage不会把数据传到服务器端，仅保存在本地。</li>\n<li>cookie可以设置过期时间，到了过期时间浏览器就会将cookie删除，如果不设置过期时间则浏览器窗口关闭则删除。<br>localstorage会一直保存在本地，除非手动删除<br>sessionstorage仅在当前浏览器窗口关闭前有效</li>\n<li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；<br>localStorage 在所有同源窗口中都是共享的；<br>cookie也是在所有同源窗口中都是共享的。</li>\n</ol>\n","excerpt":"<h1 id=\"cookie定义\"><a href=\"#cookie定义\" class=\"headerlink\" title=\"cookie定义\"></a>cookie定义</h1><p>cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。</p>\n<h1 id=\"设置和读取cookie\"><a href=\"#设置和读取cookie\" class=\"headerlink\" title=\"设置和读取cookie\"></a>设置和读取cookie</h1><p>通过设置document.cookie设置cookie如</p>\n<pre><code>document.cookie=&apos;name=sly&apos;;\ndocument.cookie=&quot;age=23&quot;\n</code></pre>","more":"<p>cookie设置之后就是一个字符串，通过document.cookie读取，如</p>\n<pre><code>document.cookie  =&gt; &quot;name=sly; age=23&quot;\n</code></pre><p>还可以设置cookie的有效期，如</p>\n<pre><code>document.cookie=&apos;name=sly;expires=date&apos;;\n</code></pre><p>下面是完整的设置cookie和获取cookie的方法，来自w3c</p>\n<pre><code>function setCookie(c_name,value,expiredays)\n{\n    var exdate=new Date()\n    exdate.setDate(exdate.getDate()+expiredays)\n    document.cookie=c_name+ &quot;=&quot; +escape(value)+\n    ((expiredays==null) ? &quot;&quot; : &quot;;expires=&quot;+exdate.toGMTString())\n}\n\nfunction getCookie(c_name)\n{\nif (document.cookie.length&gt;0)\n  {\n  c_start=document.cookie.indexOf(c_name + &quot;=&quot;)\n  if (c_start!=-1)\n    { \n        c_start=c_start + c_name.length+1 \n        c_end=document.cookie.indexOf(&quot;;&quot;,c_start)\n        if (c_end==-1) c_end=document.cookie.length\n        return unescape(document.cookie.substring(c_start,c_end))\n    } \n  }\n    return &quot;&quot;\n}\n</code></pre><h1 id=\"cookie和webstorage的区别\"><a href=\"#cookie和webstorage的区别\" class=\"headerlink\" title=\"cookie和webstorage的区别\"></a>cookie和webstorage的区别</h1><ol>\n<li>cookie有大小限制，每个cookie所存放的数据不能超过4kb，如果cookie字符串的长度超过4k，则该属性返回空字符串。webstorage大概可以存储5Mb，不同浏览器不同</li>\n<li>cookie是http协议的一部分，cookie数据始终在同源的http请求中携带，浪费带宽，webstorage不会把数据传到服务器端，仅保存在本地。</li>\n<li>cookie可以设置过期时间，到了过期时间浏览器就会将cookie删除，如果不设置过期时间则浏览器窗口关闭则删除。<br>localstorage会一直保存在本地，除非手动删除<br>sessionstorage仅在当前浏览器窗口关闭前有效</li>\n<li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；<br>localStorage 在所有同源窗口中都是共享的；<br>cookie也是在所有同源窗口中都是共享的。</li>\n</ol>"},{"title":"css3变形","date":"2016-05-25T12:17:55.000Z","_content":"css3变形是一些效果的集合，比如平移，旋转，缩放和倾斜，每个效果都被称为变形函数，它们可以控制元素发生旋转、缩放、平移等变化。\n# CSS变形属性及函数\n1. CSS3变形中具有X/Y可用的函数：translateX()、translateY()、scaleX()、scaleY()、skewX()和skewY()\n2. css3 2D变形函数包括：translate(),scale(),rotate()和skew()。translate()函数接受CSS的标准度量单位；scale()函数接受一个0~1之间的十进制值；rotate()和skew()函数都接受一个径向的度量单位deg。除了rotate()函数外，每个函数都接受X轴Y轴的参数。2D变形中还有一个矩阵matrix()函数，包含6个参数\n3. CSS3 3D变形包括：rotateX(), rotateY(),rotate3d(),translateZ(),translate3d(),scaleZ()和scale3d()。3D变形中也还有一个矩阵matrix3d()函数，包含16个参数。\n","source":"_posts/css3变形.md","raw":"---\ntitle: css3变形\ndate: 2016-05-25 20:17:55\ntags:\n  - css3变形\n  - css3\ncategories:\n  - 学习笔记\n  - 前端学习\n---\ncss3变形是一些效果的集合，比如平移，旋转，缩放和倾斜，每个效果都被称为变形函数，它们可以控制元素发生旋转、缩放、平移等变化。\n# CSS变形属性及函数\n1. CSS3变形中具有X/Y可用的函数：translateX()、translateY()、scaleX()、scaleY()、skewX()和skewY()\n2. css3 2D变形函数包括：translate(),scale(),rotate()和skew()。translate()函数接受CSS的标准度量单位；scale()函数接受一个0~1之间的十进制值；rotate()和skew()函数都接受一个径向的度量单位deg。除了rotate()函数外，每个函数都接受X轴Y轴的参数。2D变形中还有一个矩阵matrix()函数，包含6个参数\n3. CSS3 3D变形包括：rotateX(), rotateY(),rotate3d(),translateZ(),translate3d(),scaleZ()和scale3d()。3D变形中也还有一个矩阵matrix3d()函数，包含16个参数。\n","slug":"css3变形","published":1,"updated":"2016-05-25T15:44:55.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmi800121kvsjf7gj0ml","content":"<p>css3变形是一些效果的集合，比如平移，旋转，缩放和倾斜，每个效果都被称为变形函数，它们可以控制元素发生旋转、缩放、平移等变化。</p>\n<h1 id=\"CSS变形属性及函数\"><a href=\"#CSS变形属性及函数\" class=\"headerlink\" title=\"CSS变形属性及函数\"></a>CSS变形属性及函数</h1><ol>\n<li>CSS3变形中具有X/Y可用的函数：translateX()、translateY()、scaleX()、scaleY()、skewX()和skewY()</li>\n<li>css3 2D变形函数包括：translate(),scale(),rotate()和skew()。translate()函数接受CSS的标准度量单位；scale()函数接受一个0~1之间的十进制值；rotate()和skew()函数都接受一个径向的度量单位deg。除了rotate()函数外，每个函数都接受X轴Y轴的参数。2D变形中还有一个矩阵matrix()函数，包含6个参数</li>\n<li>CSS3 3D变形包括：rotateX(), rotateY(),rotate3d(),translateZ(),translate3d(),scaleZ()和scale3d()。3D变形中也还有一个矩阵matrix3d()函数，包含16个参数。</li>\n</ol>\n","excerpt":"","more":"<p>css3变形是一些效果的集合，比如平移，旋转，缩放和倾斜，每个效果都被称为变形函数，它们可以控制元素发生旋转、缩放、平移等变化。</p>\n<h1 id=\"CSS变形属性及函数\"><a href=\"#CSS变形属性及函数\" class=\"headerlink\" title=\"CSS变形属性及函数\"></a>CSS变形属性及函数</h1><ol>\n<li>CSS3变形中具有X/Y可用的函数：translateX()、translateY()、scaleX()、scaleY()、skewX()和skewY()</li>\n<li>css3 2D变形函数包括：translate(),scale(),rotate()和skew()。translate()函数接受CSS的标准度量单位；scale()函数接受一个0~1之间的十进制值；rotate()和skew()函数都接受一个径向的度量单位deg。除了rotate()函数外，每个函数都接受X轴Y轴的参数。2D变形中还有一个矩阵matrix()函数，包含6个参数</li>\n<li>CSS3 3D变形包括：rotateX(), rotateY(),rotate3d(),translateZ(),translate3d(),scaleZ()和scale3d()。3D变形中也还有一个矩阵matrix3d()函数，包含16个参数。</li>\n</ol>\n"},{"title":"git回滚","date":"2016-07-28T08:05:57.000Z","_content":"Git版本恢复命令,首先通过git log指令找出要恢复的版本，之后可以执行下面的两种操作\n<!-- more -->\n\n1. git reset\n\n\tgit reset 版本号 \n\tgit checkout .\n\t这两个指令可以将本地的代码恢复成历史版本，但是无法提交到远程，除非使用git push -f但是这样会直接将远程代码库恢复成历史版本，中间做的任何修改都会消失，不推荐使用\n\n2. git revert\n\tgit revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留\n\n\n\n","source":"_posts/git回滚.md","raw":"---\ntitle: git回滚\ndate: 2016-07-28 16:05:57\ntags: \n  - git\ncategories:\n  - 学习笔记\n  - git学习\n---\nGit版本恢复命令,首先通过git log指令找出要恢复的版本，之后可以执行下面的两种操作\n<!-- more -->\n\n1. git reset\n\n\tgit reset 版本号 \n\tgit checkout .\n\t这两个指令可以将本地的代码恢复成历史版本，但是无法提交到远程，除非使用git push -f但是这样会直接将远程代码库恢复成历史版本，中间做的任何修改都会消失，不推荐使用\n\n2. git revert\n\tgit revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留\n\n\n\n","slug":"git回滚","published":1,"updated":"2016-09-03T14:28:35.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmi800151kvsm0irmf59","content":"<p>Git版本恢复命令,首先通过git log指令找出要恢复的版本，之后可以执行下面的两种操作<br><a id=\"more\"></a></p>\n<ol>\n<li><p>git reset</p>\n<p> git reset 版本号<br> git checkout .<br> 这两个指令可以将本地的代码恢复成历史版本，但是无法提交到远程，除非使用git push -f但是这样会直接将远程代码库恢复成历史版本，中间做的任何修改都会消失，不推荐使用</p>\n</li>\n<li><p>git revert<br> git revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留</p>\n</li>\n</ol>\n","excerpt":"<p>Git版本恢复命令,首先通过git log指令找出要恢复的版本，之后可以执行下面的两种操作<br>","more":"</p>\n<ol>\n<li><p>git reset</p>\n<p> git reset 版本号<br> git checkout .<br> 这两个指令可以将本地的代码恢复成历史版本，但是无法提交到远程，除非使用git push -f但是这样会直接将远程代码库恢复成历史版本，中间做的任何修改都会消失，不推荐使用</p>\n</li>\n<li><p>git revert<br> git revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留</p>\n</li>\n</ol>"},{"title":"FlexBox学习笔记","date":"2016-05-13T07:41:17.000Z","_content":"Flex的出现是为了解决布局问题，使用flex布局很灵活，容器子元素的排列方式，对齐方式，显示顺序等都可以很方便的指定。目前处于非正式标准，但是新的浏览器基本上都支持。\n<!-- more -->\nFlexBox是一个布局模块，不是一个简单的布局属性，它包含父元素和子元素的属性。flex布局主要依赖于flex direction。\n## 主要术语\n\n1. 主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。\n2. 主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。\n3. 主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。\n4. 侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。\n5. 侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。\n6. 侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是\"width\"或\"height\"属性，由哪一个对着侧轴方向决定。\n\n## 主要属性\n\n1. display(flex container)\n\n\t\tdisplay: other values | flex | inline-flex;\n2. flex-direction(flex container)\n\n\t\tflex-direction: row | row-reverse | column | column-reverse\n3. order（flex items）\n默认情况下，伸缩项目是按照文档流出现先后顺序排列。然而，“order”属性可以控制伸缩项目在他们的伸缩容器出现的顺序。\n\n\t\torder: <integer> \n4. flex-wrap（flex container）\n这个主要用来定义伸缩容器里是单行还是多行显示，侧轴的方向决定了新行堆放的方向。\n\n\t\tflex-wrap: nowrap | wrap | wrap-reverse\n5. flex-flow（flex container）\n这个是“flex-direction”和“flex-wrap”属性的缩写版本。同时定义了伸缩容器的主轴和侧轴。其默认值为“row nowrap”。\n\n\t\tflex-flow: <‘flex-direction’> || <‘flex-wrap’>\n6. justify-content（flex container）\n这个是用来定义伸缩项目沿着主轴线的对齐方式。当一行上的所有伸缩项目都不能伸缩或可伸缩但是已经达到其最大长度时，这一属性才会对多余的空间进行分配。当项目溢出某一行时，这一属性也会在项目的对齐上施加一些控制。\n\n\t\tjustify-content: flex-start | flex-end | center | space-between | space-around;\n7. align-content（flex container）\n这个属性主要用来调准伸缩行在伸缩容器里的对齐方式。类似于伸缩项目在主轴上使用“justify-content”一样。（侧轴方向的对齐方式）*容器内必须有多行的项目，该属性才能渲染出效果*。\n\n\t\talign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n8. align-items（flex container）\n\n\t\talign-items: flex-start | flex-end | center | baseline | stretch\n9. align-self（flex items）\n用来在单独的伸缩项目上覆写默认的对齐方式。\n\n\t\talign-self: auto | flex-start | flex-end | center | baseline | stretch;\n10. flex-grow（flex items）\n根据需要用来定义伸缩项目的扩展能力。它接受一个不带单位的值做为一个*比例*。主要用来决定伸缩容器剩余空间按比例应扩展多少空间。\n\n\t\tflex-grow: <number>; /* default 0 */\n如果所有伸缩项目的“flex-grow”设置了“1”，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了“flex-grow”值为“2”，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。\n11. flex-shrink(flex items)\n根据需要用来定义伸缩项目收缩的能力。负值无效。\n\n\t\tflex-shrink: <number>; /* default 1 */\n12. flex-basis（flex items）\n这个用来设置伸缩基准值，剩余的空间按比率进行伸缩。\n\n\t\tflex-basis: <length> | auto; /* default auto */\n如果设置为“0”，不考虑剩余空白空间。如果设置为自动，则按照flex-grow值分配剩余空白空间。\n13. flex（flex items）\n这是“flex-grow”、“flex-shrink”和“flex-basis”三个属性的缩写。其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数。默认值为“0 1 auto”。\n\n\t\tflex: none | [ <'flex-grow'> <'flex-shrink'>|| <'flex-basis'> ]\n\n## 实例讲解\n\n这几个都是对齐方式，为了方便演示，\n1. 先将几个box设置为长宽各不相同，在没有设置布局方式的时候，盒子应该从上往下依次排列。\n\n\t\t.box-5{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n\t\t.box-6{\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t}\n\t\t.box-7{\n\t\t\twidth: 300px;\n\t\t\theight: 300px;\n\t\t}\n\t\t.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t}\n\t\t.container_1{\n\t\t\twidth: 2000px;\n\t\t\theight: 800px;\n\t\t\tborder: 1px solid #00F;\n\t\t}\n2. 将父元素的布局方式设为display:flex之后，子元素的四个盒子显示到同一排，如图。因为如果没有设置其他的属性，flexbox布局方式中默认flex-direction为row，即从左向右的方式排列。justify-content默认为flex-start，即向一行的起始位置靠齐。因为flexdirection为从左向右，则box应该向左靠齐。\n![flex](/img/flex/2.jpg)\n3. 改变父元素的justify-content，如改为center，我们看一下布局会变为什么样子。可以看到盒子整体在父元素中居中。\n![justify-content](/img/flex/3.jpg)\n4. 接下来设置下order。\n\n\t\tdiv.box-5{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\torder: 1;\n\t\t}\n\t\tdiv.box-6{\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\torder: 5;\n\t\t}\n\t\tdiv.box-7{\n\t\t\twidth: 300px;\n\t\t\theight: 300px;\n\t\t\torder: 3;\n\t\t}\n\t\tdiv.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\torder: -1;\n\t\t}\n结果如图。\n![order](/img/flex/4.jpg)\n可见，order按大小排序，负数也可以。\n5. 使用align-items,设置为align-items: flex-end，box的显示方式如图。可见align-items设置的是各行元素间的对齐方式。\n![align-items](/img/flex/5.jpg)\n6. 接下来我们对单独的一个box设置align-self属性，如\n\n\t\tdiv.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\torder: -1;\n\t\t\talign-self: flex-start;\n\t\t}\n结果如图，很明显align-self属性设置的是单独的一个box的对齐方式。\n![align-self](/img/flex/6.jpg)\n7. 设置其中一个box的flex-grow为1，则这个box将忽略本身的width属性，占满父元素剩下的全部空间，可以用于自适应布局中，如图。\n![flex-grow](/img/flex/7.jpg)\n将所有的box的flex-grow都设为1，则将剩余空间的宽度分为4分，然后分别加到各个盒子上。\n8. flex-basis，当为数值时与width类似，会覆盖元素本身的width。设为其他数值，就相当于元素的宽度在这个值得基础上加，如剩余空间为100，四个box的flex-grow都设为1，假如原来四个盒子的flex-basis均为30px,则现在各个盒子的宽度均为55px。\n9. flex-shrink\n该属性来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。\nflex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小。\n\n\t\tdiv.container_2{\n\t\t\twidth: 1000px;\n\t\t\theight: 800px;\n\t\t\tborder: 1px solid #00F;\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-content: flex-end;\n\t\t\talign-items: flex-end;\n\t\t}\n\t\tdiv.box-9{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 100px;\n\t\t}\n\t\tdiv.box-10{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 200px;\n\t\t}\n\t\tdiv.box-11{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 300px;\n\t\t}\n\t\tdiv.box-12{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 400px;\n\t\t}\n因为默认为1，则四个box收缩相同的宽度，不会溢出，且收缩之后box的宽度还相同。如图。\n![flex-basis](/img/flex/8.jpg)\n下面改一下各个box的flex-shrink值\n\t\tdiv.box-9{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 100px;\n\t\t\tflex-shrink: 1;\n\t\t}\n\t\tdiv.box-10{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 200px;\n\t\t\tflex-shrink: 2;\n\t\t}\n\t\tdiv.box-11{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 300px;\n\t\t\tflex-shrink: 3;\n\t\t}\n\t\tdiv.box-12{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 400px;\n\t\t\tflex-shrink: 4;\n\t\t}\n则盒子将按照1/(1+2+3+4),2/(1+2+3+4),3/(1+2+3+4),4/(1+2+3+4)的比例缩小。如图。\n![flex-basis](/img/flex/9.jpg)\n演示链接\nhttp://shly.github.io/shly/IFE/task_10/index.html\n需要注意的是：\n1. 父元素display:flex之后成为伸缩容器，子元素（除了position:absolute或fixed）无论是display:block或者display:inline，都成为了伸缩项目。\n2. 可以固定一个伸缩项目的宽度，另一个伸缩项目自适应。\n3. 伸缩项目之间的空白自适应。\n4. 可以很方便进行水平和垂直方向的，居左，居中，居右，两边对齐等效果。\n5. android浏览器4.4之前对于flex布局支持不好。\n6. 伸缩项目之间，没有inline-block元素之间的空隙。\n7. 伸缩项目自动box-sizing:border-box。","source":"_posts/flex.md","raw":"---\ntitle: FlexBox学习笔记\ndate: 2016-05-13 15:41:17\ntags: \n  - css3\n  - FlexBox\ncategories:\n  - 学习笔记\n  - 前端学习\n---\nFlex的出现是为了解决布局问题，使用flex布局很灵活，容器子元素的排列方式，对齐方式，显示顺序等都可以很方便的指定。目前处于非正式标准，但是新的浏览器基本上都支持。\n<!-- more -->\nFlexBox是一个布局模块，不是一个简单的布局属性，它包含父元素和子元素的属性。flex布局主要依赖于flex direction。\n## 主要术语\n\n1. 主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。\n2. 主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。\n3. 主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。\n4. 侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。\n5. 侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。\n6. 侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是\"width\"或\"height\"属性，由哪一个对着侧轴方向决定。\n\n## 主要属性\n\n1. display(flex container)\n\n\t\tdisplay: other values | flex | inline-flex;\n2. flex-direction(flex container)\n\n\t\tflex-direction: row | row-reverse | column | column-reverse\n3. order（flex items）\n默认情况下，伸缩项目是按照文档流出现先后顺序排列。然而，“order”属性可以控制伸缩项目在他们的伸缩容器出现的顺序。\n\n\t\torder: <integer> \n4. flex-wrap（flex container）\n这个主要用来定义伸缩容器里是单行还是多行显示，侧轴的方向决定了新行堆放的方向。\n\n\t\tflex-wrap: nowrap | wrap | wrap-reverse\n5. flex-flow（flex container）\n这个是“flex-direction”和“flex-wrap”属性的缩写版本。同时定义了伸缩容器的主轴和侧轴。其默认值为“row nowrap”。\n\n\t\tflex-flow: <‘flex-direction’> || <‘flex-wrap’>\n6. justify-content（flex container）\n这个是用来定义伸缩项目沿着主轴线的对齐方式。当一行上的所有伸缩项目都不能伸缩或可伸缩但是已经达到其最大长度时，这一属性才会对多余的空间进行分配。当项目溢出某一行时，这一属性也会在项目的对齐上施加一些控制。\n\n\t\tjustify-content: flex-start | flex-end | center | space-between | space-around;\n7. align-content（flex container）\n这个属性主要用来调准伸缩行在伸缩容器里的对齐方式。类似于伸缩项目在主轴上使用“justify-content”一样。（侧轴方向的对齐方式）*容器内必须有多行的项目，该属性才能渲染出效果*。\n\n\t\talign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n8. align-items（flex container）\n\n\t\talign-items: flex-start | flex-end | center | baseline | stretch\n9. align-self（flex items）\n用来在单独的伸缩项目上覆写默认的对齐方式。\n\n\t\talign-self: auto | flex-start | flex-end | center | baseline | stretch;\n10. flex-grow（flex items）\n根据需要用来定义伸缩项目的扩展能力。它接受一个不带单位的值做为一个*比例*。主要用来决定伸缩容器剩余空间按比例应扩展多少空间。\n\n\t\tflex-grow: <number>; /* default 0 */\n如果所有伸缩项目的“flex-grow”设置了“1”，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了“flex-grow”值为“2”，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。\n11. flex-shrink(flex items)\n根据需要用来定义伸缩项目收缩的能力。负值无效。\n\n\t\tflex-shrink: <number>; /* default 1 */\n12. flex-basis（flex items）\n这个用来设置伸缩基准值，剩余的空间按比率进行伸缩。\n\n\t\tflex-basis: <length> | auto; /* default auto */\n如果设置为“0”，不考虑剩余空白空间。如果设置为自动，则按照flex-grow值分配剩余空白空间。\n13. flex（flex items）\n这是“flex-grow”、“flex-shrink”和“flex-basis”三个属性的缩写。其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数。默认值为“0 1 auto”。\n\n\t\tflex: none | [ <'flex-grow'> <'flex-shrink'>|| <'flex-basis'> ]\n\n## 实例讲解\n\n这几个都是对齐方式，为了方便演示，\n1. 先将几个box设置为长宽各不相同，在没有设置布局方式的时候，盒子应该从上往下依次排列。\n\n\t\t.box-5{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n\t\t.box-6{\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t}\n\t\t.box-7{\n\t\t\twidth: 300px;\n\t\t\theight: 300px;\n\t\t}\n\t\t.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t}\n\t\t.container_1{\n\t\t\twidth: 2000px;\n\t\t\theight: 800px;\n\t\t\tborder: 1px solid #00F;\n\t\t}\n2. 将父元素的布局方式设为display:flex之后，子元素的四个盒子显示到同一排，如图。因为如果没有设置其他的属性，flexbox布局方式中默认flex-direction为row，即从左向右的方式排列。justify-content默认为flex-start，即向一行的起始位置靠齐。因为flexdirection为从左向右，则box应该向左靠齐。\n![flex](/img/flex/2.jpg)\n3. 改变父元素的justify-content，如改为center，我们看一下布局会变为什么样子。可以看到盒子整体在父元素中居中。\n![justify-content](/img/flex/3.jpg)\n4. 接下来设置下order。\n\n\t\tdiv.box-5{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\torder: 1;\n\t\t}\n\t\tdiv.box-6{\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\torder: 5;\n\t\t}\n\t\tdiv.box-7{\n\t\t\twidth: 300px;\n\t\t\theight: 300px;\n\t\t\torder: 3;\n\t\t}\n\t\tdiv.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\torder: -1;\n\t\t}\n结果如图。\n![order](/img/flex/4.jpg)\n可见，order按大小排序，负数也可以。\n5. 使用align-items,设置为align-items: flex-end，box的显示方式如图。可见align-items设置的是各行元素间的对齐方式。\n![align-items](/img/flex/5.jpg)\n6. 接下来我们对单独的一个box设置align-self属性，如\n\n\t\tdiv.box-8{\n\t\t\twidth: 400px;\n\t\t\theight: 400px;\n\t\t\torder: -1;\n\t\t\talign-self: flex-start;\n\t\t}\n结果如图，很明显align-self属性设置的是单独的一个box的对齐方式。\n![align-self](/img/flex/6.jpg)\n7. 设置其中一个box的flex-grow为1，则这个box将忽略本身的width属性，占满父元素剩下的全部空间，可以用于自适应布局中，如图。\n![flex-grow](/img/flex/7.jpg)\n将所有的box的flex-grow都设为1，则将剩余空间的宽度分为4分，然后分别加到各个盒子上。\n8. flex-basis，当为数值时与width类似，会覆盖元素本身的width。设为其他数值，就相当于元素的宽度在这个值得基础上加，如剩余空间为100，四个box的flex-grow都设为1，假如原来四个盒子的flex-basis均为30px,则现在各个盒子的宽度均为55px。\n9. flex-shrink\n该属性来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。\nflex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小。\n\n\t\tdiv.container_2{\n\t\t\twidth: 1000px;\n\t\t\theight: 800px;\n\t\t\tborder: 1px solid #00F;\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-content: flex-end;\n\t\t\talign-items: flex-end;\n\t\t}\n\t\tdiv.box-9{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 100px;\n\t\t}\n\t\tdiv.box-10{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 200px;\n\t\t}\n\t\tdiv.box-11{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 300px;\n\t\t}\n\t\tdiv.box-12{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 400px;\n\t\t}\n因为默认为1，则四个box收缩相同的宽度，不会溢出，且收缩之后box的宽度还相同。如图。\n![flex-basis](/img/flex/8.jpg)\n下面改一下各个box的flex-shrink值\n\t\tdiv.box-9{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 100px;\n\t\t\tflex-shrink: 1;\n\t\t}\n\t\tdiv.box-10{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 200px;\n\t\t\tflex-shrink: 2;\n\t\t}\n\t\tdiv.box-11{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 300px;\n\t\t\tflex-shrink: 3;\n\t\t}\n\t\tdiv.box-12{\n\t\t\tflex-basis: 300px;\n\t\t\theight: 400px;\n\t\t\tflex-shrink: 4;\n\t\t}\n则盒子将按照1/(1+2+3+4),2/(1+2+3+4),3/(1+2+3+4),4/(1+2+3+4)的比例缩小。如图。\n![flex-basis](/img/flex/9.jpg)\n演示链接\nhttp://shly.github.io/shly/IFE/task_10/index.html\n需要注意的是：\n1. 父元素display:flex之后成为伸缩容器，子元素（除了position:absolute或fixed）无论是display:block或者display:inline，都成为了伸缩项目。\n2. 可以固定一个伸缩项目的宽度，另一个伸缩项目自适应。\n3. 伸缩项目之间的空白自适应。\n4. 可以很方便进行水平和垂直方向的，居左，居中，居右，两边对齐等效果。\n5. android浏览器4.4之前对于flex布局支持不好。\n6. 伸缩项目之间，没有inline-block元素之间的空隙。\n7. 伸缩项目自动box-sizing:border-box。","slug":"flex","published":1,"updated":"2016-07-27T13:41:18.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmin00191kvs50s60icw","content":"<p>Flex的出现是为了解决布局问题，使用flex布局很灵活，容器子元素的排列方式，对齐方式，显示顺序等都可以很方便的指定。目前处于非正式标准，但是新的浏览器基本上都支持。<br><a id=\"more\"></a><br>FlexBox是一个布局模块，不是一个简单的布局属性，它包含父元素和子元素的属性。flex布局主要依赖于flex direction。</p>\n<h2 id=\"主要术语\"><a href=\"#主要术语\" class=\"headerlink\" title=\"主要术语\"></a>主要术语</h2><ol>\n<li>主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。</li>\n<li>主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li>\n<li>主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li>\n<li>侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li>\n<li>侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li>\n<li>侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是”width”或”height”属性，由哪一个对着侧轴方向决定。</li>\n</ol>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><ol>\n<li><p>display(flex container)</p>\n<pre><code>display: other values | flex | inline-flex;\n</code></pre></li>\n<li><p>flex-direction(flex container)</p>\n<pre><code>flex-direction: row | row-reverse | column | column-reverse\n</code></pre></li>\n<li><p>order（flex items）<br>默认情况下，伸缩项目是按照文档流出现先后顺序排列。然而，“order”属性可以控制伸缩项目在他们的伸缩容器出现的顺序。</p>\n<pre><code>order: &lt;integer&gt; \n</code></pre></li>\n<li><p>flex-wrap（flex container）<br>这个主要用来定义伸缩容器里是单行还是多行显示，侧轴的方向决定了新行堆放的方向。</p>\n<pre><code>flex-wrap: nowrap | wrap | wrap-reverse\n</code></pre></li>\n<li><p>flex-flow（flex container）<br>这个是“flex-direction”和“flex-wrap”属性的缩写版本。同时定义了伸缩容器的主轴和侧轴。其默认值为“row nowrap”。</p>\n<pre><code>flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;\n</code></pre></li>\n<li><p>justify-content（flex container）<br>这个是用来定义伸缩项目沿着主轴线的对齐方式。当一行上的所有伸缩项目都不能伸缩或可伸缩但是已经达到其最大长度时，这一属性才会对多余的空间进行分配。当项目溢出某一行时，这一属性也会在项目的对齐上施加一些控制。</p>\n<pre><code>justify-content: flex-start | flex-end | center | space-between | space-around;\n</code></pre></li>\n<li><p>align-content（flex container）<br>这个属性主要用来调准伸缩行在伸缩容器里的对齐方式。类似于伸缩项目在主轴上使用“justify-content”一样。（侧轴方向的对齐方式）<em>容器内必须有多行的项目，该属性才能渲染出效果</em>。</p>\n<pre><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n</code></pre></li>\n<li><p>align-items（flex container）</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch\n</code></pre></li>\n<li><p>align-self（flex items）<br>用来在单独的伸缩项目上覆写默认的对齐方式。</p>\n<pre><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;\n</code></pre></li>\n<li><p>flex-grow（flex items）<br>根据需要用来定义伸缩项目的扩展能力。它接受一个不带单位的值做为一个<em>比例</em>。主要用来决定伸缩容器剩余空间按比例应扩展多少空间。</p>\n<pre><code>flex-grow: &lt;number&gt;; /* default 0 */\n</code></pre><p>如果所有伸缩项目的“flex-grow”设置了“1”，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了“flex-grow”值为“2”，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。</p>\n</li>\n<li><p>flex-shrink(flex items)<br>根据需要用来定义伸缩项目收缩的能力。负值无效。</p>\n<pre><code>flex-shrink: &lt;number&gt;; /* default 1 */\n</code></pre></li>\n<li><p>flex-basis（flex items）<br>这个用来设置伸缩基准值，剩余的空间按比率进行伸缩。</p>\n<pre><code>flex-basis: &lt;length&gt; | auto; /* default auto */\n</code></pre><p>如果设置为“0”，不考虑剩余空白空间。如果设置为自动，则按照flex-grow值分配剩余空白空间。</p>\n</li>\n<li><p>flex（flex items）<br>这是“flex-grow”、“flex-shrink”和“flex-basis”三个属性的缩写。其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数。默认值为“0 1 auto”。</p>\n<pre><code>flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;|| &lt;&apos;flex-basis&apos;&gt; ]\n</code></pre></li>\n</ol>\n<h2 id=\"实例讲解\"><a href=\"#实例讲解\" class=\"headerlink\" title=\"实例讲解\"></a>实例讲解</h2><p>这几个都是对齐方式，为了方便演示，</p>\n<ol>\n<li><p>先将几个box设置为长宽各不相同，在没有设置布局方式的时候，盒子应该从上往下依次排列。</p>\n<pre><code>.box-5{\n    width: 100px;\n    height: 100px;\n}\n.box-6{\n    width: 200px;\n    height: 200px;\n}\n.box-7{\n    width: 300px;\n    height: 300px;\n}\n.box-8{\n    width: 400px;\n    height: 400px;\n}\n.container_1{\n    width: 2000px;\n    height: 800px;\n    border: 1px solid #00F;\n}\n</code></pre></li>\n<li>将父元素的布局方式设为display:flex之后，子元素的四个盒子显示到同一排，如图。因为如果没有设置其他的属性，flexbox布局方式中默认flex-direction为row，即从左向右的方式排列。justify-content默认为flex-start，即向一行的起始位置靠齐。因为flexdirection为从左向右，则box应该向左靠齐。<br><img src=\"/img/flex/2.jpg\" alt=\"flex\"></li>\n<li>改变父元素的justify-content，如改为center，我们看一下布局会变为什么样子。可以看到盒子整体在父元素中居中。<br><img src=\"/img/flex/3.jpg\" alt=\"justify-content\"></li>\n<li><p>接下来设置下order。</p>\n<pre><code>div.box-5{\n    width: 100px;\n    height: 100px;\n    order: 1;\n}\ndiv.box-6{\n    width: 200px;\n    height: 200px;\n    order: 5;\n}\ndiv.box-7{\n    width: 300px;\n    height: 300px;\n    order: 3;\n}\ndiv.box-8{\n    width: 400px;\n    height: 400px;\n    order: -1;\n}\n</code></pre><p>结果如图。<br><img src=\"/img/flex/4.jpg\" alt=\"order\"><br>可见，order按大小排序，负数也可以。</p>\n</li>\n<li>使用align-items,设置为align-items: flex-end，box的显示方式如图。可见align-items设置的是各行元素间的对齐方式。<br><img src=\"/img/flex/5.jpg\" alt=\"align-items\"></li>\n<li><p>接下来我们对单独的一个box设置align-self属性，如</p>\n<pre><code>div.box-8{\n    width: 400px;\n    height: 400px;\n    order: -1;\n    align-self: flex-start;\n}\n</code></pre><p>结果如图，很明显align-self属性设置的是单独的一个box的对齐方式。<br><img src=\"/img/flex/6.jpg\" alt=\"align-self\"></p>\n</li>\n<li>设置其中一个box的flex-grow为1，则这个box将忽略本身的width属性，占满父元素剩下的全部空间，可以用于自适应布局中，如图。<br><img src=\"/img/flex/7.jpg\" alt=\"flex-grow\"><br>将所有的box的flex-grow都设为1，则将剩余空间的宽度分为4分，然后分别加到各个盒子上。</li>\n<li>flex-basis，当为数值时与width类似，会覆盖元素本身的width。设为其他数值，就相当于元素的宽度在这个值得基础上加，如剩余空间为100，四个box的flex-grow都设为1，假如原来四个盒子的flex-basis均为30px,则现在各个盒子的宽度均为55px。</li>\n<li><p>flex-shrink<br>该属性来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。<br>flex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小。</p>\n<pre><code>div.container_2{\n    width: 1000px;\n    height: 800px;\n    border: 1px solid #00F;\n    display: flex;\n    justify-content: center;\n    align-content: flex-end;\n    align-items: flex-end;\n}\ndiv.box-9{\n    flex-basis: 300px;\n    height: 100px;\n}\ndiv.box-10{\n    flex-basis: 300px;\n    height: 200px;\n}\ndiv.box-11{\n    flex-basis: 300px;\n    height: 300px;\n}\ndiv.box-12{\n    flex-basis: 300px;\n    height: 400px;\n}\n</code></pre><p>因为默认为1，则四个box收缩相同的宽度，不会溢出，且收缩之后box的宽度还相同。如图。<br><img src=\"/img/flex/8.jpg\" alt=\"flex-basis\"><br>下面改一下各个box的flex-shrink值</p>\n<pre><code>div.box-9{\n    flex-basis: 300px;\n    height: 100px;\n    flex-shrink: 1;\n}\ndiv.box-10{\n    flex-basis: 300px;\n    height: 200px;\n    flex-shrink: 2;\n}\ndiv.box-11{\n    flex-basis: 300px;\n    height: 300px;\n    flex-shrink: 3;\n}\ndiv.box-12{\n    flex-basis: 300px;\n    height: 400px;\n    flex-shrink: 4;\n}\n</code></pre><p>则盒子将按照1/(1+2+3+4),2/(1+2+3+4),3/(1+2+3+4),4/(1+2+3+4)的比例缩小。如图。<br><img src=\"/img/flex/9.jpg\" alt=\"flex-basis\"><br>演示链接<br><a href=\"http://shly.github.io/shly/IFE/task_10/index.html\" target=\"_blank\" rel=\"external\">http://shly.github.io/shly/IFE/task_10/index.html</a><br>需要注意的是：</p>\n</li>\n<li>父元素display:flex之后成为伸缩容器，子元素（除了position:absolute或fixed）无论是display:block或者display:inline，都成为了伸缩项目。</li>\n<li>可以固定一个伸缩项目的宽度，另一个伸缩项目自适应。</li>\n<li>伸缩项目之间的空白自适应。</li>\n<li>可以很方便进行水平和垂直方向的，居左，居中，居右，两边对齐等效果。</li>\n<li>android浏览器4.4之前对于flex布局支持不好。</li>\n<li>伸缩项目之间，没有inline-block元素之间的空隙。</li>\n<li>伸缩项目自动box-sizing:border-box。</li>\n</ol>\n","excerpt":"<p>Flex的出现是为了解决布局问题，使用flex布局很灵活，容器子元素的排列方式，对齐方式，显示顺序等都可以很方便的指定。目前处于非正式标准，但是新的浏览器基本上都支持。<br>","more":"<br>FlexBox是一个布局模块，不是一个简单的布局属性，它包含父元素和子元素的属性。flex布局主要依赖于flex direction。</p>\n<h2 id=\"主要术语\"><a href=\"#主要术语\" class=\"headerlink\" title=\"主要术语\"></a>主要术语</h2><ol>\n<li>主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。</li>\n<li>主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li>\n<li>主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li>\n<li>侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li>\n<li>侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li>\n<li>侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是”width”或”height”属性，由哪一个对着侧轴方向决定。</li>\n</ol>\n<h2 id=\"主要属性\"><a href=\"#主要属性\" class=\"headerlink\" title=\"主要属性\"></a>主要属性</h2><ol>\n<li><p>display(flex container)</p>\n<pre><code>display: other values | flex | inline-flex;\n</code></pre></li>\n<li><p>flex-direction(flex container)</p>\n<pre><code>flex-direction: row | row-reverse | column | column-reverse\n</code></pre></li>\n<li><p>order（flex items）<br>默认情况下，伸缩项目是按照文档流出现先后顺序排列。然而，“order”属性可以控制伸缩项目在他们的伸缩容器出现的顺序。</p>\n<pre><code>order: &lt;integer&gt; \n</code></pre></li>\n<li><p>flex-wrap（flex container）<br>这个主要用来定义伸缩容器里是单行还是多行显示，侧轴的方向决定了新行堆放的方向。</p>\n<pre><code>flex-wrap: nowrap | wrap | wrap-reverse\n</code></pre></li>\n<li><p>flex-flow（flex container）<br>这个是“flex-direction”和“flex-wrap”属性的缩写版本。同时定义了伸缩容器的主轴和侧轴。其默认值为“row nowrap”。</p>\n<pre><code>flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;\n</code></pre></li>\n<li><p>justify-content（flex container）<br>这个是用来定义伸缩项目沿着主轴线的对齐方式。当一行上的所有伸缩项目都不能伸缩或可伸缩但是已经达到其最大长度时，这一属性才会对多余的空间进行分配。当项目溢出某一行时，这一属性也会在项目的对齐上施加一些控制。</p>\n<pre><code>justify-content: flex-start | flex-end | center | space-between | space-around;\n</code></pre></li>\n<li><p>align-content（flex container）<br>这个属性主要用来调准伸缩行在伸缩容器里的对齐方式。类似于伸缩项目在主轴上使用“justify-content”一样。（侧轴方向的对齐方式）<em>容器内必须有多行的项目，该属性才能渲染出效果</em>。</p>\n<pre><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n</code></pre></li>\n<li><p>align-items（flex container）</p>\n<pre><code>align-items: flex-start | flex-end | center | baseline | stretch\n</code></pre></li>\n<li><p>align-self（flex items）<br>用来在单独的伸缩项目上覆写默认的对齐方式。</p>\n<pre><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;\n</code></pre></li>\n<li><p>flex-grow（flex items）<br>根据需要用来定义伸缩项目的扩展能力。它接受一个不带单位的值做为一个<em>比例</em>。主要用来决定伸缩容器剩余空间按比例应扩展多少空间。</p>\n<pre><code>flex-grow: &lt;number&gt;; /* default 0 */\n</code></pre><p>如果所有伸缩项目的“flex-grow”设置了“1”，那么每个伸缩项目将设置为一个大小相等的剩余空间。如果你给其中一个伸缩项目设置了“flex-grow”值为“2”，那么这个伸缩项目所占的剩余空间是其他伸缩项目所占剩余空间的两倍。</p>\n</li>\n<li><p>flex-shrink(flex items)<br>根据需要用来定义伸缩项目收缩的能力。负值无效。</p>\n<pre><code>flex-shrink: &lt;number&gt;; /* default 1 */\n</code></pre></li>\n<li><p>flex-basis（flex items）<br>这个用来设置伸缩基准值，剩余的空间按比率进行伸缩。</p>\n<pre><code>flex-basis: &lt;length&gt; | auto; /* default auto */\n</code></pre><p>如果设置为“0”，不考虑剩余空白空间。如果设置为自动，则按照flex-grow值分配剩余空白空间。</p>\n</li>\n<li><p>flex（flex items）<br>这是“flex-grow”、“flex-shrink”和“flex-basis”三个属性的缩写。其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数。默认值为“0 1 auto”。</p>\n<pre><code>flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;|| &lt;&apos;flex-basis&apos;&gt; ]\n</code></pre></li>\n</ol>\n<h2 id=\"实例讲解\"><a href=\"#实例讲解\" class=\"headerlink\" title=\"实例讲解\"></a>实例讲解</h2><p>这几个都是对齐方式，为了方便演示，</p>\n<ol>\n<li><p>先将几个box设置为长宽各不相同，在没有设置布局方式的时候，盒子应该从上往下依次排列。</p>\n<pre><code>.box-5{\n    width: 100px;\n    height: 100px;\n}\n.box-6{\n    width: 200px;\n    height: 200px;\n}\n.box-7{\n    width: 300px;\n    height: 300px;\n}\n.box-8{\n    width: 400px;\n    height: 400px;\n}\n.container_1{\n    width: 2000px;\n    height: 800px;\n    border: 1px solid #00F;\n}\n</code></pre></li>\n<li>将父元素的布局方式设为display:flex之后，子元素的四个盒子显示到同一排，如图。因为如果没有设置其他的属性，flexbox布局方式中默认flex-direction为row，即从左向右的方式排列。justify-content默认为flex-start，即向一行的起始位置靠齐。因为flexdirection为从左向右，则box应该向左靠齐。<br><img src=\"/img/flex/2.jpg\" alt=\"flex\"></li>\n<li>改变父元素的justify-content，如改为center，我们看一下布局会变为什么样子。可以看到盒子整体在父元素中居中。<br><img src=\"/img/flex/3.jpg\" alt=\"justify-content\"></li>\n<li><p>接下来设置下order。</p>\n<pre><code>div.box-5{\n    width: 100px;\n    height: 100px;\n    order: 1;\n}\ndiv.box-6{\n    width: 200px;\n    height: 200px;\n    order: 5;\n}\ndiv.box-7{\n    width: 300px;\n    height: 300px;\n    order: 3;\n}\ndiv.box-8{\n    width: 400px;\n    height: 400px;\n    order: -1;\n}\n</code></pre><p>结果如图。<br><img src=\"/img/flex/4.jpg\" alt=\"order\"><br>可见，order按大小排序，负数也可以。</p>\n</li>\n<li>使用align-items,设置为align-items: flex-end，box的显示方式如图。可见align-items设置的是各行元素间的对齐方式。<br><img src=\"/img/flex/5.jpg\" alt=\"align-items\"></li>\n<li><p>接下来我们对单独的一个box设置align-self属性，如</p>\n<pre><code>div.box-8{\n    width: 400px;\n    height: 400px;\n    order: -1;\n    align-self: flex-start;\n}\n</code></pre><p>结果如图，很明显align-self属性设置的是单独的一个box的对齐方式。<br><img src=\"/img/flex/6.jpg\" alt=\"align-self\"></p>\n</li>\n<li>设置其中一个box的flex-grow为1，则这个box将忽略本身的width属性，占满父元素剩下的全部空间，可以用于自适应布局中，如图。<br><img src=\"/img/flex/7.jpg\" alt=\"flex-grow\"><br>将所有的box的flex-grow都设为1，则将剩余空间的宽度分为4分，然后分别加到各个盒子上。</li>\n<li>flex-basis，当为数值时与width类似，会覆盖元素本身的width。设为其他数值，就相当于元素的宽度在这个值得基础上加，如剩余空间为100，四个box的flex-grow都设为1，假如原来四个盒子的flex-basis均为30px,则现在各个盒子的宽度均为55px。</li>\n<li><p>flex-shrink<br>该属性来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。<br>flex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小。</p>\n<pre><code>div.container_2{\n    width: 1000px;\n    height: 800px;\n    border: 1px solid #00F;\n    display: flex;\n    justify-content: center;\n    align-content: flex-end;\n    align-items: flex-end;\n}\ndiv.box-9{\n    flex-basis: 300px;\n    height: 100px;\n}\ndiv.box-10{\n    flex-basis: 300px;\n    height: 200px;\n}\ndiv.box-11{\n    flex-basis: 300px;\n    height: 300px;\n}\ndiv.box-12{\n    flex-basis: 300px;\n    height: 400px;\n}\n</code></pre><p>因为默认为1，则四个box收缩相同的宽度，不会溢出，且收缩之后box的宽度还相同。如图。<br><img src=\"/img/flex/8.jpg\" alt=\"flex-basis\"><br>下面改一下各个box的flex-shrink值</p>\n<pre><code>div.box-9{\n    flex-basis: 300px;\n    height: 100px;\n    flex-shrink: 1;\n}\ndiv.box-10{\n    flex-basis: 300px;\n    height: 200px;\n    flex-shrink: 2;\n}\ndiv.box-11{\n    flex-basis: 300px;\n    height: 300px;\n    flex-shrink: 3;\n}\ndiv.box-12{\n    flex-basis: 300px;\n    height: 400px;\n    flex-shrink: 4;\n}\n</code></pre><p>则盒子将按照1/(1+2+3+4),2/(1+2+3+4),3/(1+2+3+4),4/(1+2+3+4)的比例缩小。如图。<br><img src=\"/img/flex/9.jpg\" alt=\"flex-basis\"><br>演示链接<br><a href=\"http://shly.github.io/shly/IFE/task_10/index.html\">http://shly.github.io/shly/IFE/task_10/index.html</a><br>需要注意的是：</p>\n</li>\n<li>父元素display:flex之后成为伸缩容器，子元素（除了position:absolute或fixed）无论是display:block或者display:inline，都成为了伸缩项目。</li>\n<li>可以固定一个伸缩项目的宽度，另一个伸缩项目自适应。</li>\n<li>伸缩项目之间的空白自适应。</li>\n<li>可以很方便进行水平和垂直方向的，居左，居中，居右，两边对齐等效果。</li>\n<li>android浏览器4.4之前对于flex布局支持不好。</li>\n<li>伸缩项目之间，没有inline-block元素之间的空隙。</li>\n<li>伸缩项目自动box-sizing:border-box。</li>\n</ol>"},{"title":"二叉树遍历java版（递归与非递归）","date":"2016-06-14T02:50:34.000Z","_content":"今天复习了一下二叉树的遍历，包括递归与非递归形式，记录一下\n首先定义一个简单的二叉树结构，包括节点的值与左子节点和右子节点\n<!-- more -->\n\n\tpublic class TreeNode {\n\t\tint value;\n\t\tTreeNode left,right;\n\t\tpublic TreeNode(int value, TreeNode left, TreeNode right) {\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n下面是递归方式实现的，首先是先序遍历\n\n\tpublic void preOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t\tpreOrder(root.left);\n\t\t\t\tpreOrder(root.right);\n\t\t\t}\n\t\t}\n\n中序遍历\n\n\tpublic void inOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tinOrder(root.left);\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t\tinOrder(root.right);\n\t\t\t}\n\t\t}\n\n后序遍历\n\n\tpublic void postOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tpostOrder(root.left);\n\t\t\t\tpostOrder(root.right);\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t}\n\t\t}\n\n递归的形式比较简单，就是调整三行代码的顺序，下面来看非递归的实现。首先是先序遍历\n\n\tpublic void preOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\tif (root != null) {\n\t\t\t\tstack.add(root);\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tTreeNode p = stack.pop();\n\t\t\t\t\tSystem.out.print(p.value);\n\t\t\t\t\tif (p.right != null) {\n\t\t\t\t\t\tstack.add(p.right);\n\t\t\t\t\t}\n\t\t\t\t\tif (p.left != null) {\n\t\t\t\t\t\tstack.add(p.left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n先序遍历是先遍历根节点，首先将根节点压入栈底，然后弹出，弹出时要记得输出。看当前根节点是否有右子节点，有则压入右子节点，为什么要先压入右子节点呢，原因是栈是先进后出，我们要先弹出左子节点，故要先压入右子节点。然后在看有没有左子节点，有则压入，现在栈里面有两个个节点，依次是左子节点和右子节点，这个时候弹出左子节点，将左子节点视为根节点，继续重复上面过程，左子节点都弹出之后在弹出右子节点，将右子节点视为根节点，继续重复以上步骤。\n\n下面看中序遍历的非递归形式\n\n\tpublic void inOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\twhile (root != null || !stack.isEmpty()) {\n\t\t\t\tif (root != null) {\n\t\t\t\t\tstack.push(root);\n\t\t\t\t\troot = root.left;\n\t\t\t\t}else {\n\t\t\t\t\troot = stack.pop();\n\t\t\t\t\tSystem.out.print(root.value);\n\t\t\t\t\troot = root.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n最后是后序遍历的非递归形式\n\n\tpublic void postOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t    Stack<TreeNode> output = new Stack<TreeNode>();\n\t\t    TreeNode node = root;\n\t\t    while (node != null || !stack.empty()) {\n\t\t      if (node != null) {\n\t\t        output.push(node);\n\t\t        stack.push(node);\t\t\t\t\n\t\t        node = node.right;\n\t\t      } else {\n\t\t        node = stack.pop();\t\t\t\t\n\t\t        node = node.left;\n\t\t      }\n\t\t    }\n\t\t    while (output.size() > 0) {\n\t\t    \tSystem.out.print(output.pop().value);\n\t\t    }\n\t\t}\n\n","source":"_posts/bt.md","raw":"---\ntitle: 二叉树遍历java版（递归与非递归）\ndate: 2016-06-14 10:50:34\ntags: \n  - 数据结构\n  - 二叉树遍历\ncategories:\n  - 学习笔记\n  - 数据结构\n---\n今天复习了一下二叉树的遍历，包括递归与非递归形式，记录一下\n首先定义一个简单的二叉树结构，包括节点的值与左子节点和右子节点\n<!-- more -->\n\n\tpublic class TreeNode {\n\t\tint value;\n\t\tTreeNode left,right;\n\t\tpublic TreeNode(int value, TreeNode left, TreeNode right) {\n\t\t\tthis.value = value;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n下面是递归方式实现的，首先是先序遍历\n\n\tpublic void preOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t\tpreOrder(root.left);\n\t\t\t\tpreOrder(root.right);\n\t\t\t}\n\t\t}\n\n中序遍历\n\n\tpublic void inOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tinOrder(root.left);\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t\tinOrder(root.right);\n\t\t\t}\n\t\t}\n\n后序遍历\n\n\tpublic void postOrder(TreeNode root) {\n\t\t\tif (root != null) {\n\t\t\t\tpostOrder(root.left);\n\t\t\t\tpostOrder(root.right);\n\t\t\t\tSystem.out.print(root.value);\n\t\t\t}\n\t\t}\n\n递归的形式比较简单，就是调整三行代码的顺序，下面来看非递归的实现。首先是先序遍历\n\n\tpublic void preOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\tif (root != null) {\n\t\t\t\tstack.add(root);\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tTreeNode p = stack.pop();\n\t\t\t\t\tSystem.out.print(p.value);\n\t\t\t\t\tif (p.right != null) {\n\t\t\t\t\t\tstack.add(p.right);\n\t\t\t\t\t}\n\t\t\t\t\tif (p.left != null) {\n\t\t\t\t\t\tstack.add(p.left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n先序遍历是先遍历根节点，首先将根节点压入栈底，然后弹出，弹出时要记得输出。看当前根节点是否有右子节点，有则压入右子节点，为什么要先压入右子节点呢，原因是栈是先进后出，我们要先弹出左子节点，故要先压入右子节点。然后在看有没有左子节点，有则压入，现在栈里面有两个个节点，依次是左子节点和右子节点，这个时候弹出左子节点，将左子节点视为根节点，继续重复上面过程，左子节点都弹出之后在弹出右子节点，将右子节点视为根节点，继续重复以上步骤。\n\n下面看中序遍历的非递归形式\n\n\tpublic void inOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t\twhile (root != null || !stack.isEmpty()) {\n\t\t\t\tif (root != null) {\n\t\t\t\t\tstack.push(root);\n\t\t\t\t\troot = root.left;\n\t\t\t\t}else {\n\t\t\t\t\troot = stack.pop();\n\t\t\t\t\tSystem.out.print(root.value);\n\t\t\t\t\troot = root.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n最后是后序遍历的非递归形式\n\n\tpublic void postOrder1(TreeNode root) {\n\t\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\t    Stack<TreeNode> output = new Stack<TreeNode>();\n\t\t    TreeNode node = root;\n\t\t    while (node != null || !stack.empty()) {\n\t\t      if (node != null) {\n\t\t        output.push(node);\n\t\t        stack.push(node);\t\t\t\t\n\t\t        node = node.right;\n\t\t      } else {\n\t\t        node = stack.pop();\t\t\t\t\n\t\t        node = node.left;\n\t\t      }\n\t\t    }\n\t\t    while (output.size() > 0) {\n\t\t    \tSystem.out.print(output.pop().value);\n\t\t    }\n\t\t}\n\n","slug":"bt","published":1,"updated":"2016-06-15T13:31:49.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmin001d1kvspdolai7x","content":"<p>今天复习了一下二叉树的遍历，包括递归与非递归形式，记录一下<br>首先定义一个简单的二叉树结构，包括节点的值与左子节点和右子节点<br><a id=\"more\"></a></p>\n<pre><code>public class TreeNode {\n    int value;\n    TreeNode left,right;\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n</code></pre><p>下面是递归方式实现的，首先是先序遍历</p>\n<pre><code>public void preOrder(TreeNode root) {\n        if (root != null) {\n            System.out.print(root.value);\n            preOrder(root.left);\n            preOrder(root.right);\n        }\n    }\n</code></pre><p>中序遍历</p>\n<pre><code>public void inOrder(TreeNode root) {\n        if (root != null) {\n            inOrder(root.left);\n            System.out.print(root.value);\n            inOrder(root.right);\n        }\n    }\n</code></pre><p>后序遍历</p>\n<pre><code>public void postOrder(TreeNode root) {\n        if (root != null) {\n            postOrder(root.left);\n            postOrder(root.right);\n            System.out.print(root.value);\n        }\n    }\n</code></pre><p>递归的形式比较简单，就是调整三行代码的顺序，下面来看非递归的实现。首先是先序遍历</p>\n<pre><code>public void preOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        if (root != null) {\n            stack.add(root);\n            while (!stack.isEmpty()) {\n                TreeNode p = stack.pop();\n                System.out.print(p.value);\n                if (p.right != null) {\n                    stack.add(p.right);\n                }\n                if (p.left != null) {\n                    stack.add(p.left);\n                }\n            }\n        }\n    }\n</code></pre><p>先序遍历是先遍历根节点，首先将根节点压入栈底，然后弹出，弹出时要记得输出。看当前根节点是否有右子节点，有则压入右子节点，为什么要先压入右子节点呢，原因是栈是先进后出，我们要先弹出左子节点，故要先压入右子节点。然后在看有没有左子节点，有则压入，现在栈里面有两个个节点，依次是左子节点和右子节点，这个时候弹出左子节点，将左子节点视为根节点，继续重复上面过程，左子节点都弹出之后在弹出右子节点，将右子节点视为根节点，继续重复以上步骤。</p>\n<p>下面看中序遍历的非递归形式</p>\n<pre><code>public void inOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        while (root != null || !stack.isEmpty()) {\n            if (root != null) {\n                stack.push(root);\n                root = root.left;\n            }else {\n                root = stack.pop();\n                System.out.print(root.value);\n                root = root.right;\n            }\n        }\n    }\n</code></pre><p>最后是后序遍历的非递归形式</p>\n<pre><code>public void postOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        Stack&lt;TreeNode&gt; output = new Stack&lt;TreeNode&gt;();\n        TreeNode node = root;\n        while (node != null || !stack.empty()) {\n          if (node != null) {\n            output.push(node);\n            stack.push(node);                \n            node = node.right;\n          } else {\n            node = stack.pop();                \n            node = node.left;\n          }\n        }\n        while (output.size() &gt; 0) {\n            System.out.print(output.pop().value);\n        }\n    }\n</code></pre>","excerpt":"<p>今天复习了一下二叉树的遍历，包括递归与非递归形式，记录一下<br>首先定义一个简单的二叉树结构，包括节点的值与左子节点和右子节点<br>","more":"</p>\n<pre><code>public class TreeNode {\n    int value;\n    TreeNode left,right;\n    public TreeNode(int value, TreeNode left, TreeNode right) {\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n</code></pre><p>下面是递归方式实现的，首先是先序遍历</p>\n<pre><code>public void preOrder(TreeNode root) {\n        if (root != null) {\n            System.out.print(root.value);\n            preOrder(root.left);\n            preOrder(root.right);\n        }\n    }\n</code></pre><p>中序遍历</p>\n<pre><code>public void inOrder(TreeNode root) {\n        if (root != null) {\n            inOrder(root.left);\n            System.out.print(root.value);\n            inOrder(root.right);\n        }\n    }\n</code></pre><p>后序遍历</p>\n<pre><code>public void postOrder(TreeNode root) {\n        if (root != null) {\n            postOrder(root.left);\n            postOrder(root.right);\n            System.out.print(root.value);\n        }\n    }\n</code></pre><p>递归的形式比较简单，就是调整三行代码的顺序，下面来看非递归的实现。首先是先序遍历</p>\n<pre><code>public void preOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        if (root != null) {\n            stack.add(root);\n            while (!stack.isEmpty()) {\n                TreeNode p = stack.pop();\n                System.out.print(p.value);\n                if (p.right != null) {\n                    stack.add(p.right);\n                }\n                if (p.left != null) {\n                    stack.add(p.left);\n                }\n            }\n        }\n    }\n</code></pre><p>先序遍历是先遍历根节点，首先将根节点压入栈底，然后弹出，弹出时要记得输出。看当前根节点是否有右子节点，有则压入右子节点，为什么要先压入右子节点呢，原因是栈是先进后出，我们要先弹出左子节点，故要先压入右子节点。然后在看有没有左子节点，有则压入，现在栈里面有两个个节点，依次是左子节点和右子节点，这个时候弹出左子节点，将左子节点视为根节点，继续重复上面过程，左子节点都弹出之后在弹出右子节点，将右子节点视为根节点，继续重复以上步骤。</p>\n<p>下面看中序遍历的非递归形式</p>\n<pre><code>public void inOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        while (root != null || !stack.isEmpty()) {\n            if (root != null) {\n                stack.push(root);\n                root = root.left;\n            }else {\n                root = stack.pop();\n                System.out.print(root.value);\n                root = root.right;\n            }\n        }\n    }\n</code></pre><p>最后是后序遍历的非递归形式</p>\n<pre><code>public void postOrder1(TreeNode root) {\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        Stack&lt;TreeNode&gt; output = new Stack&lt;TreeNode&gt;();\n        TreeNode node = root;\n        while (node != null || !stack.empty()) {\n          if (node != null) {\n            output.push(node);\n            stack.push(node);                \n            node = node.right;\n          } else {\n            node = stack.pop();                \n            node = node.left;\n          }\n        }\n        while (output.size() &gt; 0) {\n            System.out.print(output.pop().value);\n        }\n    }\n</code></pre>"},{"title":"heapSort","date":"2016-05-26T03:06:29.000Z","_content":"java堆排，记录一下。（选择排序，时间复杂度O(n*logn),不稳定排序）\n\n\tpublic void heapSort(int[] arr) {\n\t\t\tint arrLength = arr.length;\n\t\t\tfor(int i = 0;i<arrLength-1;i++){\n\t\t\t\tint lastIndex = arrLength-1-i;\n\t\t\t\tbuildMaxHeap(arr,lastIndex);\n\t\t\t\tswap(arr,0,lastIndex);\n\t\t\t}\n\t\t}\n\t\tpublic void buildMaxHeap(int[] arr,int lastIndex){\n\t\t\tfor(int i = (lastIndex-1)/2;i>=0;i--){\n\t\t\t\tint k = i;\n\t\t\t\twhile(k*2+1<=lastIndex){\n\t\t\t\t\tint biggerIndex = 2*k+1;\n\t\t\t\t\tif(biggerIndex<lastIndex){\n\t\t\t\t\t\tif(arr[biggerIndex]<arr[biggerIndex+1]){\n\t\t\t\t\t\t\tbiggerIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(arr[k]<arr[biggerIndex]){\n\t\t\t\t\t\tswap(arr,k,biggerIndex);\n\t\t\t\t\t\tk = biggerIndex;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n其他排序算法见 https://github.com/shly/datastructure","source":"_posts/heapSort.md","raw":"---\ntitle: heapSort\ndate: 2016-05-26 11:06:29\ntags: \n  - 排序算法\ncategories:\n  - 学习笔记\n  - 数据结构\n---\njava堆排，记录一下。（选择排序，时间复杂度O(n*logn),不稳定排序）\n\n\tpublic void heapSort(int[] arr) {\n\t\t\tint arrLength = arr.length;\n\t\t\tfor(int i = 0;i<arrLength-1;i++){\n\t\t\t\tint lastIndex = arrLength-1-i;\n\t\t\t\tbuildMaxHeap(arr,lastIndex);\n\t\t\t\tswap(arr,0,lastIndex);\n\t\t\t}\n\t\t}\n\t\tpublic void buildMaxHeap(int[] arr,int lastIndex){\n\t\t\tfor(int i = (lastIndex-1)/2;i>=0;i--){\n\t\t\t\tint k = i;\n\t\t\t\twhile(k*2+1<=lastIndex){\n\t\t\t\t\tint biggerIndex = 2*k+1;\n\t\t\t\t\tif(biggerIndex<lastIndex){\n\t\t\t\t\t\tif(arr[biggerIndex]<arr[biggerIndex+1]){\n\t\t\t\t\t\t\tbiggerIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(arr[k]<arr[biggerIndex]){\n\t\t\t\t\t\tswap(arr,k,biggerIndex);\n\t\t\t\t\t\tk = biggerIndex;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n其他排序算法见 https://github.com/shly/datastructure","slug":"heapSort","published":1,"updated":"2016-06-14T12:33:58.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmj3001g1kvsbu1cv36k","content":"<p>java堆排，记录一下。（选择排序，时间复杂度O(n*logn),不稳定排序）</p>\n<pre><code>public void heapSort(int[] arr) {\n        int arrLength = arr.length;\n        for(int i = 0;i&lt;arrLength-1;i++){\n            int lastIndex = arrLength-1-i;\n            buildMaxHeap(arr,lastIndex);\n            swap(arr,0,lastIndex);\n        }\n    }\n    public void buildMaxHeap(int[] arr,int lastIndex){\n        for(int i = (lastIndex-1)/2;i&gt;=0;i--){\n            int k = i;\n            while(k*2+1&lt;=lastIndex){\n                int biggerIndex = 2*k+1;\n                if(biggerIndex&lt;lastIndex){\n                    if(arr[biggerIndex]&lt;arr[biggerIndex+1]){\n                        biggerIndex++;\n                    }\n                }\n                if(arr[k]&lt;arr[biggerIndex]){\n                    swap(arr,k,biggerIndex);\n                    k = biggerIndex;\n                }else{\n                    break;\n                }\n            }\n        }\n    }\n</code></pre><p>其他排序算法见 <a href=\"https://github.com/shly/datastructure\" target=\"_blank\" rel=\"external\">https://github.com/shly/datastructure</a></p>\n","excerpt":"","more":"<p>java堆排，记录一下。（选择排序，时间复杂度O(n*logn),不稳定排序）</p>\n<pre><code>public void heapSort(int[] arr) {\n        int arrLength = arr.length;\n        for(int i = 0;i&lt;arrLength-1;i++){\n            int lastIndex = arrLength-1-i;\n            buildMaxHeap(arr,lastIndex);\n            swap(arr,0,lastIndex);\n        }\n    }\n    public void buildMaxHeap(int[] arr,int lastIndex){\n        for(int i = (lastIndex-1)/2;i&gt;=0;i--){\n            int k = i;\n            while(k*2+1&lt;=lastIndex){\n                int biggerIndex = 2*k+1;\n                if(biggerIndex&lt;lastIndex){\n                    if(arr[biggerIndex]&lt;arr[biggerIndex+1]){\n                        biggerIndex++;\n                    }\n                }\n                if(arr[k]&lt;arr[biggerIndex]){\n                    swap(arr,k,biggerIndex);\n                    k = biggerIndex;\n                }else{\n                    break;\n                }\n            }\n        }\n    }\n</code></pre><p>其他排序算法见 <a href=\"https://github.com/shly/datastructure\">https://github.com/shly/datastructure</a></p>\n"},{"title":"gulp API","date":"2016-07-21T08:58:18.000Z","_content":"\n来源：http://www.gulpjs.com.cn/docs/api/\n\n自动化构建工具gulp\n<!-- more -->\n\n一 gulp.src(globs[,options])\n输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。\n\n\tgulp.src('client/templates/*.jade')\n\t  .pipe(jade())\n\t  .pipe(minify())\n\t  .pipe(gulp.dest('build/minified_templates'));\nglob 请参考 node-glob 语法 或者，你也可以直接写文件的路径。\n\nglobs\n\n类型： String 或 Array\n\n所要读取的 glob 或者包含 globs 的数组。\noptions\n\n类型： Object\n\n通过 glob-stream 所传递给 node-glob 的参数。\n\n除了 node-glob 和 glob-stream 所支持的参数外，gulp 增加了一些额外的选项参数：\noptions.buffer\n\n类型： Boolean 默认值： true\n\n如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。**注意：**插件可能并不会实现对 stream 的支持。\n\noptions.read\n\n类型： Boolean 默认值： true\n\n如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。\n\noptions.base\n\n类型： String 默认值： 将会加在 glob 之前 (请看 glob2base)\n\n二 gulp.dest(path[, options])\n能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。\npath\n\n类型： String or Function\n\n文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。\n\noptions\n\n类型： Object\n\noptions.cwd\n\n类型： String 默认值： process.cwd()\n\n输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n\noptions.mode\n\n类型： String 默认值： 0777\n\n八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n三 gulp.task(name[, deps], fn)\n\n定义一个使用 Orchestrator 实现的任务（task）。\nname\n\n任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。\n\ndeps\n\n类型： Array\n\n一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。\n\tgulp.task('mytask', ['array', 'of', 'task', 'names'], function() {\n\t  // 做一些事\n\t});\n注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。\n\nfn\n\n该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。\n\n异步任务支持\n\n任务可以异步执行，如果 fn 能做到以下其中一点：\n\n接受一个 callback\n\n\t// 在 shell 中执行一个命令\n\tvar exec = require('child_process').exec;\n\tgulp.task('jekyll', function(cb) {\n\t  // 编译 Jekyll\n\t  exec('jekyll build', function(err) {\n\t    if (err) return cb(err); // 返回 error\n\t    cb(); // 完成 task\n\t  });\n\t});\n返回一个 stream\n\n\tgulp.task('somename', function() {\n\t  var stream = gulp.src('client/**/*.js')\n\t    .pipe(minify())\n\t    .pipe(gulp.dest('build'));\n\t  return stream;\n\t});\n返回一个 promise\n\n\tvar Q = require('q');\n\n\tgulp.task('somename', function() {\n\t  var deferred = Q.defer();\n\n\t  // 执行异步的操作\n\t  setTimeout(function() {\n\t    deferred.resolve();\n\t  }, 1);\n\n\t  return deferred.promise;\n\t});\n\n注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事：\n\n给出一个提示，来告知 task 什么时候执行完毕，\n并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。\n对于这个例子，让我们先假定你有两个 task，\"one\" 和 \"two\"，并且你希望它们按照这个顺序执行：\n\n在 \"one\" 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。\n\n在 \"two\" 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。\n\n因此，这个例子的实际代码将会是这样：\n\n\tvar gulp = require('gulp');\n\n\t// 返回一个 callback，因此系统可以知道它什么时候完成\n\tgulp.task('one', function(cb) {\n\t    // 做一些事 -- 异步的或者其他的\n\t    cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\n\t});\n\n\t// 定义一个所依赖的 task 必须在这个 task 执行之前完成\n\tgulp.task('two', ['one'], function() {\n\t    // 'one' 完成后\n\t});\n\n\tgulp.task('default', ['one', 'two']);\n\n四 gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])\n\n监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。\n\n（1）gulp.watch(glob[, opts], tasks)\n\nglob\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\nopts\n\n类型： Object\n\n传给 gaze 的参数。\n\ntasks\n\n类型： Array\n\n需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字，\n\n\tvar watcher = gulp.watch('js/**/*.js', ['uglify','reload']);\n\twatcher.on('change', function(event) {\n\t  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\n（2）gulp.watch(glob[, opts, cb])\n\nglob\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\nopts\n\n类型： Object\n\n传给 gaze 的参数。\n\ncb(event)\n\n类型： Function\n\n每次变动需要执行的 callback。\n\n\tgulp.watch('js/**/*.js', function(event) {\n\t  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\ncallback 会被传入一个名为 event 的对象。这个对象描述了所监控到的变动：\n\nevent.type\n\n类型： String\n\n发生的变动的类型：added, changed 或者 deleted。\n\nevent.path\n\n类型： String\n\n触发了该事件的文件的路径。\n\n用法举例：\n\n\tgulp.task('styles', function() {\n\t    return gulp.src('sass/demo.scss')\n\t        .pipe($.sass())\n\t        .pipe($.autoprefixer())\n\t        .pipe(gulp.dest('css'));\n\t});","source":"_posts/gulp.md","raw":"---\ntitle: gulp API\ndate: 2016-07-21 16:58:18\ntags:\n---\n\n来源：http://www.gulpjs.com.cn/docs/api/\n\n自动化构建工具gulp\n<!-- more -->\n\n一 gulp.src(globs[,options])\n输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。\n\n\tgulp.src('client/templates/*.jade')\n\t  .pipe(jade())\n\t  .pipe(minify())\n\t  .pipe(gulp.dest('build/minified_templates'));\nglob 请参考 node-glob 语法 或者，你也可以直接写文件的路径。\n\nglobs\n\n类型： String 或 Array\n\n所要读取的 glob 或者包含 globs 的数组。\noptions\n\n类型： Object\n\n通过 glob-stream 所传递给 node-glob 的参数。\n\n除了 node-glob 和 glob-stream 所支持的参数外，gulp 增加了一些额外的选项参数：\noptions.buffer\n\n类型： Boolean 默认值： true\n\n如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。**注意：**插件可能并不会实现对 stream 的支持。\n\noptions.read\n\n类型： Boolean 默认值： true\n\n如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。\n\noptions.base\n\n类型： String 默认值： 将会加在 glob 之前 (请看 glob2base)\n\n二 gulp.dest(path[, options])\n能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。\npath\n\n类型： String or Function\n\n文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。\n\noptions\n\n类型： Object\n\noptions.cwd\n\n类型： String 默认值： process.cwd()\n\n输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n\noptions.mode\n\n类型： String 默认值： 0777\n\n八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n三 gulp.task(name[, deps], fn)\n\n定义一个使用 Orchestrator 实现的任务（task）。\nname\n\n任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。\n\ndeps\n\n类型： Array\n\n一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。\n\tgulp.task('mytask', ['array', 'of', 'task', 'names'], function() {\n\t  // 做一些事\n\t});\n注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。\n\nfn\n\n该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。\n\n异步任务支持\n\n任务可以异步执行，如果 fn 能做到以下其中一点：\n\n接受一个 callback\n\n\t// 在 shell 中执行一个命令\n\tvar exec = require('child_process').exec;\n\tgulp.task('jekyll', function(cb) {\n\t  // 编译 Jekyll\n\t  exec('jekyll build', function(err) {\n\t    if (err) return cb(err); // 返回 error\n\t    cb(); // 完成 task\n\t  });\n\t});\n返回一个 stream\n\n\tgulp.task('somename', function() {\n\t  var stream = gulp.src('client/**/*.js')\n\t    .pipe(minify())\n\t    .pipe(gulp.dest('build'));\n\t  return stream;\n\t});\n返回一个 promise\n\n\tvar Q = require('q');\n\n\tgulp.task('somename', function() {\n\t  var deferred = Q.defer();\n\n\t  // 执行异步的操作\n\t  setTimeout(function() {\n\t    deferred.resolve();\n\t  }, 1);\n\n\t  return deferred.promise;\n\t});\n\n注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事：\n\n给出一个提示，来告知 task 什么时候执行完毕，\n并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。\n对于这个例子，让我们先假定你有两个 task，\"one\" 和 \"two\"，并且你希望它们按照这个顺序执行：\n\n在 \"one\" 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。\n\n在 \"two\" 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。\n\n因此，这个例子的实际代码将会是这样：\n\n\tvar gulp = require('gulp');\n\n\t// 返回一个 callback，因此系统可以知道它什么时候完成\n\tgulp.task('one', function(cb) {\n\t    // 做一些事 -- 异步的或者其他的\n\t    cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\n\t});\n\n\t// 定义一个所依赖的 task 必须在这个 task 执行之前完成\n\tgulp.task('two', ['one'], function() {\n\t    // 'one' 完成后\n\t});\n\n\tgulp.task('default', ['one', 'two']);\n\n四 gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])\n\n监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。\n\n（1）gulp.watch(glob[, opts], tasks)\n\nglob\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\nopts\n\n类型： Object\n\n传给 gaze 的参数。\n\ntasks\n\n类型： Array\n\n需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字，\n\n\tvar watcher = gulp.watch('js/**/*.js', ['uglify','reload']);\n\twatcher.on('change', function(event) {\n\t  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\n（2）gulp.watch(glob[, opts, cb])\n\nglob\n\n类型： String or Array\n\n一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。\n\nopts\n\n类型： Object\n\n传给 gaze 的参数。\n\ncb(event)\n\n类型： Function\n\n每次变动需要执行的 callback。\n\n\tgulp.watch('js/**/*.js', function(event) {\n\t  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');\n\t});\ncallback 会被传入一个名为 event 的对象。这个对象描述了所监控到的变动：\n\nevent.type\n\n类型： String\n\n发生的变动的类型：added, changed 或者 deleted。\n\nevent.path\n\n类型： String\n\n触发了该事件的文件的路径。\n\n用法举例：\n\n\tgulp.task('styles', function() {\n\t    return gulp.src('sass/demo.scss')\n\t        .pipe($.sass())\n\t        .pipe($.autoprefixer())\n\t        .pipe(gulp.dest('css'));\n\t});","slug":"gulp","published":1,"updated":"2016-07-27T13:03:38.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmj3001k1kvslzeqw1v0","content":"<p>来源：<a href=\"http://www.gulpjs.com.cn/docs/api/\" target=\"_blank\" rel=\"external\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<p>自动化构建工具gulp<br><a id=\"more\"></a></p>\n<p>一 gulp.src(globs[,options])<br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。</p>\n<pre><code>gulp.src(&apos;client/templates/*.jade&apos;)\n  .pipe(jade())\n  .pipe(minify())\n  .pipe(gulp.dest(&apos;build/minified_templates&apos;));\n</code></pre><p>glob 请参考 node-glob 语法 或者，你也可以直接写文件的路径。</p>\n<p>globs</p>\n<p>类型： String 或 Array</p>\n<p>所要读取的 glob 或者包含 globs 的数组。<br>options</p>\n<p>类型： Object</p>\n<p>通过 glob-stream 所传递给 node-glob 的参数。</p>\n<p>除了 node-glob 和 glob-stream 所支持的参数外，gulp 增加了一些额外的选项参数：<br>options.buffer</p>\n<p>类型： Boolean 默认值： true</p>\n<p>如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。<strong>注意：</strong>插件可能并不会实现对 stream 的支持。</p>\n<p>options.read</p>\n<p>类型： Boolean 默认值： true</p>\n<p>如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。</p>\n<p>options.base</p>\n<p>类型： String 默认值： 将会加在 glob 之前 (请看 glob2base)</p>\n<p>二 gulp.dest(path[, options])<br>能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。<br>path</p>\n<p>类型： String or Function</p>\n<p>文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。</p>\n<p>options</p>\n<p>类型： Object</p>\n<p>options.cwd</p>\n<p>类型： String 默认值： process.cwd()</p>\n<p>输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</p>\n<p>options.mode</p>\n<p>类型： String 默认值： 0777</p>\n<p>八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</p>\n<p>三 gulp.task(name[, deps], fn)</p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>name</p>\n<p>任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。</p>\n<p>deps</p>\n<p>类型： Array</p>\n<p>一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。<br>    gulp.task(‘mytask’, [‘array’, ‘of’, ‘task’, ‘names’], function() {<br>      // 做一些事<br>    });<br>注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。</p>\n<p>fn</p>\n<p>该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。</p>\n<p>异步任务支持</p>\n<p>任务可以异步执行，如果 fn 能做到以下其中一点：</p>\n<p>接受一个 callback</p>\n<pre><code>// 在 shell 中执行一个命令\nvar exec = require(&apos;child_process&apos;).exec;\ngulp.task(&apos;jekyll&apos;, function(cb) {\n  // 编译 Jekyll\n  exec(&apos;jekyll build&apos;, function(err) {\n    if (err) return cb(err); // 返回 error\n    cb(); // 完成 task\n  });\n});\n</code></pre><p>返回一个 stream</p>\n<pre><code>gulp.task(&apos;somename&apos;, function() {\n  var stream = gulp.src(&apos;client/**/*.js&apos;)\n    .pipe(minify())\n    .pipe(gulp.dest(&apos;build&apos;));\n  return stream;\n});\n</code></pre><p>返回一个 promise</p>\n<pre><code>var Q = require(&apos;q&apos;);\n\ngulp.task(&apos;somename&apos;, function() {\n  var deferred = Q.defer();\n\n  // 执行异步的操作\n  setTimeout(function() {\n    deferred.resolve();\n  }, 1);\n\n  return deferred.promise;\n});\n</code></pre><p>注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事：</p>\n<p>给出一个提示，来告知 task 什么时候执行完毕，<br>并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。<br>对于这个例子，让我们先假定你有两个 task，”one” 和 “two”，并且你希望它们按照这个顺序执行：</p>\n<p>在 “one” 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。</p>\n<p>在 “two” 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。</p>\n<p>因此，这个例子的实际代码将会是这样：</p>\n<pre><code>var gulp = require(&apos;gulp&apos;);\n\n// 返回一个 callback，因此系统可以知道它什么时候完成\ngulp.task(&apos;one&apos;, function(cb) {\n    // 做一些事 -- 异步的或者其他的\n    cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\n});\n\n// 定义一个所依赖的 task 必须在这个 task 执行之前完成\ngulp.task(&apos;two&apos;, [&apos;one&apos;], function() {\n    // &apos;one&apos; 完成后\n});\n\ngulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;]);\n</code></pre><p>四 gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</p>\n<p>监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。</p>\n<p>（1）gulp.watch(glob[, opts], tasks)</p>\n<p>glob</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>opts</p>\n<p>类型： Object</p>\n<p>传给 gaze 的参数。</p>\n<p>tasks</p>\n<p>类型： Array</p>\n<p>需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字，</p>\n<pre><code>var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);\nwatcher.on(&apos;change&apos;, function(event) {\n  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);\n});\n</code></pre><p>（2）gulp.watch(glob[, opts, cb])</p>\n<p>glob</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>opts</p>\n<p>类型： Object</p>\n<p>传给 gaze 的参数。</p>\n<p>cb(event)</p>\n<p>类型： Function</p>\n<p>每次变动需要执行的 callback。</p>\n<pre><code>gulp.watch(&apos;js/**/*.js&apos;, function(event) {\n  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);\n});\n</code></pre><p>callback 会被传入一个名为 event 的对象。这个对象描述了所监控到的变动：</p>\n<p>event.type</p>\n<p>类型： String</p>\n<p>发生的变动的类型：added, changed 或者 deleted。</p>\n<p>event.path</p>\n<p>类型： String</p>\n<p>触发了该事件的文件的路径。</p>\n<p>用法举例：</p>\n<pre><code>gulp.task(&apos;styles&apos;, function() {\n    return gulp.src(&apos;sass/demo.scss&apos;)\n        .pipe($.sass())\n        .pipe($.autoprefixer())\n        .pipe(gulp.dest(&apos;css&apos;));\n});\n</code></pre>","excerpt":"<p>来源：<a href=\"http://www.gulpjs.com.cn/docs/api/\">http://www.gulpjs.com.cn/docs/api/</a></p>\n<p>自动化构建工具gulp<br>","more":"</p>\n<p>一 gulp.src(globs[,options])<br>输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。</p>\n<pre><code>gulp.src(&apos;client/templates/*.jade&apos;)\n  .pipe(jade())\n  .pipe(minify())\n  .pipe(gulp.dest(&apos;build/minified_templates&apos;));\n</code></pre><p>glob 请参考 node-glob 语法 或者，你也可以直接写文件的路径。</p>\n<p>globs</p>\n<p>类型： String 或 Array</p>\n<p>所要读取的 glob 或者包含 globs 的数组。<br>options</p>\n<p>类型： Object</p>\n<p>通过 glob-stream 所传递给 node-glob 的参数。</p>\n<p>除了 node-glob 和 glob-stream 所支持的参数外，gulp 增加了一些额外的选项参数：<br>options.buffer</p>\n<p>类型： Boolean 默认值： true</p>\n<p>如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。<strong>注意：</strong>插件可能并不会实现对 stream 的支持。</p>\n<p>options.read</p>\n<p>类型： Boolean 默认值： true</p>\n<p>如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。</p>\n<p>options.base</p>\n<p>类型： String 默认值： 将会加在 glob 之前 (请看 glob2base)</p>\n<p>二 gulp.dest(path[, options])<br>能被 pipe 进来，并且将会写文件。并且重新输出（emits）所有数据，因此你可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。<br>path</p>\n<p>类型： String or Function</p>\n<p>文件将被写入的路径（输出目录）。也可以传入一个函数，在函数中返回相应路径，这个函数也可以由 vinyl 文件实例 来提供。</p>\n<p>options</p>\n<p>类型： Object</p>\n<p>options.cwd</p>\n<p>类型： String 默认值： process.cwd()</p>\n<p>输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</p>\n<p>options.mode</p>\n<p>类型： String 默认值： 0777</p>\n<p>八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</p>\n<p>三 gulp.task(name[, deps], fn)</p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>name</p>\n<p>任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。</p>\n<p>deps</p>\n<p>类型： Array</p>\n<p>一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。<br>    gulp.task(‘mytask’, [‘array’, ‘of’, ‘task’, ‘names’], function() {<br>      // 做一些事<br>    });<br>注意： 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。</p>\n<p>fn</p>\n<p>该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。</p>\n<p>异步任务支持</p>\n<p>任务可以异步执行，如果 fn 能做到以下其中一点：</p>\n<p>接受一个 callback</p>\n<pre><code>// 在 shell 中执行一个命令\nvar exec = require(&apos;child_process&apos;).exec;\ngulp.task(&apos;jekyll&apos;, function(cb) {\n  // 编译 Jekyll\n  exec(&apos;jekyll build&apos;, function(err) {\n    if (err) return cb(err); // 返回 error\n    cb(); // 完成 task\n  });\n});\n</code></pre><p>返回一个 stream</p>\n<pre><code>gulp.task(&apos;somename&apos;, function() {\n  var stream = gulp.src(&apos;client/**/*.js&apos;)\n    .pipe(minify())\n    .pipe(gulp.dest(&apos;build&apos;));\n  return stream;\n});\n</code></pre><p>返回一个 promise</p>\n<pre><code>var Q = require(&apos;q&apos;);\n\ngulp.task(&apos;somename&apos;, function() {\n  var deferred = Q.defer();\n\n  // 执行异步的操作\n  setTimeout(function() {\n    deferred.resolve();\n  }, 1);\n\n  return deferred.promise;\n});\n</code></pre><p>注意： 默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，你需要做两件事：</p>\n<p>给出一个提示，来告知 task 什么时候执行完毕，<br>并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。<br>对于这个例子，让我们先假定你有两个 task，”one” 和 “two”，并且你希望它们按照这个顺序执行：</p>\n<p>在 “one” 中，你加入一个提示，来告知什么时候它会完成：可以再完成时候返回一个 callback，或者返回一个 promise 或 stream，这样系统会去等待它完成。</p>\n<p>在 “two” 中，你需要添加一个提示来告诉系统它需要依赖第一个 task 完成。</p>\n<p>因此，这个例子的实际代码将会是这样：</p>\n<pre><code>var gulp = require(&apos;gulp&apos;);\n\n// 返回一个 callback，因此系统可以知道它什么时候完成\ngulp.task(&apos;one&apos;, function(cb) {\n    // 做一些事 -- 异步的或者其他的\n    cb(err); // 如果 err 不是 null 或 undefined，则会停止执行，且注意，这样代表执行失败了\n});\n\n// 定义一个所依赖的 task 必须在这个 task 执行之前完成\ngulp.task(&apos;two&apos;, [&apos;one&apos;], function() {\n    // &apos;one&apos; 完成后\n});\n\ngulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;]);\n</code></pre><p>四 gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</p>\n<p>监视文件，并且可以在文件发生改动时候做一些事情。它总会返回一个 EventEmitter 来发射（emit） change 事件。</p>\n<p>（1）gulp.watch(glob[, opts], tasks)</p>\n<p>glob</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>opts</p>\n<p>类型： Object</p>\n<p>传给 gaze 的参数。</p>\n<p>tasks</p>\n<p>类型： Array</p>\n<p>需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字，</p>\n<pre><code>var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);\nwatcher.on(&apos;change&apos;, function(event) {\n  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);\n});\n</code></pre><p>（2）gulp.watch(glob[, opts, cb])</p>\n<p>glob</p>\n<p>类型： String or Array</p>\n<p>一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动。</p>\n<p>opts</p>\n<p>类型： Object</p>\n<p>传给 gaze 的参数。</p>\n<p>cb(event)</p>\n<p>类型： Function</p>\n<p>每次变动需要执行的 callback。</p>\n<pre><code>gulp.watch(&apos;js/**/*.js&apos;, function(event) {\n  console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);\n});\n</code></pre><p>callback 会被传入一个名为 event 的对象。这个对象描述了所监控到的变动：</p>\n<p>event.type</p>\n<p>类型： String</p>\n<p>发生的变动的类型：added, changed 或者 deleted。</p>\n<p>event.path</p>\n<p>类型： String</p>\n<p>触发了该事件的文件的路径。</p>\n<p>用法举例：</p>\n<pre><code>gulp.task(&apos;styles&apos;, function() {\n    return gulp.src(&apos;sass/demo.scss&apos;)\n        .pipe($.sass())\n        .pipe($.autoprefixer())\n        .pipe(gulp.dest(&apos;css&apos;));\n});\n</code></pre>"},{"title":"inline-block空div和有内容的div显示不在一行的问题","date":"2016-07-27T07:18:01.000Z","_content":"当使用css实现div在同一行中显示时，可以使用将div的display属性设为inline-block的方式，但是使用这种方式设置会有一个问题，即空的div和有内容的div并不在同一条水平线上。如下面例子中第一行的div。\nhttp://slygg.cn/shly/IFE/task_13/index.html\n<!-- more -->\n\n那么为什么会产生这种现象呢？\n\nhttp://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/","source":"_posts/inline-block.md","raw":"---\ntitle: inline-block空div和有内容的div显示不在一行的问题\ndate: 2016-07-27 15:18:01\ntags: \n  - css\n  - inline-block\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n当使用css实现div在同一行中显示时，可以使用将div的display属性设为inline-block的方式，但是使用这种方式设置会有一个问题，即空的div和有内容的div并不在同一条水平线上。如下面例子中第一行的div。\nhttp://slygg.cn/shly/IFE/task_13/index.html\n<!-- more -->\n\n那么为什么会产生这种现象呢？\n\nhttp://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/","slug":"inline-block","published":1,"updated":"2016-07-27T13:03:38.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmji001n1kvsgkvx1bk4","content":"<p>当使用css实现div在同一行中显示时，可以使用将div的display属性设为inline-block的方式，但是使用这种方式设置会有一个问题，即空的div和有内容的div并不在同一条水平线上。如下面例子中第一行的div。<br><a href=\"http://slygg.cn/shly/IFE/task_13/index.html\" target=\"_blank\" rel=\"external\">http://slygg.cn/shly/IFE/task_13/index.html</a><br><a id=\"more\"></a></p>\n<p>那么为什么会产生这种现象呢？</p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/\" target=\"_blank\" rel=\"external\">http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/</a></p>\n","excerpt":"<p>当使用css实现div在同一行中显示时，可以使用将div的display属性设为inline-block的方式，但是使用这种方式设置会有一个问题，即空的div和有内容的div并不在同一条水平线上。如下面例子中第一行的div。<br><a href=\"http://slygg.cn/shly/IFE/task_13/index.html\">http://slygg.cn/shly/IFE/task_13/index.html</a><br>","more":"</p>\n<p>那么为什么会产生这种现象呢？</p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/\">http://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/</a></p>"},{"title":"jQuery each方法","date":"2016-06-16T07:59:50.000Z","_content":"\njQuery中有两个each方法，一个是$().each(callback),一个是$.each();\nAPI中对$().each(callback)的描述如下：\n以每一个匹配的元素作为上下文来执行一个函数。\n<!-- more -->\n意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 'false' 将停止循环 (就像在普通的循环中使用 'break')。返回 'true' 跳至下一个循环(就像在普通的循环中使用'continue')。\ncallback是对每个匹配元素要执行的函数。\n\n对jQuery.each(object, [callback])的描述如下：\n通用例遍方法，可用于例遍对象和数组。\n不同于例遍 jQuery 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。\n两个参数：\nobject:需要例遍的对象或数组。\ncallback:每个成员/元素执行的回调函数。\n\n为了更好的理解两个方法，来看一下jQuery-1.11.3中两个方法的实现：\n\n\tjQuery.fn = jQuery.prototype = {\n\t\teach: function( callback, args ) {\n\t\t\treturn jQuery.each( this, callback, args );\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\t\t\teach: function( obj, callback, args ) {\n\t\t\t\tvar value,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tlength = obj.length,\n\t\t\t\t\tisArray = isArraylike( obj );\n\n\t\t\t\tif ( args ) {\n\t\t\t\t\tif ( isArray ) {\n\t\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// A special, fast, case for the most common use of each\n\t\t\t\t} else {\n\t\t\t\t\tif ( isArray ) {\n\t\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t})\n","source":"_posts/each.md","raw":"---\ntitle: jQuery each方法\ndate: 2016-06-16 15:59:50\ntags: \n  - jquery\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n\njQuery中有两个each方法，一个是$().each(callback),一个是$.each();\nAPI中对$().each(callback)的描述如下：\n以每一个匹配的元素作为上下文来执行一个函数。\n<!-- more -->\n意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 'false' 将停止循环 (就像在普通的循环中使用 'break')。返回 'true' 跳至下一个循环(就像在普通的循环中使用'continue')。\ncallback是对每个匹配元素要执行的函数。\n\n对jQuery.each(object, [callback])的描述如下：\n通用例遍方法，可用于例遍对象和数组。\n不同于例遍 jQuery 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。\n两个参数：\nobject:需要例遍的对象或数组。\ncallback:每个成员/元素执行的回调函数。\n\n为了更好的理解两个方法，来看一下jQuery-1.11.3中两个方法的实现：\n\n\tjQuery.fn = jQuery.prototype = {\n\t\teach: function( callback, args ) {\n\t\t\treturn jQuery.each( this, callback, args );\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\t\t\teach: function( obj, callback, args ) {\n\t\t\t\tvar value,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tlength = obj.length,\n\t\t\t\t\tisArray = isArraylike( obj );\n\n\t\t\t\tif ( args ) {\n\t\t\t\t\tif ( isArray ) {\n\t\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// A special, fast, case for the most common use of each\n\t\t\t\t} else {\n\t\t\t\t\tif ( isArray ) {\n\t\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t})\n","slug":"each","published":1,"updated":"2016-06-18T13:53:41.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmji001r1kvstvljrgai","content":"<p>jQuery中有两个each方法，一个是$().each(callback),一个是$.each();<br>API中对$().each(callback)的描述如下：<br>以每一个匹配的元素作为上下文来执行一个函数。<br><a id=\"more\"></a><br>意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 ‘false’ 将停止循环 (就像在普通的循环中使用 ‘break’)。返回 ‘true’ 跳至下一个循环(就像在普通的循环中使用’continue’)。<br>callback是对每个匹配元素要执行的函数。</p>\n<p>对jQuery.each(object, [callback])的描述如下：<br>通用例遍方法，可用于例遍对象和数组。<br>不同于例遍 jQuery 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。<br>两个参数：<br>object:需要例遍的对象或数组。<br>callback:每个成员/元素执行的回调函数。</p>\n<p>为了更好的理解两个方法，来看一下jQuery-1.11.3中两个方法的实现：</p>\n<pre><code>jQuery.fn = jQuery.prototype = {\n    each: function( callback, args ) {\n        return jQuery.each( this, callback, args );\n    }\n}\n\njQuery.extend({\n            each: function( obj, callback, args ) {\n            var value,\n                i = 0,\n                length = obj.length,\n                isArray = isArraylike( obj );\n\n            if ( args ) {\n                if ( isArray ) {\n                    for ( ; i &lt; length; i++ ) {\n                        value = callback.apply( obj[ i ], args );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                } else {\n                    for ( i in obj ) {\n                        value = callback.apply( obj[ i ], args );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                }\n\n            // A special, fast, case for the most common use of each\n            } else {\n                if ( isArray ) {\n                    for ( ; i &lt; length; i++ ) {\n                        value = callback.call( obj[ i ], i, obj[ i ] );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                } else {\n                    for ( i in obj ) {\n                        value = callback.call( obj[ i ], i, obj[ i ] );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return obj;\n        }\n    })\n</code></pre>","excerpt":"<p>jQuery中有两个each方法，一个是$().each(callback),一个是$.each();<br>API中对$().each(callback)的描述如下：<br>以每一个匹配的元素作为上下文来执行一个函数。<br>","more":"<br>意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 ‘false’ 将停止循环 (就像在普通的循环中使用 ‘break’)。返回 ‘true’ 跳至下一个循环(就像在普通的循环中使用’continue’)。<br>callback是对每个匹配元素要执行的函数。</p>\n<p>对jQuery.each(object, [callback])的描述如下：<br>通用例遍方法，可用于例遍对象和数组。<br>不同于例遍 jQuery 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。<br>两个参数：<br>object:需要例遍的对象或数组。<br>callback:每个成员/元素执行的回调函数。</p>\n<p>为了更好的理解两个方法，来看一下jQuery-1.11.3中两个方法的实现：</p>\n<pre><code>jQuery.fn = jQuery.prototype = {\n    each: function( callback, args ) {\n        return jQuery.each( this, callback, args );\n    }\n}\n\njQuery.extend({\n            each: function( obj, callback, args ) {\n            var value,\n                i = 0,\n                length = obj.length,\n                isArray = isArraylike( obj );\n\n            if ( args ) {\n                if ( isArray ) {\n                    for ( ; i &lt; length; i++ ) {\n                        value = callback.apply( obj[ i ], args );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                } else {\n                    for ( i in obj ) {\n                        value = callback.apply( obj[ i ], args );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                }\n\n            // A special, fast, case for the most common use of each\n            } else {\n                if ( isArray ) {\n                    for ( ; i &lt; length; i++ ) {\n                        value = callback.call( obj[ i ], i, obj[ i ] );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                } else {\n                    for ( i in obj ) {\n                        value = callback.call( obj[ i ], i, obj[ i ] );\n\n                        if ( value === false ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return obj;\n        }\n    })\n</code></pre>"},{"title":"html标签学习","date":"2016-05-06T02:36:02.000Z","_content":"# a标签\n## 属性\n1. href\n2. target \n规定在何处打开新链接。\n3. media\n 属性规定目标URL是为什么媒介/设备优化的。可接受多个值。且只能在href属性存在时使用。\n   *html5 中的新属性*\n   <!--more-->\n4. download\n 规定被下载的超链接目标。只有firefox和Chrome支持。\n *html5新属性*。\n\t\t<a download=\"filename\"> \nfilename 为下载之后文件的名字。没有指定filename时只下载不重命名。\n5. type\n 规定被链接文档的MIMI类型。\n*html5新属性*\n6. hreflang\n 规定被链接文档的语言。仅在使用href属性时才使用。和 lang 属性不同的是，hreflang 属性不会指定标签中的内容所使用的语言，而是指定被 href 属性调用的文档所使用的语言。\n\\* 主流的浏览器几乎都不支持 hreflang 属性。\n7. rel\n 指定当前文档与被链接文档之间的关系。所有浏览器都支持。尽管浏览器不会以任何方式使用该属性，不过搜索引擎可以利用该属性获得更多有关链接的信息。\n8. rev\n 指定当前文档与被链接文档之间的关系。rel是指定从源文档到目标文档之间的关系，rev指定从目标文档到源文档之间的关系。\n*几乎没有浏览器支持，html 5废除*\n9. charset\n 规定被链接文档的字符集\n*主流的浏览器几乎都不支持 charset 属性。html 5废除*\n10. shape\n 规定链接的形状。只有 Firefox 和 Opera 支持 shape 属性。\n*html 5废除*\n11. coords\n coords 属性与 shape 属性配合，可以规定 object 或 img 元素中链接的尺寸、形状和位置。\n*只有 Firefox 和 Opera 支持 coords 属性。html 5废除*\n12. name\n 描述锚的名称。主流浏览器都支持。id出现之前用的name，后id出现为了保证兼容性而保留。\n*html 5废除*\n\n## 总结\n共12个属性，html 5新添属性有download，media，type三个。html 5 废除属性有charset,coords,name,rev,shape五个，剩下 href,target,rel,hreflang四个。其中hreflang主流浏览器都不支持。\n# abbr标签\n缩写，所有浏览器都支持。\n\n\t\tThe <abbr title=\"People's Republic of China\">PRC</abbr> was founded in 1949.\n# acronym标签\n首字母缩写。所有浏览器支持。html 5 废除，使用abbr代替。\n# address标签\n&lt;address>标签定义文档或文章的作者/拥有者的联系信息。\n如果 &lt;address> 元素位于 &lt;body> 元素内，则它表示文档联系信息。\n如果 &lt;address> 元素位于 &lt;article> 元素内，则它表示文章的联系信息。\n&lt;address> 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。\n*所有主流浏览器支持，html 5新添*\n# applet标签\n定义嵌入的java applet。\n*html 5废除，使用object代替。html 4.01中也不赞成使用*\n# area标签\n定义图像映射中的区域。area元素总是嵌套在map标签中。所有主流浏览器都支持。\n&lt;img> 标签中的 usemap 属性与 map 元素 name 属性相关联，创建图像与映射之间的联系。\n&lt;img> 中的 usemap 属性可引用 &lt;map> 中的 id 或 name 属性（由浏览器决定），所以我们需要同时向 &lt;map> 添加 id 和 name 两个属性。\n## 必需属性 \nalt，定义此区域的替换文本。\n## 可选属性\n 1. shape\n定义区域的形状。可选值：圆形（circ 或 circle）、多边形（poly 或 polygon）、矩形（rect 或 rectangle）和default。未规定shape时会假定使用default。意味着该区域会覆盖整个图像。可以识别 shape 属性的 default 值的浏览器，可以提供一个包括全部热点的区域，以用于在超过其他热点定义的范围之外单击的情况。由于区域在 <map> 标签中是采用“先来先得”的顺序，所有必须将默认区域放置在后面。否则，默认区域会覆盖其他的图像映射中出现的所有区域。\n所有浏览器都支持。\n 2. coords\n坐标值，定义可点击区域的坐标。与shape属性配合使用。\n圆形：shape=\"circle\"，coords=\"x,y,z\"\n这里的 x 和 y 定义了圆心的位置（\"0,0\" 是图像左上角的坐标），r 是以像素为单位的圆形半径。\n多边形：shape=\"polygon\"，coords=\"x1,y1,x2,y2,x3,y3,...\"\n每一对 \"x,y\" 坐标都定义了多边形的一个顶点（\"0,0\" 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。\n多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。\n矩形：shape=\"rectangle\"，coords=\"x1,y1,x2,y2\"\n第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，\"0,0\" 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。\n 3. href\nhref 属性规定区域中连接的目标。\n 4. nohref\nnohref 属性规定该区域没有相关的链接。\n 5. target\n\n# article标签\n规定独立的自包含内容。\n一篇文章应该具有其自身的意义。应该有可能独立于站点的其他部分对齐进行分发。\n&lt;article> 元素的潜在来源：\n 论坛帖子\n 报纸文章\n 博客条目\n 用户评论\n*html 5新添*\n# aside标签\n定义其所处内容之外的内容，应该与附近的内容相关。&lt;aside> 的内容可用作文章的侧栏。\n*html 5新添*\n# audio标签\n\t<audio src=\"someaudio.wav\">\n\t您的浏览器不支持 audio 标签。\n\t</audio>\n*Internet Explorer 8 以及更早的版本不支持 &lt;audio> 标签,html 5新添*\n## 属性\n1. autoplay\n2. controls\n3. loop\n4. muted 规定音频输出应该被静音\n5. preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用autoplay则忽略改属性。\n6. src \n\n# b标签\n加粗显示。\n\n根据 HTML5 规范，在没有其他合适标签更合适时，才应该把 &lt;b> 标签作为最后的选项。HTML5 规范声明：应该使用 &lt;h1> - &lt;h6> 来表示标题，使用 &lt;em> 标签来表示强调的文本，应该使用 &lt;strong> 标签来表示重要文本，应该使用 &lt;mark> 标签来表示标注的/突出显示的文本。\n\n# base标签\n## 必须属性\n   href\n## 可选属性\n  target\n\n# basefont\n规定页面上默认的字体和颜色。\n\n\t<basefont color=\"red\" size=\"5\" />\n*只有ie支持*。\n# bdi\nbdi 指的是 bidi 隔离。\n&lt;bdi> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。\n在发布用户评论或其他您无法完全控制的内容时，该标签很有用。\n## 属性\ndir 取值：ltr,rtl,auto\n*目前只有 Firefox 和 Chrome 支持 &lt;bdi> 标签。html5新添*\n# bdo\nbdo 元素可覆盖默认的文本方向。\n## 可选属性\ndir 取值：ltr,rtl\n","source":"_posts/html标签.md","raw":"---\ntitle: html标签学习\ndate: 2016-05-06 10:36:02\ntags: html标签\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n# a标签\n## 属性\n1. href\n2. target \n规定在何处打开新链接。\n3. media\n 属性规定目标URL是为什么媒介/设备优化的。可接受多个值。且只能在href属性存在时使用。\n   *html5 中的新属性*\n   <!--more-->\n4. download\n 规定被下载的超链接目标。只有firefox和Chrome支持。\n *html5新属性*。\n\t\t<a download=\"filename\"> \nfilename 为下载之后文件的名字。没有指定filename时只下载不重命名。\n5. type\n 规定被链接文档的MIMI类型。\n*html5新属性*\n6. hreflang\n 规定被链接文档的语言。仅在使用href属性时才使用。和 lang 属性不同的是，hreflang 属性不会指定标签中的内容所使用的语言，而是指定被 href 属性调用的文档所使用的语言。\n\\* 主流的浏览器几乎都不支持 hreflang 属性。\n7. rel\n 指定当前文档与被链接文档之间的关系。所有浏览器都支持。尽管浏览器不会以任何方式使用该属性，不过搜索引擎可以利用该属性获得更多有关链接的信息。\n8. rev\n 指定当前文档与被链接文档之间的关系。rel是指定从源文档到目标文档之间的关系，rev指定从目标文档到源文档之间的关系。\n*几乎没有浏览器支持，html 5废除*\n9. charset\n 规定被链接文档的字符集\n*主流的浏览器几乎都不支持 charset 属性。html 5废除*\n10. shape\n 规定链接的形状。只有 Firefox 和 Opera 支持 shape 属性。\n*html 5废除*\n11. coords\n coords 属性与 shape 属性配合，可以规定 object 或 img 元素中链接的尺寸、形状和位置。\n*只有 Firefox 和 Opera 支持 coords 属性。html 5废除*\n12. name\n 描述锚的名称。主流浏览器都支持。id出现之前用的name，后id出现为了保证兼容性而保留。\n*html 5废除*\n\n## 总结\n共12个属性，html 5新添属性有download，media，type三个。html 5 废除属性有charset,coords,name,rev,shape五个，剩下 href,target,rel,hreflang四个。其中hreflang主流浏览器都不支持。\n# abbr标签\n缩写，所有浏览器都支持。\n\n\t\tThe <abbr title=\"People's Republic of China\">PRC</abbr> was founded in 1949.\n# acronym标签\n首字母缩写。所有浏览器支持。html 5 废除，使用abbr代替。\n# address标签\n&lt;address>标签定义文档或文章的作者/拥有者的联系信息。\n如果 &lt;address> 元素位于 &lt;body> 元素内，则它表示文档联系信息。\n如果 &lt;address> 元素位于 &lt;article> 元素内，则它表示文章的联系信息。\n&lt;address> 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。\n*所有主流浏览器支持，html 5新添*\n# applet标签\n定义嵌入的java applet。\n*html 5废除，使用object代替。html 4.01中也不赞成使用*\n# area标签\n定义图像映射中的区域。area元素总是嵌套在map标签中。所有主流浏览器都支持。\n&lt;img> 标签中的 usemap 属性与 map 元素 name 属性相关联，创建图像与映射之间的联系。\n&lt;img> 中的 usemap 属性可引用 &lt;map> 中的 id 或 name 属性（由浏览器决定），所以我们需要同时向 &lt;map> 添加 id 和 name 两个属性。\n## 必需属性 \nalt，定义此区域的替换文本。\n## 可选属性\n 1. shape\n定义区域的形状。可选值：圆形（circ 或 circle）、多边形（poly 或 polygon）、矩形（rect 或 rectangle）和default。未规定shape时会假定使用default。意味着该区域会覆盖整个图像。可以识别 shape 属性的 default 值的浏览器，可以提供一个包括全部热点的区域，以用于在超过其他热点定义的范围之外单击的情况。由于区域在 <map> 标签中是采用“先来先得”的顺序，所有必须将默认区域放置在后面。否则，默认区域会覆盖其他的图像映射中出现的所有区域。\n所有浏览器都支持。\n 2. coords\n坐标值，定义可点击区域的坐标。与shape属性配合使用。\n圆形：shape=\"circle\"，coords=\"x,y,z\"\n这里的 x 和 y 定义了圆心的位置（\"0,0\" 是图像左上角的坐标），r 是以像素为单位的圆形半径。\n多边形：shape=\"polygon\"，coords=\"x1,y1,x2,y2,x3,y3,...\"\n每一对 \"x,y\" 坐标都定义了多边形的一个顶点（\"0,0\" 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。\n多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。\n矩形：shape=\"rectangle\"，coords=\"x1,y1,x2,y2\"\n第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，\"0,0\" 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。\n 3. href\nhref 属性规定区域中连接的目标。\n 4. nohref\nnohref 属性规定该区域没有相关的链接。\n 5. target\n\n# article标签\n规定独立的自包含内容。\n一篇文章应该具有其自身的意义。应该有可能独立于站点的其他部分对齐进行分发。\n&lt;article> 元素的潜在来源：\n 论坛帖子\n 报纸文章\n 博客条目\n 用户评论\n*html 5新添*\n# aside标签\n定义其所处内容之外的内容，应该与附近的内容相关。&lt;aside> 的内容可用作文章的侧栏。\n*html 5新添*\n# audio标签\n\t<audio src=\"someaudio.wav\">\n\t您的浏览器不支持 audio 标签。\n\t</audio>\n*Internet Explorer 8 以及更早的版本不支持 &lt;audio> 标签,html 5新添*\n## 属性\n1. autoplay\n2. controls\n3. loop\n4. muted 规定音频输出应该被静音\n5. preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用autoplay则忽略改属性。\n6. src \n\n# b标签\n加粗显示。\n\n根据 HTML5 规范，在没有其他合适标签更合适时，才应该把 &lt;b> 标签作为最后的选项。HTML5 规范声明：应该使用 &lt;h1> - &lt;h6> 来表示标题，使用 &lt;em> 标签来表示强调的文本，应该使用 &lt;strong> 标签来表示重要文本，应该使用 &lt;mark> 标签来表示标注的/突出显示的文本。\n\n# base标签\n## 必须属性\n   href\n## 可选属性\n  target\n\n# basefont\n规定页面上默认的字体和颜色。\n\n\t<basefont color=\"red\" size=\"5\" />\n*只有ie支持*。\n# bdi\nbdi 指的是 bidi 隔离。\n&lt;bdi> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。\n在发布用户评论或其他您无法完全控制的内容时，该标签很有用。\n## 属性\ndir 取值：ltr,rtl,auto\n*目前只有 Firefox 和 Chrome 支持 &lt;bdi> 标签。html5新添*\n# bdo\nbdo 元素可覆盖默认的文本方向。\n## 可选属性\ndir 取值：ltr,rtl\n","slug":"html标签","published":1,"updated":"2016-05-14T10:52:53.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmjy001v1kvsofb7sh9c","content":"<h1 id=\"a标签\"><a href=\"#a标签\" class=\"headerlink\" title=\"a标签\"></a>a标签</h1><h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li>href</li>\n<li>target<br>规定在何处打开新链接。</li>\n<li>media<br>属性规定目标URL是为什么媒介/设备优化的。可接受多个值。且只能在href属性存在时使用。<br><em>html5 中的新属性</em><a id=\"more\"></a></li>\n<li>download<br>规定被下载的超链接目标。只有firefox和Chrome支持。<br><em>html5新属性</em>。<pre><code>&lt;a download=&quot;filename&quot;&gt; \n</code></pre>filename 为下载之后文件的名字。没有指定filename时只下载不重命名。</li>\n<li>type<br>规定被链接文档的MIMI类型。<br><em>html5新属性</em></li>\n<li>hreflang<br>规定被链接文档的语言。仅在使用href属性时才使用。和 lang 属性不同的是，hreflang 属性不会指定标签中的内容所使用的语言，而是指定被 href 属性调用的文档所使用的语言。<br>* 主流的浏览器几乎都不支持 hreflang 属性。</li>\n<li>rel<br>指定当前文档与被链接文档之间的关系。所有浏览器都支持。尽管浏览器不会以任何方式使用该属性，不过搜索引擎可以利用该属性获得更多有关链接的信息。</li>\n<li>rev<br>指定当前文档与被链接文档之间的关系。rel是指定从源文档到目标文档之间的关系，rev指定从目标文档到源文档之间的关系。<br><em>几乎没有浏览器支持，html 5废除</em></li>\n<li>charset<br>规定被链接文档的字符集<br><em>主流的浏览器几乎都不支持 charset 属性。html 5废除</em></li>\n<li>shape<br>规定链接的形状。只有 Firefox 和 Opera 支持 shape 属性。<br><em>html 5废除</em></li>\n<li>coords<br>coords 属性与 shape 属性配合，可以规定 object 或 img 元素中链接的尺寸、形状和位置。<br><em>只有 Firefox 和 Opera 支持 coords 属性。html 5废除</em></li>\n<li>name<br>描述锚的名称。主流浏览器都支持。id出现之前用的name，后id出现为了保证兼容性而保留。<br><em>html 5废除</em></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>共12个属性，html 5新添属性有download，media，type三个。html 5 废除属性有charset,coords,name,rev,shape五个，剩下 href,target,rel,hreflang四个。其中hreflang主流浏览器都不支持。</p>\n<h1 id=\"abbr标签\"><a href=\"#abbr标签\" class=\"headerlink\" title=\"abbr标签\"></a>abbr标签</h1><p>缩写，所有浏览器都支持。</p>\n<pre><code>The &lt;abbr title=&quot;People&apos;s Republic of China&quot;&gt;PRC&lt;/abbr&gt; was founded in 1949.\n</code></pre><h1 id=\"acronym标签\"><a href=\"#acronym标签\" class=\"headerlink\" title=\"acronym标签\"></a>acronym标签</h1><p>首字母缩写。所有浏览器支持。html 5 废除，使用abbr代替。</p>\n<h1 id=\"address标签\"><a href=\"#address标签\" class=\"headerlink\" title=\"address标签\"></a>address标签</h1><p>&lt;address&gt;标签定义文档或文章的作者/拥有者的联系信息。<br>如果 &lt;address&gt; 元素位于 &lt;body&gt; 元素内，则它表示文档联系信息。<br>如果 &lt;address&gt; 元素位于 &lt;article&gt; 元素内，则它表示文章的联系信息。<br>&lt;address&gt; 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。<br><em>所有主流浏览器支持，html 5新添</em></p>\n<h1 id=\"applet标签\"><a href=\"#applet标签\" class=\"headerlink\" title=\"applet标签\"></a>applet标签</h1><p>定义嵌入的java applet。<br><em>html 5废除，使用object代替。html 4.01中也不赞成使用</em></p>\n<h1 id=\"area标签\"><a href=\"#area标签\" class=\"headerlink\" title=\"area标签\"></a>area标签</h1><p>定义图像映射中的区域。area元素总是嵌套在map标签中。所有主流浏览器都支持。<br>&lt;img&gt; 标签中的 usemap 属性与 map 元素 name 属性相关联，创建图像与映射之间的联系。<br>&lt;img&gt; 中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（由浏览器决定），所以我们需要同时向 &lt;map&gt; 添加 id 和 name 两个属性。</p>\n<h2 id=\"必需属性\"><a href=\"#必需属性\" class=\"headerlink\" title=\"必需属性\"></a>必需属性</h2><p>alt，定义此区域的替换文本。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><ol>\n<li>shape<br>定义区域的形状。可选值：圆形（circ 或 circle）、多边形（poly 或 polygon）、矩形（rect 或 rectangle）和default。未规定shape时会假定使用default。意味着该区域会覆盖整个图像。可以识别 shape 属性的 default 值的浏览器，可以提供一个包括全部热点的区域，以用于在超过其他热点定义的范围之外单击的情况。由于区域在 <map> 标签中是采用“先来先得”的顺序，所有必须将默认区域放置在后面。否则，默认区域会覆盖其他的图像映射中出现的所有区域。<br>所有浏览器都支持。</map></li>\n<li>coords<br>坐标值，定义可点击区域的坐标。与shape属性配合使用。<br>圆形：shape=”circle”，coords=”x,y,z”<br>这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），r 是以像素为单位的圆形半径。<br>多边形：shape=”polygon”，coords=”x1,y1,x2,y2,x3,y3,…”<br>每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。<br>多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。<br>矩形：shape=”rectangle”，coords=”x1,y1,x2,y2”<br>第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，”0,0” 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。</li>\n<li>href<br>href 属性规定区域中连接的目标。</li>\n<li>nohref<br>nohref 属性规定该区域没有相关的链接。</li>\n<li>target</li>\n</ol>\n<h1 id=\"article标签\"><a href=\"#article标签\" class=\"headerlink\" title=\"article标签\"></a>article标签</h1><p>规定独立的自包含内容。<br>一篇文章应该具有其自身的意义。应该有可能独立于站点的其他部分对齐进行分发。<br>&lt;article&gt; 元素的潜在来源：<br> 论坛帖子<br> 报纸文章<br> 博客条目<br> 用户评论<br><em>html 5新添</em></p>\n<h1 id=\"aside标签\"><a href=\"#aside标签\" class=\"headerlink\" title=\"aside标签\"></a>aside标签</h1><p>定义其所处内容之外的内容，应该与附近的内容相关。&lt;aside&gt; 的内容可用作文章的侧栏。<br><em>html 5新添</em></p>\n<h1 id=\"audio标签\"><a href=\"#audio标签\" class=\"headerlink\" title=\"audio标签\"></a>audio标签</h1><pre><code>&lt;audio src=&quot;someaudio.wav&quot;&gt;\n您的浏览器不支持 audio 标签。\n&lt;/audio&gt;\n</code></pre><p><em>Internet Explorer 8 以及更早的版本不支持 &lt;audio&gt; 标签,html 5新添</em></p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li>autoplay</li>\n<li>controls</li>\n<li>loop</li>\n<li>muted 规定音频输出应该被静音</li>\n<li>preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用autoplay则忽略改属性。</li>\n<li>src </li>\n</ol>\n<h1 id=\"b标签\"><a href=\"#b标签\" class=\"headerlink\" title=\"b标签\"></a>b标签</h1><p>加粗显示。</p>\n<p>根据 HTML5 规范，在没有其他合适标签更合适时，才应该把 &lt;b&gt; 标签作为最后的选项。HTML5 规范声明：应该使用 &lt;h1&gt; - &lt;h6&gt; 来表示标题，使用 &lt;em&gt; 标签来表示强调的文本，应该使用 &lt;strong&gt; 标签来表示重要文本，应该使用 &lt;mark&gt; 标签来表示标注的/突出显示的文本。</p>\n<h1 id=\"base标签\"><a href=\"#base标签\" class=\"headerlink\" title=\"base标签\"></a>base标签</h1><h2 id=\"必须属性\"><a href=\"#必须属性\" class=\"headerlink\" title=\"必须属性\"></a>必须属性</h2><p>   href</p>\n<h2 id=\"可选属性-1\"><a href=\"#可选属性-1\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>  target</p>\n<h1 id=\"basefont\"><a href=\"#basefont\" class=\"headerlink\" title=\"basefont\"></a>basefont</h1><p>规定页面上默认的字体和颜色。</p>\n<pre><code>&lt;basefont color=&quot;red&quot; size=&quot;5&quot; /&gt;\n</code></pre><p><em>只有ie支持</em>。</p>\n<h1 id=\"bdi\"><a href=\"#bdi\" class=\"headerlink\" title=\"bdi\"></a>bdi</h1><p>bdi 指的是 bidi 隔离。<br>&lt;bdi&gt; 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。<br>在发布用户评论或其他您无法完全控制的内容时，该标签很有用。</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>dir 取值：ltr,rtl,auto<br><em>目前只有 Firefox 和 Chrome 支持 &lt;bdi&gt; 标签。html5新添</em></p>\n<h1 id=\"bdo\"><a href=\"#bdo\" class=\"headerlink\" title=\"bdo\"></a>bdo</h1><p>bdo 元素可覆盖默认的文本方向。</p>\n<h2 id=\"可选属性-2\"><a href=\"#可选属性-2\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>dir 取值：ltr,rtl</p>\n","excerpt":"<h1 id=\"a标签\"><a href=\"#a标签\" class=\"headerlink\" title=\"a标签\"></a>a标签</h1><h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li>href</li>\n<li>target<br>规定在何处打开新链接。</li>\n<li>media<br>属性规定目标URL是为什么媒介/设备优化的。可接受多个值。且只能在href属性存在时使用。<br><em>html5 中的新属性</em>","more":"</li>\n<li>download<br>规定被下载的超链接目标。只有firefox和Chrome支持。<br><em>html5新属性</em>。<pre><code>&lt;a download=&quot;filename&quot;&gt; \n</code></pre>filename 为下载之后文件的名字。没有指定filename时只下载不重命名。</li>\n<li>type<br>规定被链接文档的MIMI类型。<br><em>html5新属性</em></li>\n<li>hreflang<br>规定被链接文档的语言。仅在使用href属性时才使用。和 lang 属性不同的是，hreflang 属性不会指定标签中的内容所使用的语言，而是指定被 href 属性调用的文档所使用的语言。<br>* 主流的浏览器几乎都不支持 hreflang 属性。</li>\n<li>rel<br>指定当前文档与被链接文档之间的关系。所有浏览器都支持。尽管浏览器不会以任何方式使用该属性，不过搜索引擎可以利用该属性获得更多有关链接的信息。</li>\n<li>rev<br>指定当前文档与被链接文档之间的关系。rel是指定从源文档到目标文档之间的关系，rev指定从目标文档到源文档之间的关系。<br><em>几乎没有浏览器支持，html 5废除</em></li>\n<li>charset<br>规定被链接文档的字符集<br><em>主流的浏览器几乎都不支持 charset 属性。html 5废除</em></li>\n<li>shape<br>规定链接的形状。只有 Firefox 和 Opera 支持 shape 属性。<br><em>html 5废除</em></li>\n<li>coords<br>coords 属性与 shape 属性配合，可以规定 object 或 img 元素中链接的尺寸、形状和位置。<br><em>只有 Firefox 和 Opera 支持 coords 属性。html 5废除</em></li>\n<li>name<br>描述锚的名称。主流浏览器都支持。id出现之前用的name，后id出现为了保证兼容性而保留。<br><em>html 5废除</em></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>共12个属性，html 5新添属性有download，media，type三个。html 5 废除属性有charset,coords,name,rev,shape五个，剩下 href,target,rel,hreflang四个。其中hreflang主流浏览器都不支持。</p>\n<h1 id=\"abbr标签\"><a href=\"#abbr标签\" class=\"headerlink\" title=\"abbr标签\"></a>abbr标签</h1><p>缩写，所有浏览器都支持。</p>\n<pre><code>The &lt;abbr title=&quot;People&apos;s Republic of China&quot;&gt;PRC&lt;/abbr&gt; was founded in 1949.\n</code></pre><h1 id=\"acronym标签\"><a href=\"#acronym标签\" class=\"headerlink\" title=\"acronym标签\"></a>acronym标签</h1><p>首字母缩写。所有浏览器支持。html 5 废除，使用abbr代替。</p>\n<h1 id=\"address标签\"><a href=\"#address标签\" class=\"headerlink\" title=\"address标签\"></a>address标签</h1><p>&lt;address&gt;标签定义文档或文章的作者/拥有者的联系信息。<br>如果 &lt;address&gt; 元素位于 &lt;body&gt; 元素内，则它表示文档联系信息。<br>如果 &lt;address&gt; 元素位于 &lt;article&gt; 元素内，则它表示文章的联系信息。<br>&lt;address&gt; 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。<br><em>所有主流浏览器支持，html 5新添</em></p>\n<h1 id=\"applet标签\"><a href=\"#applet标签\" class=\"headerlink\" title=\"applet标签\"></a>applet标签</h1><p>定义嵌入的java applet。<br><em>html 5废除，使用object代替。html 4.01中也不赞成使用</em></p>\n<h1 id=\"area标签\"><a href=\"#area标签\" class=\"headerlink\" title=\"area标签\"></a>area标签</h1><p>定义图像映射中的区域。area元素总是嵌套在map标签中。所有主流浏览器都支持。<br>&lt;img&gt; 标签中的 usemap 属性与 map 元素 name 属性相关联，创建图像与映射之间的联系。<br>&lt;img&gt; 中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（由浏览器决定），所以我们需要同时向 &lt;map&gt; 添加 id 和 name 两个属性。</p>\n<h2 id=\"必需属性\"><a href=\"#必需属性\" class=\"headerlink\" title=\"必需属性\"></a>必需属性</h2><p>alt，定义此区域的替换文本。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><ol>\n<li>shape<br>定义区域的形状。可选值：圆形（circ 或 circle）、多边形（poly 或 polygon）、矩形（rect 或 rectangle）和default。未规定shape时会假定使用default。意味着该区域会覆盖整个图像。可以识别 shape 属性的 default 值的浏览器，可以提供一个包括全部热点的区域，以用于在超过其他热点定义的范围之外单击的情况。由于区域在 <map> 标签中是采用“先来先得”的顺序，所有必须将默认区域放置在后面。否则，默认区域会覆盖其他的图像映射中出现的所有区域。<br>所有浏览器都支持。</li>\n<li>coords<br>坐标值，定义可点击区域的坐标。与shape属性配合使用。<br>圆形：shape=”circle”，coords=”x,y,z”<br>这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），r 是以像素为单位的圆形半径。<br>多边形：shape=”polygon”，coords=”x1,y1,x2,y2,x3,y3,…”<br>每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。<br>多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。<br>矩形：shape=”rectangle”，coords=”x1,y1,x2,y2”<br>第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，”0,0” 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。</li>\n<li>href<br>href 属性规定区域中连接的目标。</li>\n<li>nohref<br>nohref 属性规定该区域没有相关的链接。</li>\n<li>target</li>\n</ol>\n<h1 id=\"article标签\"><a href=\"#article标签\" class=\"headerlink\" title=\"article标签\"></a>article标签</h1><p>规定独立的自包含内容。<br>一篇文章应该具有其自身的意义。应该有可能独立于站点的其他部分对齐进行分发。<br>&lt;article&gt; 元素的潜在来源：<br> 论坛帖子<br> 报纸文章<br> 博客条目<br> 用户评论<br><em>html 5新添</em></p>\n<h1 id=\"aside标签\"><a href=\"#aside标签\" class=\"headerlink\" title=\"aside标签\"></a>aside标签</h1><p>定义其所处内容之外的内容，应该与附近的内容相关。&lt;aside&gt; 的内容可用作文章的侧栏。<br><em>html 5新添</em></p>\n<h1 id=\"audio标签\"><a href=\"#audio标签\" class=\"headerlink\" title=\"audio标签\"></a>audio标签</h1><pre><code>&lt;audio src=&quot;someaudio.wav&quot;&gt;\n您的浏览器不支持 audio 标签。\n&lt;/audio&gt;\n</code></pre><p><em>Internet Explorer 8 以及更早的版本不支持 &lt;audio&gt; 标签,html 5新添</em></p>\n<h2 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ol>\n<li>autoplay</li>\n<li>controls</li>\n<li>loop</li>\n<li>muted 规定音频输出应该被静音</li>\n<li>preload 如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用autoplay则忽略改属性。</li>\n<li>src </li>\n</ol>\n<h1 id=\"b标签\"><a href=\"#b标签\" class=\"headerlink\" title=\"b标签\"></a>b标签</h1><p>加粗显示。</p>\n<p>根据 HTML5 规范，在没有其他合适标签更合适时，才应该把 &lt;b&gt; 标签作为最后的选项。HTML5 规范声明：应该使用 &lt;h1&gt; - &lt;h6&gt; 来表示标题，使用 &lt;em&gt; 标签来表示强调的文本，应该使用 &lt;strong&gt; 标签来表示重要文本，应该使用 &lt;mark&gt; 标签来表示标注的/突出显示的文本。</p>\n<h1 id=\"base标签\"><a href=\"#base标签\" class=\"headerlink\" title=\"base标签\"></a>base标签</h1><h2 id=\"必须属性\"><a href=\"#必须属性\" class=\"headerlink\" title=\"必须属性\"></a>必须属性</h2><p>   href</p>\n<h2 id=\"可选属性-1\"><a href=\"#可选属性-1\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>  target</p>\n<h1 id=\"basefont\"><a href=\"#basefont\" class=\"headerlink\" title=\"basefont\"></a>basefont</h1><p>规定页面上默认的字体和颜色。</p>\n<pre><code>&lt;basefont color=&quot;red&quot; size=&quot;5&quot; /&gt;\n</code></pre><p><em>只有ie支持</em>。</p>\n<h1 id=\"bdi\"><a href=\"#bdi\" class=\"headerlink\" title=\"bdi\"></a>bdi</h1><p>bdi 指的是 bidi 隔离。<br>&lt;bdi&gt; 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。<br>在发布用户评论或其他您无法完全控制的内容时，该标签很有用。</p>\n<h2 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>dir 取值：ltr,rtl,auto<br><em>目前只有 Firefox 和 Chrome 支持 &lt;bdi&gt; 标签。html5新添</em></p>\n<h1 id=\"bdo\"><a href=\"#bdo\" class=\"headerlink\" title=\"bdo\"></a>bdo</h1><p>bdo 元素可覆盖默认的文本方向。</p>\n<h2 id=\"可选属性-2\"><a href=\"#可选属性-2\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>dir 取值：ltr,rtl</p>"},{"title":"javascript创建对象及继承","date":"2016-07-29T03:02:46.000Z","_content":"本文介绍JavaScript面向对象编程中的创建对象和继承的实现，主要来自《JavaScript高级程序设计》。\n<!-- more -->\n\n# 对象的创建\n\n1. 工厂模式\n\n\t\tfunction Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\t\tvar person = Person(\"lily\",15);\n\n 缺点：无法识别对象的类型\n\n2. 构造函数模式\n\n\t\tfunction Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tthis.getName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t}\n\t\tvar person = new Person(\"lily\",15);\n\n\t注意：如何不通过new调用，则this指向window\n\n\t缺点：每个方法需要在每个实例上都重新创建一遍。若将方法移出，则当方法多时，需要定义多个全局函数，破坏封装性。\n\n3. 原型模式\n\n\t\tfunction Person(){}\n\t\tPerson.prototype.name = \"lily\";\n\t\tPerson.prototype.age = 15;\n\t\tPerson.prototype.getName =  function(){\n\t\t\treturn this.name;\n\t\t};\n\t\tvar person = new Person；\n\n\t缺点：（1）所有实例的默认属性值相同\n\t  （2）当属性中有引用类型时，也会共享。\n\n4. 组合构造函数模式\n\n\t   function Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPerson.prototype.getName =  function(){\n\t\t\tconsole.log(this.name);\n\t\t};\n\t\tvar person = new Person(\"lily\",15);\n\n5. 动态原型模式\n\n\t\tfunction Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tif(typeof this.getName!= \"function\"){\n\t\t\t\tPerson.prototype.getName = function(){\n\t\t\t\t\tconsole.log(this.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tvar person = new Person(\"lily\",15);\n\n6. 寄生构造函数模式\n\n\t   function Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\n\t\tvar person = new Person(\"lily\",15);\n\n\t缺点：无法判断对象类型\n\n7. 稳妥构造函数模式\n\n\t\tfunction Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\t\tconsole.log(name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\n\t\tvar person = Person(\"lily\",15);\n\n\t与寄生构造函数模式的区别：（1）不引用this（2）创建对象不使用new\n\t缺点：无法判断类型\n\n# 实现继承的方式\n\n1. 原型链\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tthis.subProperty = false;\n\t\t}\n\t\tSubType.prototype = new SuperType();\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\n\t缺点：（1）引用类型的属性：在通过原型继承时，原型实际上会变成另一个类型的实例，故原来实例中的属性会变成新的对象的原型中的属性。\n\t  （2）在创建子类型时，无法向超类型的构造函数中传递参数。\n\n2. 借用构造函数\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t\tthis.getSuperValue = function(){\n\t\t\t\treturn this.property;\n\t\t\t}\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\n3. 组合继承\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\t\tSubType.prototype = new SuperType();\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\n4. 原型式继承（相当于ES5中的Object.create()）\n\n\t    function object(o){\n\t    \tfunction F(){};\n\t    \tF.prototype = o;\n\t    \treturn new F();\n\t    }\n\n5. 寄生式继承(增强对象)\n\n\t\tfunction CreateAnother(o){\n\t\t\tvar another = object(o);\n\t\t\tanother.sayName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn another;\n\t\t}\n\n6. 寄生组合式继承\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\t\tinheritPrototype(subType,superType);\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\t\tfunction inheritPrototype(subType,superType){\n\t\t\tvar prototype = object(superType.prototype);\n\t\t\tprototype.constructor = subType;\n\t\t\tSubType.prototype = prototype;\n\n\t\t}","source":"_posts/javascript创建对象及继承.md","raw":"---\ntitle: javascript创建对象及继承\ndate: 2016-07-29 11:02:46\ntags: \n  - javascript\ncategories:\n  - 学习笔记\n  - javascript\n---\n本文介绍JavaScript面向对象编程中的创建对象和继承的实现，主要来自《JavaScript高级程序设计》。\n<!-- more -->\n\n# 对象的创建\n\n1. 工厂模式\n\n\t\tfunction Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\t\tvar person = Person(\"lily\",15);\n\n 缺点：无法识别对象的类型\n\n2. 构造函数模式\n\n\t\tfunction Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tthis.getName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t}\n\t\tvar person = new Person(\"lily\",15);\n\n\t注意：如何不通过new调用，则this指向window\n\n\t缺点：每个方法需要在每个实例上都重新创建一遍。若将方法移出，则当方法多时，需要定义多个全局函数，破坏封装性。\n\n3. 原型模式\n\n\t\tfunction Person(){}\n\t\tPerson.prototype.name = \"lily\";\n\t\tPerson.prototype.age = 15;\n\t\tPerson.prototype.getName =  function(){\n\t\t\treturn this.name;\n\t\t};\n\t\tvar person = new Person；\n\n\t缺点：（1）所有实例的默认属性值相同\n\t  （2）当属性中有引用类型时，也会共享。\n\n4. 组合构造函数模式\n\n\t   function Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t}\n\t\tPerson.prototype.getName =  function(){\n\t\t\tconsole.log(this.name);\n\t\t};\n\t\tvar person = new Person(\"lily\",15);\n\n5. 动态原型模式\n\n\t\tfunction Person(name,age){\n\t\t\tthis.name = name;\n\t\t\tthis.age = age;\n\t\t\tif(typeof this.getName!= \"function\"){\n\t\t\t\tPerson.prototype.getName = function(){\n\t\t\t\t\tconsole.log(this.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tvar person = new Person(\"lily\",15);\n\n6. 寄生构造函数模式\n\n\t   function Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\n\t\tvar person = new Person(\"lily\",15);\n\n\t缺点：无法判断对象类型\n\n7. 稳妥构造函数模式\n\n\t\tfunction Person(name,age){\n\t\t\tvar o = new Object();\n\t\t\to.name = name;\n\t\t\to.age = age;\n\t\t\to.getName = function(){\n\t\t\t\tconsole.log(name);\n\t\t\t}\n\t\t\treturn o;\n\t\t}\n\n\t\tvar person = Person(\"lily\",15);\n\n\t与寄生构造函数模式的区别：（1）不引用this（2）创建对象不使用new\n\t缺点：无法判断类型\n\n# 实现继承的方式\n\n1. 原型链\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tthis.subProperty = false;\n\t\t}\n\t\tSubType.prototype = new SuperType();\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\n\t缺点：（1）引用类型的属性：在通过原型继承时，原型实际上会变成另一个类型的实例，故原来实例中的属性会变成新的对象的原型中的属性。\n\t  （2）在创建子类型时，无法向超类型的构造函数中传递参数。\n\n2. 借用构造函数\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t\tthis.getSuperValue = function(){\n\t\t\t\treturn this.property;\n\t\t\t}\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\n3. 组合继承\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\t\tSubType.prototype = new SuperType();\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\n4. 原型式继承（相当于ES5中的Object.create()）\n\n\t    function object(o){\n\t    \tfunction F(){};\n\t    \tF.prototype = o;\n\t    \treturn new F();\n\t    }\n\n5. 寄生式继承(增强对象)\n\n\t\tfunction CreateAnother(o){\n\t\t\tvar another = object(o);\n\t\t\tanother.sayName = function(){\n\t\t\t\tconsole.log(this.name);\n\t\t\t}\n\t\t\treturn another;\n\t\t}\n\n6. 寄生组合式继承\n\n\t\tfunction SuperType(){\n\t\t\tthis.property = true;\n\t\t}\n\t\tSuperType.prototype.getSuperValue = function(){\n\t\t\treturn this.property;\n\t\t}\n\n\t\tfunction SubType(){\n\t\t\tSuperType.call(this);\n\t\t}\n\t\tinheritPrototype(subType,superType);\n\t\tSubType.prototype.getSubValue = function(){\n\t\t\treturn this.subProperty;\n\t\t}\n\t\tfunction inheritPrototype(subType,superType){\n\t\t\tvar prototype = object(superType.prototype);\n\t\t\tprototype.constructor = subType;\n\t\t\tSubType.prototype = prototype;\n\n\t\t}","slug":"javascript创建对象及继承","published":1,"updated":"2016-09-03T14:28:35.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmjy001z1kvsrk2ytl24","content":"<p>本文介绍JavaScript面向对象编程中的创建对象和继承的实现，主要来自《JavaScript高级程序设计》。<br><a id=\"more\"></a></p>\n<h1 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h1><ol>\n<li><p>工厂模式</p>\n<pre><code>function Person(name,age){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.getName = function(){\n    console.log(this.name);\n    }\n    return o;\n}\nvar person = Person(&quot;lily&quot;,15);\n</code></pre><p>缺点：无法识别对象的类型</p>\n</li>\n<li><p>构造函数模式</p>\n<pre><code>function Person(name,age){\n    this.name = name;\n    this.age = age;\n    this.getName = function(){\n        console.log(this.name);\n    }\n}\nvar person = new Person(&quot;lily&quot;,15);\n</code></pre><p> 注意：如何不通过new调用，则this指向window</p>\n<p> 缺点：每个方法需要在每个实例上都重新创建一遍。若将方法移出，则当方法多时，需要定义多个全局函数，破坏封装性。</p>\n</li>\n<li><p>原型模式</p>\n<pre><code>function Person(){}\nPerson.prototype.name = &quot;lily&quot;;\nPerson.prototype.age = 15;\nPerson.prototype.getName =  function(){\n    return this.name;\n};\nvar person = new Person；\n</code></pre><p> 缺点：（1）所有实例的默认属性值相同<br>   （2）当属性中有引用类型时，也会共享。</p>\n</li>\n<li><p>组合构造函数模式</p>\n<pre><code>function Person(name,age){\n     this.name = name;\n     this.age = age;\n }\n Person.prototype.getName =  function(){\n     console.log(this.name);\n };\n var person = new Person(&quot;lily&quot;,15);\n</code></pre></li>\n<li><p>动态原型模式</p>\n<pre><code>function Person(name,age){\n    this.name = name;\n    this.age = age;\n    if(typeof this.getName!= &quot;function&quot;){\n        Person.prototype.getName = function(){\n            console.log(this.name);\n        }\n    }\n}\n</code></pre><p> var person = new Person(“lily”,15);</p>\n</li>\n<li><p>寄生构造函数模式</p>\n<pre><code>function Person(name,age){\n     var o = new Object();\n     o.name = name;\n     o.age = age;\n     o.getName = function(){\n         console.log(this.name);\n     }\n     return o;\n }\n\n var person = new Person(&quot;lily&quot;,15);\n</code></pre><p> 缺点：无法判断对象类型</p>\n</li>\n<li><p>稳妥构造函数模式</p>\n<pre><code>function Person(name,age){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.getName = function(){\n        console.log(name);\n    }\n    return o;\n}\n\nvar person = Person(&quot;lily&quot;,15);\n</code></pre><p> 与寄生构造函数模式的区别：（1）不引用this（2）创建对象不使用new<br> 缺点：无法判断类型</p>\n</li>\n</ol>\n<h1 id=\"实现继承的方式\"><a href=\"#实现继承的方式\" class=\"headerlink\" title=\"实现继承的方式\"></a>实现继承的方式</h1><ol>\n<li><p>原型链</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    this.subProperty = false;\n}\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\n</code></pre><p> 缺点：（1）引用类型的属性：在通过原型继承时，原型实际上会变成另一个类型的实例，故原来实例中的属性会变成新的对象的原型中的属性。<br>   （2）在创建子类型时，无法向超类型的构造函数中传递参数。</p>\n</li>\n<li><p>借用构造函数</p>\n<pre><code>function SuperType(){\n    this.property = true;\n    this.getSuperValue = function(){\n        return this.property;\n    }\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\n</code></pre></li>\n<li><p>组合继承</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\n</code></pre></li>\n<li><p>原型式继承（相当于ES5中的Object.create()）</p>\n<pre><code>function object(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n</code></pre></li>\n<li><p>寄生式继承(增强对象)</p>\n<pre><code>function CreateAnother(o){\n    var another = object(o);\n    another.sayName = function(){\n        console.log(this.name);\n    }\n    return another;\n}\n</code></pre></li>\n<li><p>寄生组合式继承</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\ninheritPrototype(subType,superType);\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\nfunction inheritPrototype(subType,superType){\n    var prototype = object(superType.prototype);\n    prototype.constructor = subType;\n    SubType.prototype = prototype;\n\n}\n</code></pre></li>\n</ol>\n","excerpt":"<p>本文介绍JavaScript面向对象编程中的创建对象和继承的实现，主要来自《JavaScript高级程序设计》。<br>","more":"</p>\n<h1 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h1><ol>\n<li><p>工厂模式</p>\n<pre><code>function Person(name,age){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.getName = function(){\n    console.log(this.name);\n    }\n    return o;\n}\nvar person = Person(&quot;lily&quot;,15);\n</code></pre><p>缺点：无法识别对象的类型</p>\n</li>\n<li><p>构造函数模式</p>\n<pre><code>function Person(name,age){\n    this.name = name;\n    this.age = age;\n    this.getName = function(){\n        console.log(this.name);\n    }\n}\nvar person = new Person(&quot;lily&quot;,15);\n</code></pre><p> 注意：如何不通过new调用，则this指向window</p>\n<p> 缺点：每个方法需要在每个实例上都重新创建一遍。若将方法移出，则当方法多时，需要定义多个全局函数，破坏封装性。</p>\n</li>\n<li><p>原型模式</p>\n<pre><code>function Person(){}\nPerson.prototype.name = &quot;lily&quot;;\nPerson.prototype.age = 15;\nPerson.prototype.getName =  function(){\n    return this.name;\n};\nvar person = new Person；\n</code></pre><p> 缺点：（1）所有实例的默认属性值相同<br>   （2）当属性中有引用类型时，也会共享。</p>\n</li>\n<li><p>组合构造函数模式</p>\n<pre><code>function Person(name,age){\n     this.name = name;\n     this.age = age;\n }\n Person.prototype.getName =  function(){\n     console.log(this.name);\n };\n var person = new Person(&quot;lily&quot;,15);\n</code></pre></li>\n<li><p>动态原型模式</p>\n<pre><code>function Person(name,age){\n    this.name = name;\n    this.age = age;\n    if(typeof this.getName!= &quot;function&quot;){\n        Person.prototype.getName = function(){\n            console.log(this.name);\n        }\n    }\n}\n</code></pre><p> var person = new Person(“lily”,15);</p>\n</li>\n<li><p>寄生构造函数模式</p>\n<pre><code>function Person(name,age){\n     var o = new Object();\n     o.name = name;\n     o.age = age;\n     o.getName = function(){\n         console.log(this.name);\n     }\n     return o;\n }\n\n var person = new Person(&quot;lily&quot;,15);\n</code></pre><p> 缺点：无法判断对象类型</p>\n</li>\n<li><p>稳妥构造函数模式</p>\n<pre><code>function Person(name,age){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.getName = function(){\n        console.log(name);\n    }\n    return o;\n}\n\nvar person = Person(&quot;lily&quot;,15);\n</code></pre><p> 与寄生构造函数模式的区别：（1）不引用this（2）创建对象不使用new<br> 缺点：无法判断类型</p>\n</li>\n</ol>\n<h1 id=\"实现继承的方式\"><a href=\"#实现继承的方式\" class=\"headerlink\" title=\"实现继承的方式\"></a>实现继承的方式</h1><ol>\n<li><p>原型链</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    this.subProperty = false;\n}\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\n</code></pre><p> 缺点：（1）引用类型的属性：在通过原型继承时，原型实际上会变成另一个类型的实例，故原来实例中的属性会变成新的对象的原型中的属性。<br>   （2）在创建子类型时，无法向超类型的构造函数中传递参数。</p>\n</li>\n<li><p>借用构造函数</p>\n<pre><code>function SuperType(){\n    this.property = true;\n    this.getSuperValue = function(){\n        return this.property;\n    }\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\n</code></pre></li>\n<li><p>组合继承</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\n</code></pre></li>\n<li><p>原型式继承（相当于ES5中的Object.create()）</p>\n<pre><code>function object(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n</code></pre></li>\n<li><p>寄生式继承(增强对象)</p>\n<pre><code>function CreateAnother(o){\n    var another = object(o);\n    another.sayName = function(){\n        console.log(this.name);\n    }\n    return another;\n}\n</code></pre></li>\n<li><p>寄生组合式继承</p>\n<pre><code>function SuperType(){\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    SuperType.call(this);\n}\ninheritPrototype(subType,superType);\nSubType.prototype.getSubValue = function(){\n    return this.subProperty;\n}\nfunction inheritPrototype(subType,superType){\n    var prototype = object(superType.prototype);\n    prototype.constructor = subType;\n    SubType.prototype = prototype;\n\n}\n</code></pre></li>\n</ol>"},{"title":"mergeSort","date":"2016-05-27T06:11:55.000Z","_content":"归并排序算法总结（稳定，时间复杂度n*logn）\n\n\tpublic void mergeSort(int[] arr, int left, int right) {\n\t\t\tif(left<right){\n\t\t\t\tint center = (right+left)/2;\n\t\t\t\tmergeSort(arr,left,center);\n\t\t\t\tmergeSort(arr,center+1,right);\n\t\t\t\tmerge(arr,left,right,center);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t/**\n\t\t * 将两个数组进行排序，排序前两个数组有序，排序后依然有序\n\t\t * @param arr 要排序的数组\n\t\t * @param left 左数组第一个元素的索引\n\t\t * @param right 右数组最后一个元素的索引\n\t\t * @param center 左数组最后一个元素的索引，center+1是右数组第一个元素的索引\n\t\t */\n\t\tpublic void merge(int[] arr,int left,int right,int center){\n\t//\t\t与待排序数组等长的临时数组\n\t\t\tint[] temp = new int[arr.length];\n\t//\t\t右侧数组的索引\n\t\t\tint mid = center+1;\n\t//\t\tthird 中间数组的索引\n\t\t\tint third = left;\n\t//\t\t记录左侧数组的第一个元素的索引，用于将临时数组的元素复制到原数组时\n\t\t\tint tmp = left;\n\t\t\twhile(left <= center && mid <= right){\n\t//\t\t\t从两个数组中取出小的放入中间数组\n\t\t\t\tif(arr[left]<=arr[mid]){\n\t\t\t\t\ttemp[third++]=arr[left++];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[third++]=arr[mid++];\n\t\t\t\t}\n\t\t\t}\n\t//\t\t剩余部分依次加入到中间数组\n\t\t\twhile(mid<=right){\n\t\t\t\ttemp[third++]= arr[mid++];\n\t\t\t}\n\t\t\twhile(left<=center){\n\t\t\t\ttemp[third++]= arr[left++];\n\t\t\t}\n\t//\t\t将中间数组的内容复制回原数组\n\t\t\twhile(tmp<=right){\n\t\t\t\tarr[tmp] = temp[tmp++];\n\t\t\t}\n\t\t}","source":"_posts/mergeSort.md","raw":"---\ntitle: mergeSort\ndate: 2016-05-27 14:11:55\ntags: \n  - 排序算法\ncategories:\n  - 学习笔记\n  - 数据结构\n---\n归并排序算法总结（稳定，时间复杂度n*logn）\n\n\tpublic void mergeSort(int[] arr, int left, int right) {\n\t\t\tif(left<right){\n\t\t\t\tint center = (right+left)/2;\n\t\t\t\tmergeSort(arr,left,center);\n\t\t\t\tmergeSort(arr,center+1,right);\n\t\t\t\tmerge(arr,left,right,center);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t/**\n\t\t * 将两个数组进行排序，排序前两个数组有序，排序后依然有序\n\t\t * @param arr 要排序的数组\n\t\t * @param left 左数组第一个元素的索引\n\t\t * @param right 右数组最后一个元素的索引\n\t\t * @param center 左数组最后一个元素的索引，center+1是右数组第一个元素的索引\n\t\t */\n\t\tpublic void merge(int[] arr,int left,int right,int center){\n\t//\t\t与待排序数组等长的临时数组\n\t\t\tint[] temp = new int[arr.length];\n\t//\t\t右侧数组的索引\n\t\t\tint mid = center+1;\n\t//\t\tthird 中间数组的索引\n\t\t\tint third = left;\n\t//\t\t记录左侧数组的第一个元素的索引，用于将临时数组的元素复制到原数组时\n\t\t\tint tmp = left;\n\t\t\twhile(left <= center && mid <= right){\n\t//\t\t\t从两个数组中取出小的放入中间数组\n\t\t\t\tif(arr[left]<=arr[mid]){\n\t\t\t\t\ttemp[third++]=arr[left++];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[third++]=arr[mid++];\n\t\t\t\t}\n\t\t\t}\n\t//\t\t剩余部分依次加入到中间数组\n\t\t\twhile(mid<=right){\n\t\t\t\ttemp[third++]= arr[mid++];\n\t\t\t}\n\t\t\twhile(left<=center){\n\t\t\t\ttemp[third++]= arr[left++];\n\t\t\t}\n\t//\t\t将中间数组的内容复制回原数组\n\t\t\twhile(tmp<=right){\n\t\t\t\tarr[tmp] = temp[tmp++];\n\t\t\t}\n\t\t}","slug":"mergeSort","published":1,"updated":"2016-06-14T12:33:58.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmke00221kvsnds21kt0","content":"<p>归并排序算法总结（稳定，时间复杂度n*logn）</p>\n<pre><code>public void mergeSort(int[] arr, int left, int right) {\n        if(left&lt;right){\n            int center = (right+left)/2;\n            mergeSort(arr,left,center);\n            mergeSort(arr,center+1,right);\n            merge(arr,left,right,center);\n        }\n\n    }\n    /**\n     * 将两个数组进行排序，排序前两个数组有序，排序后依然有序\n     * @param arr 要排序的数组\n     * @param left 左数组第一个元素的索引\n     * @param right 右数组最后一个元素的索引\n     * @param center 左数组最后一个元素的索引，center+1是右数组第一个元素的索引\n     */\n    public void merge(int[] arr,int left,int right,int center){\n//        与待排序数组等长的临时数组\n        int[] temp = new int[arr.length];\n//        右侧数组的索引\n        int mid = center+1;\n//        third 中间数组的索引\n        int third = left;\n//        记录左侧数组的第一个元素的索引，用于将临时数组的元素复制到原数组时\n        int tmp = left;\n        while(left &lt;= center &amp;&amp; mid &lt;= right){\n//            从两个数组中取出小的放入中间数组\n            if(arr[left]&lt;=arr[mid]){\n                temp[third++]=arr[left++];\n            }else{\n                temp[third++]=arr[mid++];\n            }\n        }\n//        剩余部分依次加入到中间数组\n        while(mid&lt;=right){\n            temp[third++]= arr[mid++];\n        }\n        while(left&lt;=center){\n            temp[third++]= arr[left++];\n        }\n//        将中间数组的内容复制回原数组\n        while(tmp&lt;=right){\n            arr[tmp] = temp[tmp++];\n        }\n    }\n</code></pre>","excerpt":"","more":"<p>归并排序算法总结（稳定，时间复杂度n*logn）</p>\n<pre><code>public void mergeSort(int[] arr, int left, int right) {\n        if(left&lt;right){\n            int center = (right+left)/2;\n            mergeSort(arr,left,center);\n            mergeSort(arr,center+1,right);\n            merge(arr,left,right,center);\n        }\n\n    }\n    /**\n     * 将两个数组进行排序，排序前两个数组有序，排序后依然有序\n     * @param arr 要排序的数组\n     * @param left 左数组第一个元素的索引\n     * @param right 右数组最后一个元素的索引\n     * @param center 左数组最后一个元素的索引，center+1是右数组第一个元素的索引\n     */\n    public void merge(int[] arr,int left,int right,int center){\n//        与待排序数组等长的临时数组\n        int[] temp = new int[arr.length];\n//        右侧数组的索引\n        int mid = center+1;\n//        third 中间数组的索引\n        int third = left;\n//        记录左侧数组的第一个元素的索引，用于将临时数组的元素复制到原数组时\n        int tmp = left;\n        while(left &lt;= center &amp;&amp; mid &lt;= right){\n//            从两个数组中取出小的放入中间数组\n            if(arr[left]&lt;=arr[mid]){\n                temp[third++]=arr[left++];\n            }else{\n                temp[third++]=arr[mid++];\n            }\n        }\n//        剩余部分依次加入到中间数组\n        while(mid&lt;=right){\n            temp[third++]= arr[mid++];\n        }\n        while(left&lt;=center){\n            temp[third++]= arr[left++];\n        }\n//        将中间数组的内容复制回原数组\n        while(tmp&lt;=right){\n            arr[tmp] = temp[tmp++];\n        }\n    }\n</code></pre>"},{"title":"padding and margin学习笔记","date":"2016-09-28T13:46:01.000Z","_content":"# padding学习笔记\n\n1. 对于block水平元素：\n\n当padding-left+padding-right>width时，容器的宽度变为padding-left+padding-right，\n容器中的内容按最小尺寸显示（width为200px的盒子，padding为200px时，盒子的宽度变为400px）\n\n2. 对于inline水平元素（width和height不能设置）\n\n水平padding影响尺寸，垂直padding不影响尺寸,但是会影响背景色（占据空间）\n\n## padding应用\n  1. 高度可控的分割线\n    1.1 直接使用字符\n    1.2 inline-block控制\n    1.3 使用inline padding\n\n    \t注册&lt;span>&lt;span>登录\n\n    \tspan{\n    \tpadding：16px 6px 1px;\n    \tmargin-left:12px;\n    \tborder-left:2px solid;\n    \tfont-size:0;\n    \t}","source":"_posts/padding-margin.md","raw":"---\ntitle: padding and margin学习笔记\ndate: 2016-09-28 21:46:01\ntags: \n  - padding\n  - margin\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n# padding学习笔记\n\n1. 对于block水平元素：\n\n当padding-left+padding-right>width时，容器的宽度变为padding-left+padding-right，\n容器中的内容按最小尺寸显示（width为200px的盒子，padding为200px时，盒子的宽度变为400px）\n\n2. 对于inline水平元素（width和height不能设置）\n\n水平padding影响尺寸，垂直padding不影响尺寸,但是会影响背景色（占据空间）\n\n## padding应用\n  1. 高度可控的分割线\n    1.1 直接使用字符\n    1.2 inline-block控制\n    1.3 使用inline padding\n\n    \t注册&lt;span>&lt;span>登录\n\n    \tspan{\n    \tpadding：16px 6px 1px;\n    \tmargin-left:12px;\n    \tborder-left:2px solid;\n    \tfont-size:0;\n    \t}","slug":"padding-margin","published":1,"updated":"2016-09-28T14:35:13.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmke00241kvsz2jwr427","content":"<h1 id=\"padding学习笔记\"><a href=\"#padding学习笔记\" class=\"headerlink\" title=\"padding学习笔记\"></a>padding学习笔记</h1><ol>\n<li>对于block水平元素：</li>\n</ol>\n<p>当padding-left+padding-right&gt;width时，容器的宽度变为padding-left+padding-right，<br>容器中的内容按最小尺寸显示（width为200px的盒子，padding为200px时，盒子的宽度变为400px）</p>\n<ol>\n<li>对于inline水平元素（width和height不能设置）</li>\n</ol>\n<p>水平padding影响尺寸，垂直padding不影响尺寸,但是会影响背景色（占据空间）</p>\n<h2 id=\"padding应用\"><a href=\"#padding应用\" class=\"headerlink\" title=\"padding应用\"></a>padding应用</h2><ol>\n<li><p>高度可控的分割线<br>1.1 直接使用字符<br>1.2 inline-block控制<br>1.3 使用inline padding</p>\n<p>   注册&lt;span&gt;&lt;span&gt;登录</p>\n<p>   span{<br>   padding：16px 6px 1px;<br>   margin-left:12px;<br>   border-left:2px solid;<br>   font-size:0;<br>   }</p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"padding学习笔记\"><a href=\"#padding学习笔记\" class=\"headerlink\" title=\"padding学习笔记\"></a>padding学习笔记</h1><ol>\n<li>对于block水平元素：</li>\n</ol>\n<p>当padding-left+padding-right&gt;width时，容器的宽度变为padding-left+padding-right，<br>容器中的内容按最小尺寸显示（width为200px的盒子，padding为200px时，盒子的宽度变为400px）</p>\n<ol>\n<li>对于inline水平元素（width和height不能设置）</li>\n</ol>\n<p>水平padding影响尺寸，垂直padding不影响尺寸,但是会影响背景色（占据空间）</p>\n<h2 id=\"padding应用\"><a href=\"#padding应用\" class=\"headerlink\" title=\"padding应用\"></a>padding应用</h2><ol>\n<li><p>高度可控的分割线<br>1.1 直接使用字符<br>1.2 inline-block控制<br>1.3 使用inline padding</p>\n<p>   注册&lt;span&gt;&lt;span&gt;登录</p>\n<p>   span{<br>   padding：16px 6px 1px;<br>   margin-left:12px;<br>   border-left:2px solid;<br>   font-size:0;<br>   }</p>\n</li>\n</ol>\n"},{"title":"npm笔记(修改npm镜像站)","date":"2016-07-26T07:42:24.000Z","_content":"方法一 命令行输入npm config edit可以调出.npmrc文件（npm userconfig file）。通过修改里面的register可以修改npm镜像站点。\n<!-- more -->\n\n方法二 使用nrm（NPM registry manager） \nnrm \nNPM registry manager can help you easy and fast switch between different npm registries, now include: cnpm, taobao, nj(nodejitsu), rednpm, edunpm\n\n\nInstall\n\n$ npm install -g nrm\n\nExample\n\t$ nrm ls\n\t \n\t* npm -----  https://registry.npmjs.org/\n\t  cnpm ----  http://r.cnpmjs.org/\n\t  taobao --  https://registry.npm.taobao.org/\n\t  nj ------  https://registry.nodejitsu.com/\n\t  rednpm -- http://registry.mirror.cqupt.edu.cn\n\t  skimdb -- https://skimdb.npmjs.com/registry\n\t \n\t$ nrm use cnpm  //switch registry to cnpm\n\t \n\t    Registry has been set to: http://r.cnpmjs.org/\n \nUsage\nUsage: nrm [options] [command]\n \n  Commands:\n \n    ls                           List all the registries\n    use <registry>               Change registry to registry\n    add <registry> <url> [home]  Add one custom registry\n    del <registry>               Delete one custom registry\n    home <registry> [browser]    Open the homepage of registry with optional browser\n    test [registry]              Show the response time for one or all registries\n    help                         Print this help\n \n  Options:\n \n    -h, --help     output usage information\n    -V, --version  output the version number","source":"_posts/npm.md","raw":"---\ntitle: npm笔记(修改npm镜像站)\ndate: 2016-07-26 15:42:24\ntags:\n---\n方法一 命令行输入npm config edit可以调出.npmrc文件（npm userconfig file）。通过修改里面的register可以修改npm镜像站点。\n<!-- more -->\n\n方法二 使用nrm（NPM registry manager） \nnrm \nNPM registry manager can help you easy and fast switch between different npm registries, now include: cnpm, taobao, nj(nodejitsu), rednpm, edunpm\n\n\nInstall\n\n$ npm install -g nrm\n\nExample\n\t$ nrm ls\n\t \n\t* npm -----  https://registry.npmjs.org/\n\t  cnpm ----  http://r.cnpmjs.org/\n\t  taobao --  https://registry.npm.taobao.org/\n\t  nj ------  https://registry.nodejitsu.com/\n\t  rednpm -- http://registry.mirror.cqupt.edu.cn\n\t  skimdb -- https://skimdb.npmjs.com/registry\n\t \n\t$ nrm use cnpm  //switch registry to cnpm\n\t \n\t    Registry has been set to: http://r.cnpmjs.org/\n \nUsage\nUsage: nrm [options] [command]\n \n  Commands:\n \n    ls                           List all the registries\n    use <registry>               Change registry to registry\n    add <registry> <url> [home]  Add one custom registry\n    del <registry>               Delete one custom registry\n    home <registry> [browser]    Open the homepage of registry with optional browser\n    test [registry]              Show the response time for one or all registries\n    help                         Print this help\n \n  Options:\n \n    -h, --help     output usage information\n    -V, --version  output the version number","slug":"npm","published":1,"updated":"2016-07-27T13:03:38.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmke00271kvsfagdzly3","content":"<p>方法一 命令行输入npm config edit可以调出.npmrc文件（npm userconfig file）。通过修改里面的register可以修改npm镜像站点。<br><a id=\"more\"></a></p>\n<p>方法二 使用nrm（NPM registry manager）<br>nrm<br>NPM registry manager can help you easy and fast switch between different npm registries, now include: cnpm, taobao, nj(nodejitsu), rednpm, edunpm</p>\n<p>Install</p>\n<p>$ npm install -g nrm</p>\n<p>Example<br>    $ nrm ls</p>\n<pre><code>* npm -----  https://registry.npmjs.org/\n  cnpm ----  http://r.cnpmjs.org/\n  taobao --  https://registry.npm.taobao.org/\n  nj ------  https://registry.nodejitsu.com/\n  rednpm -- http://registry.mirror.cqupt.edu.cn\n  skimdb -- https://skimdb.npmjs.com/registry\n\n$ nrm use cnpm  //switch registry to cnpm\n\n    Registry has been set to: http://r.cnpmjs.org/\n</code></pre><p>Usage<br>Usage: nrm [options] [command]</p>\n<p>  Commands:</p>\n<pre><code>ls                           List all the registries\nuse &lt;registry&gt;               Change registry to registry\nadd &lt;registry&gt; &lt;url&gt; [home]  Add one custom registry\ndel &lt;registry&gt;               Delete one custom registry\nhome &lt;registry&gt; [browser]    Open the homepage of registry with optional browser\ntest [registry]              Show the response time for one or all registries\nhelp                         Print this help\n</code></pre><p>  Options:</p>\n<pre><code>-h, --help     output usage information\n-V, --version  output the version number\n</code></pre>","excerpt":"<p>方法一 命令行输入npm config edit可以调出.npmrc文件（npm userconfig file）。通过修改里面的register可以修改npm镜像站点。<br>","more":"</p>\n<p>方法二 使用nrm（NPM registry manager）<br>nrm<br>NPM registry manager can help you easy and fast switch between different npm registries, now include: cnpm, taobao, nj(nodejitsu), rednpm, edunpm</p>\n<p>Install</p>\n<p>$ npm install -g nrm</p>\n<p>Example<br>    $ nrm ls</p>\n<pre><code>* npm -----  https://registry.npmjs.org/\n  cnpm ----  http://r.cnpmjs.org/\n  taobao --  https://registry.npm.taobao.org/\n  nj ------  https://registry.nodejitsu.com/\n  rednpm -- http://registry.mirror.cqupt.edu.cn\n  skimdb -- https://skimdb.npmjs.com/registry\n\n$ nrm use cnpm  //switch registry to cnpm\n\n    Registry has been set to: http://r.cnpmjs.org/\n</code></pre><p>Usage<br>Usage: nrm [options] [command]</p>\n<p>  Commands:</p>\n<pre><code>ls                           List all the registries\nuse &lt;registry&gt;               Change registry to registry\nadd &lt;registry&gt; &lt;url&gt; [home]  Add one custom registry\ndel &lt;registry&gt;               Delete one custom registry\nhome &lt;registry&gt; [browser]    Open the homepage of registry with optional browser\ntest [registry]              Show the response time for one or all registries\nhelp                         Print this help\n</code></pre><p>  Options:</p>\n<pre><code>-h, --help     output usage information\n-V, --version  output the version number\n</code></pre>"},{"title":"property与attribute","date":"2016-07-19T07:13:22.000Z","_content":"本文对html中的property和attribute进行区分：\n\n1. DOM对象的是属性（property），HTML标签的是特性（Attribute）\n\n2. 每一个HTML标签(tag)都对应一个DOM接口HTMLXxxElement,比如Span标签对应的是HTMLSpanElement。这些标签的DOM接口都继承自HTMLElement接口，而HTMLElement又继承自Element。我们知道所有的标签都是一个元素结点,因此Element接口又继承自Node接口。其实HTML文档树中的所有东西都是结点,只不过有不同的结点类型而已。\n<!-- more -->\n3. HTML标签的attribute以类数组的形式存储在对应DOM对象的属性attributes中,attributes属性的类型为NamedNodeMap对象。\nDOM对象提供了方法setAttribute，getAttribute和removeAttribute来操纵HTML标签的特性，包括自定义的特性。如下面的代码：\n\n\tvar id1=elem.id;\n\tvar id2=elem.getAttribute('id');\n获取元素的id可以通过上面的两种方式，第一行代码中的方式是通过获取DOM的属性（property）获取的，而第二行代码中getAttribute获取的是HTML标签的特性（attribute）\n\n*这一点很重要，可以看出，特性，只是DOM中的一个属性而已，而这个属性本身是一个类数组对象-NamedNodeMap对象。*\n\n4. HTML标签attribute的名字和值都必须为字符串类型，而DOM对象的property没有此限制，可以是任何类型。\n\n5. 有些HTML标签的attribute有对应的DOM对象property,但它们的取值却不一定是相同的。一般来说相对应的attribute与property其名字是一样的，但是class特性有所不同，因为class在javascript中为关键字，所以其所对应的property名字为className。\n\n6. 对于input的value,使用getAttribute获取的永远是写HTML标签时指定的那个值,而value属性则获取到的是input当前输入的值。\n\n7. 另一些特性比如checked,只要checked特性存在，无论其值是什么，DOM对象的checked属性的值都是true。这里checked属性已经不是字符串而是布尔类型了。\n\n8. 还有一些特性比如style和onclick,其对应的DOM属性完全是返回一个对象了,比如elem.style属性就返回一个CSSStyleDeclaration对象。\n\n9. HTML自定义attribute没有对应的DOM对象property。\n\n\n\n参考文章：\nDOM对象属性(property)与HTML标签特性(attribute)：http://openwares.net/linux/dom_property_element_attribute.html \nattribute和property的区别：http://stylechen.com/attribute-property.html\nSD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现：\nhttp://www.w3help.org/zh-cn/causes/SD9006\nDOM元素的特性（Attribute）和属性（Property）：http://www.cnblogs.com/wangfupeng1988/p/3631853.html\n\n\n","source":"_posts/property与attribute.md","raw":"---\ntitle: property与attribute\ndate: 2016-07-19 15:13:22\ntags: \n  - JavaScript\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n本文对html中的property和attribute进行区分：\n\n1. DOM对象的是属性（property），HTML标签的是特性（Attribute）\n\n2. 每一个HTML标签(tag)都对应一个DOM接口HTMLXxxElement,比如Span标签对应的是HTMLSpanElement。这些标签的DOM接口都继承自HTMLElement接口，而HTMLElement又继承自Element。我们知道所有的标签都是一个元素结点,因此Element接口又继承自Node接口。其实HTML文档树中的所有东西都是结点,只不过有不同的结点类型而已。\n<!-- more -->\n3. HTML标签的attribute以类数组的形式存储在对应DOM对象的属性attributes中,attributes属性的类型为NamedNodeMap对象。\nDOM对象提供了方法setAttribute，getAttribute和removeAttribute来操纵HTML标签的特性，包括自定义的特性。如下面的代码：\n\n\tvar id1=elem.id;\n\tvar id2=elem.getAttribute('id');\n获取元素的id可以通过上面的两种方式，第一行代码中的方式是通过获取DOM的属性（property）获取的，而第二行代码中getAttribute获取的是HTML标签的特性（attribute）\n\n*这一点很重要，可以看出，特性，只是DOM中的一个属性而已，而这个属性本身是一个类数组对象-NamedNodeMap对象。*\n\n4. HTML标签attribute的名字和值都必须为字符串类型，而DOM对象的property没有此限制，可以是任何类型。\n\n5. 有些HTML标签的attribute有对应的DOM对象property,但它们的取值却不一定是相同的。一般来说相对应的attribute与property其名字是一样的，但是class特性有所不同，因为class在javascript中为关键字，所以其所对应的property名字为className。\n\n6. 对于input的value,使用getAttribute获取的永远是写HTML标签时指定的那个值,而value属性则获取到的是input当前输入的值。\n\n7. 另一些特性比如checked,只要checked特性存在，无论其值是什么，DOM对象的checked属性的值都是true。这里checked属性已经不是字符串而是布尔类型了。\n\n8. 还有一些特性比如style和onclick,其对应的DOM属性完全是返回一个对象了,比如elem.style属性就返回一个CSSStyleDeclaration对象。\n\n9. HTML自定义attribute没有对应的DOM对象property。\n\n\n\n参考文章：\nDOM对象属性(property)与HTML标签特性(attribute)：http://openwares.net/linux/dom_property_element_attribute.html \nattribute和property的区别：http://stylechen.com/attribute-property.html\nSD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现：\nhttp://www.w3help.org/zh-cn/causes/SD9006\nDOM元素的特性（Attribute）和属性（Property）：http://www.cnblogs.com/wangfupeng1988/p/3631853.html\n\n\n","slug":"property与attribute","published":1,"updated":"2016-07-20T12:35:07.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmkt002b1kvso500jldo","content":"<p>本文对html中的property和attribute进行区分：</p>\n<ol>\n<li><p>DOM对象的是属性（property），HTML标签的是特性（Attribute）</p>\n</li>\n<li><p>每一个HTML标签(tag)都对应一个DOM接口HTMLXxxElement,比如Span标签对应的是HTMLSpanElement。这些标签的DOM接口都继承自HTMLElement接口，而HTMLElement又继承自Element。我们知道所有的标签都是一个元素结点,因此Element接口又继承自Node接口。其实HTML文档树中的所有东西都是结点,只不过有不同的结点类型而已。</p>\n<a id=\"more\"></a></li>\n<li><p>HTML标签的attribute以类数组的形式存储在对应DOM对象的属性attributes中,attributes属性的类型为NamedNodeMap对象。<br>DOM对象提供了方法setAttribute，getAttribute和removeAttribute来操纵HTML标签的特性，包括自定义的特性。如下面的代码：</p>\n<p> var id1=elem.id;<br> var id2=elem.getAttribute(‘id’);<br>获取元素的id可以通过上面的两种方式，第一行代码中的方式是通过获取DOM的属性（property）获取的，而第二行代码中getAttribute获取的是HTML标签的特性（attribute）</p>\n</li>\n</ol>\n<p><em>这一点很重要，可以看出，特性，只是DOM中的一个属性而已，而这个属性本身是一个类数组对象-NamedNodeMap对象。</em></p>\n<ol>\n<li><p>HTML标签attribute的名字和值都必须为字符串类型，而DOM对象的property没有此限制，可以是任何类型。</p>\n</li>\n<li><p>有些HTML标签的attribute有对应的DOM对象property,但它们的取值却不一定是相同的。一般来说相对应的attribute与property其名字是一样的，但是class特性有所不同，因为class在javascript中为关键字，所以其所对应的property名字为className。</p>\n</li>\n<li><p>对于input的value,使用getAttribute获取的永远是写HTML标签时指定的那个值,而value属性则获取到的是input当前输入的值。</p>\n</li>\n<li><p>另一些特性比如checked,只要checked特性存在，无论其值是什么，DOM对象的checked属性的值都是true。这里checked属性已经不是字符串而是布尔类型了。</p>\n</li>\n<li><p>还有一些特性比如style和onclick,其对应的DOM属性完全是返回一个对象了,比如elem.style属性就返回一个CSSStyleDeclaration对象。</p>\n</li>\n<li><p>HTML自定义attribute没有对应的DOM对象property。</p>\n</li>\n</ol>\n<p>参考文章：<br>DOM对象属性(property)与HTML标签特性(attribute)：<a href=\"http://openwares.net/linux/dom_property_element_attribute.html\" target=\"_blank\" rel=\"external\">http://openwares.net/linux/dom_property_element_attribute.html</a><br>attribute和property的区别：<a href=\"http://stylechen.com/attribute-property.html\" target=\"_blank\" rel=\"external\">http://stylechen.com/attribute-property.html</a><br>SD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现：<br><a href=\"http://www.w3help.org/zh-cn/causes/SD9006\" target=\"_blank\" rel=\"external\">http://www.w3help.org/zh-cn/causes/SD9006</a><br>DOM元素的特性（Attribute）和属性（Property）：<a href=\"http://www.cnblogs.com/wangfupeng1988/p/3631853.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/wangfupeng1988/p/3631853.html</a></p>\n","excerpt":"<p>本文对html中的property和attribute进行区分：</p>\n<ol>\n<li><p>DOM对象的是属性（property），HTML标签的是特性（Attribute）</p>\n</li>\n<li><p>每一个HTML标签(tag)都对应一个DOM接口HTMLXxxElement,比如Span标签对应的是HTMLSpanElement。这些标签的DOM接口都继承自HTMLElement接口，而HTMLElement又继承自Element。我们知道所有的标签都是一个元素结点,因此Element接口又继承自Node接口。其实HTML文档树中的所有东西都是结点,只不过有不同的结点类型而已。</p>","more":"</li>\n<li><p>HTML标签的attribute以类数组的形式存储在对应DOM对象的属性attributes中,attributes属性的类型为NamedNodeMap对象。<br>DOM对象提供了方法setAttribute，getAttribute和removeAttribute来操纵HTML标签的特性，包括自定义的特性。如下面的代码：</p>\n<p> var id1=elem.id;<br> var id2=elem.getAttribute(‘id’);<br>获取元素的id可以通过上面的两种方式，第一行代码中的方式是通过获取DOM的属性（property）获取的，而第二行代码中getAttribute获取的是HTML标签的特性（attribute）</p>\n</li>\n</ol>\n<p><em>这一点很重要，可以看出，特性，只是DOM中的一个属性而已，而这个属性本身是一个类数组对象-NamedNodeMap对象。</em></p>\n<ol>\n<li><p>HTML标签attribute的名字和值都必须为字符串类型，而DOM对象的property没有此限制，可以是任何类型。</p>\n</li>\n<li><p>有些HTML标签的attribute有对应的DOM对象property,但它们的取值却不一定是相同的。一般来说相对应的attribute与property其名字是一样的，但是class特性有所不同，因为class在javascript中为关键字，所以其所对应的property名字为className。</p>\n</li>\n<li><p>对于input的value,使用getAttribute获取的永远是写HTML标签时指定的那个值,而value属性则获取到的是input当前输入的值。</p>\n</li>\n<li><p>另一些特性比如checked,只要checked特性存在，无论其值是什么，DOM对象的checked属性的值都是true。这里checked属性已经不是字符串而是布尔类型了。</p>\n</li>\n<li><p>还有一些特性比如style和onclick,其对应的DOM属性完全是返回一个对象了,比如elem.style属性就返回一个CSSStyleDeclaration对象。</p>\n</li>\n<li><p>HTML自定义attribute没有对应的DOM对象property。</p>\n</li>\n</ol>\n<p>参考文章：<br>DOM对象属性(property)与HTML标签特性(attribute)：<a href=\"http://openwares.net/linux/dom_property_element_attribute.html\">http://openwares.net/linux/dom_property_element_attribute.html</a><br>attribute和property的区别：<a href=\"http://stylechen.com/attribute-property.html\">http://stylechen.com/attribute-property.html</a><br>SD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现：<br><a href=\"http://www.w3help.org/zh-cn/causes/SD9006\">http://www.w3help.org/zh-cn/causes/SD9006</a><br>DOM元素的特性（Attribute）和属性（Property）：<a href=\"http://www.cnblogs.com/wangfupeng1988/p/3631853.html\">http://www.cnblogs.com/wangfupeng1988/p/3631853.html</a></p>"},{"title":"history pushState 实现浏览器前进与后退","date":"2016-03-29T08:24:21.000Z","_content":"今天做了个界面需要用到ajax进行页面跳转，当然使用ajax进行页面跳转有它的优点，比如降低服务器压力，缩短用户等待时间等，但是一个很明显的缺点就是浏览器的前进和后退按钮失效了，好在HTML5的history对象的出现比较好的解决了这个问题，所以去网上找一些pushState使用的文章，但是大多数都是只讲原理没有实现的实例，理解起来还是不太容易的。现在将我理解的一些内容说一下，不对的地方欢迎大家指出。\n<!-- more -->\n首先讲一下API：\n首先是方法有两个history.pushState()和history.replaceState()\n事件有一个window.onpopstate\npushState（）方法，接收三个参数\na state object, a title (which is currentlyignored), and (optionally) a URL\n\n其中，state对象保存的是被pushState页面的信息的一个拷贝，也就是说以后你要用到的信息，都可以放到这个对象中。\nurl是可选的，负责改变浏览器的地址栏中显示的url，如果没有指定url，你点击前进后退按钮页面还是会变化，只是浏览器的地址栏上显示的url会一直保持不变。\nreplaceState（）方法，与pushState方法相同，主要用于改变当前历史记录中记录的当前页面的state对象和url信息。\nonpopstate事件,每次点击浏览器的前进和后退按钮，就会触发window的Onpopstate事件。\n最后使用history.state获取当前所在页面的state对象，也就是在上面pushState中保存的。\n\n下面以一个例子具体说明。\n\n首先，我们一般做一个网站，刚进去的首页是没有pathname的，为了让浏览器能够后退到首页，我们对首页的url进行拦截，即改变首页的url。这里面history.replaceState只是改变网页的url地址，不会改变网页内容。这里面的state保存的是你要在将来获取到的任何信息。\n\n\tvar url = “blog/index.html”;\n\n\tvar state = {\n\t    url:url\n\n\t}\n\thistory.replaceState(state,””,\"blog/index.html\");\n\n接下来,当调用ajax使页面内容发送变化之后，我们将这个变化的页面状态保存起来，如\n\n\tvar url = “blog/index.html”;\n\n\tvar state = {\n\n\t      url:url\n\n\t}\n\n\twindow.history.pushState(state,\"\",url);\n\n最后，给window添加监听，当popstate被触发之后，我们通过history.state获取到达页面的信息，通过.操作符获取该页面的信息，如我这里保存了该页面的url，就通过history.state.url获取，然后通过这个url加载页面。\n\n\twindow.addEventListener(\"popstate\",function() {\n\tvar currentUrl = history.state.url;\n\t\t$(\".container\").load(currentUrl +\" #container\");\n\t});\n\n","source":"_posts/pushstate.md","raw":"---\ntitle: history pushState 实现浏览器前进与后退\ndate: 2016-03-29 16:24:21\ntags: \n  - html5\n  - pushState\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n今天做了个界面需要用到ajax进行页面跳转，当然使用ajax进行页面跳转有它的优点，比如降低服务器压力，缩短用户等待时间等，但是一个很明显的缺点就是浏览器的前进和后退按钮失效了，好在HTML5的history对象的出现比较好的解决了这个问题，所以去网上找一些pushState使用的文章，但是大多数都是只讲原理没有实现的实例，理解起来还是不太容易的。现在将我理解的一些内容说一下，不对的地方欢迎大家指出。\n<!-- more -->\n首先讲一下API：\n首先是方法有两个history.pushState()和history.replaceState()\n事件有一个window.onpopstate\npushState（）方法，接收三个参数\na state object, a title (which is currentlyignored), and (optionally) a URL\n\n其中，state对象保存的是被pushState页面的信息的一个拷贝，也就是说以后你要用到的信息，都可以放到这个对象中。\nurl是可选的，负责改变浏览器的地址栏中显示的url，如果没有指定url，你点击前进后退按钮页面还是会变化，只是浏览器的地址栏上显示的url会一直保持不变。\nreplaceState（）方法，与pushState方法相同，主要用于改变当前历史记录中记录的当前页面的state对象和url信息。\nonpopstate事件,每次点击浏览器的前进和后退按钮，就会触发window的Onpopstate事件。\n最后使用history.state获取当前所在页面的state对象，也就是在上面pushState中保存的。\n\n下面以一个例子具体说明。\n\n首先，我们一般做一个网站，刚进去的首页是没有pathname的，为了让浏览器能够后退到首页，我们对首页的url进行拦截，即改变首页的url。这里面history.replaceState只是改变网页的url地址，不会改变网页内容。这里面的state保存的是你要在将来获取到的任何信息。\n\n\tvar url = “blog/index.html”;\n\n\tvar state = {\n\t    url:url\n\n\t}\n\thistory.replaceState(state,””,\"blog/index.html\");\n\n接下来,当调用ajax使页面内容发送变化之后，我们将这个变化的页面状态保存起来，如\n\n\tvar url = “blog/index.html”;\n\n\tvar state = {\n\n\t      url:url\n\n\t}\n\n\twindow.history.pushState(state,\"\",url);\n\n最后，给window添加监听，当popstate被触发之后，我们通过history.state获取到达页面的信息，通过.操作符获取该页面的信息，如我这里保存了该页面的url，就通过history.state.url获取，然后通过这个url加载页面。\n\n\twindow.addEventListener(\"popstate\",function() {\n\tvar currentUrl = history.state.url;\n\t\t$(\".container\").load(currentUrl +\" #container\");\n\t});\n\n","slug":"pushstate","published":1,"updated":"2016-05-24T13:20:55.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmkt002f1kvswdzwng9t","content":"<p>今天做了个界面需要用到ajax进行页面跳转，当然使用ajax进行页面跳转有它的优点，比如降低服务器压力，缩短用户等待时间等，但是一个很明显的缺点就是浏览器的前进和后退按钮失效了，好在HTML5的history对象的出现比较好的解决了这个问题，所以去网上找一些pushState使用的文章，但是大多数都是只讲原理没有实现的实例，理解起来还是不太容易的。现在将我理解的一些内容说一下，不对的地方欢迎大家指出。<br><a id=\"more\"></a><br>首先讲一下API：<br>首先是方法有两个history.pushState()和history.replaceState()<br>事件有一个window.onpopstate<br>pushState（）方法，接收三个参数<br>a state object, a title (which is currentlyignored), and (optionally) a URL</p>\n<p>其中，state对象保存的是被pushState页面的信息的一个拷贝，也就是说以后你要用到的信息，都可以放到这个对象中。<br>url是可选的，负责改变浏览器的地址栏中显示的url，如果没有指定url，你点击前进后退按钮页面还是会变化，只是浏览器的地址栏上显示的url会一直保持不变。<br>replaceState（）方法，与pushState方法相同，主要用于改变当前历史记录中记录的当前页面的state对象和url信息。<br>onpopstate事件,每次点击浏览器的前进和后退按钮，就会触发window的Onpopstate事件。<br>最后使用history.state获取当前所在页面的state对象，也就是在上面pushState中保存的。</p>\n<p>下面以一个例子具体说明。</p>\n<p>首先，我们一般做一个网站，刚进去的首页是没有pathname的，为了让浏览器能够后退到首页，我们对首页的url进行拦截，即改变首页的url。这里面history.replaceState只是改变网页的url地址，不会改变网页内容。这里面的state保存的是你要在将来获取到的任何信息。</p>\n<pre><code>var url = “blog/index.html”;\n\nvar state = {\n    url:url\n\n}\nhistory.replaceState(state,””,&quot;blog/index.html&quot;);\n</code></pre><p>接下来,当调用ajax使页面内容发送变化之后，我们将这个变化的页面状态保存起来，如</p>\n<pre><code>var url = “blog/index.html”;\n\nvar state = {\n\n      url:url\n\n}\n\nwindow.history.pushState(state,&quot;&quot;,url);\n</code></pre><p>最后，给window添加监听，当popstate被触发之后，我们通过history.state获取到达页面的信息，通过.操作符获取该页面的信息，如我这里保存了该页面的url，就通过history.state.url获取，然后通过这个url加载页面。</p>\n<pre><code>window.addEventListener(&quot;popstate&quot;,function() {\nvar currentUrl = history.state.url;\n    $(&quot;.container&quot;).load(currentUrl +&quot; #container&quot;);\n});\n</code></pre>","excerpt":"<p>今天做了个界面需要用到ajax进行页面跳转，当然使用ajax进行页面跳转有它的优点，比如降低服务器压力，缩短用户等待时间等，但是一个很明显的缺点就是浏览器的前进和后退按钮失效了，好在HTML5的history对象的出现比较好的解决了这个问题，所以去网上找一些pushState使用的文章，但是大多数都是只讲原理没有实现的实例，理解起来还是不太容易的。现在将我理解的一些内容说一下，不对的地方欢迎大家指出。<br>","more":"<br>首先讲一下API：<br>首先是方法有两个history.pushState()和history.replaceState()<br>事件有一个window.onpopstate<br>pushState（）方法，接收三个参数<br>a state object, a title (which is currentlyignored), and (optionally) a URL</p>\n<p>其中，state对象保存的是被pushState页面的信息的一个拷贝，也就是说以后你要用到的信息，都可以放到这个对象中。<br>url是可选的，负责改变浏览器的地址栏中显示的url，如果没有指定url，你点击前进后退按钮页面还是会变化，只是浏览器的地址栏上显示的url会一直保持不变。<br>replaceState（）方法，与pushState方法相同，主要用于改变当前历史记录中记录的当前页面的state对象和url信息。<br>onpopstate事件,每次点击浏览器的前进和后退按钮，就会触发window的Onpopstate事件。<br>最后使用history.state获取当前所在页面的state对象，也就是在上面pushState中保存的。</p>\n<p>下面以一个例子具体说明。</p>\n<p>首先，我们一般做一个网站，刚进去的首页是没有pathname的，为了让浏览器能够后退到首页，我们对首页的url进行拦截，即改变首页的url。这里面history.replaceState只是改变网页的url地址，不会改变网页内容。这里面的state保存的是你要在将来获取到的任何信息。</p>\n<pre><code>var url = “blog/index.html”;\n\nvar state = {\n    url:url\n\n}\nhistory.replaceState(state,””,&quot;blog/index.html&quot;);\n</code></pre><p>接下来,当调用ajax使页面内容发送变化之后，我们将这个变化的页面状态保存起来，如</p>\n<pre><code>var url = “blog/index.html”;\n\nvar state = {\n\n      url:url\n\n}\n\nwindow.history.pushState(state,&quot;&quot;,url);\n</code></pre><p>最后，给window添加监听，当popstate被触发之后，我们通过history.state获取到达页面的信息，通过.操作符获取该页面的信息，如我这里保存了该页面的url，就通过history.state.url获取，然后通过这个url加载页面。</p>\n<pre><code>window.addEventListener(&quot;popstate&quot;,function() {\nvar currentUrl = history.state.url;\n    $(&quot;.container&quot;).load(currentUrl +&quot; #container&quot;);\n});\n</code></pre>"},{"title":"java中的Queue与Deque","date":"2016-06-18T15:46:10.000Z","_content":"\njava中的栈为Stack，Stack是一个类，队列为Queue，但是与栈的实现不同的是，Queue是一个接口，而不是实现类。Queue接口定义的方法有：\n<!-- more -->\n\n\t boolean add(E e);//向队列中添加一个元素，成功返回true\n\t boolean offer(E e);//向队列中添加一个元素，成功返回true\n\t E remove();\n\t E poll();\n\t E element();\n\t E peek();\n\nDeque为双端队列，也是一个接口，继承自Queue。以Deque接口的一个实现类ArrayDeque为例，说一下add方法与offer方法的区别。\n先看一下add方法的实现\n\n\tpublic boolean add(E e) {\n\t        addLast(e);\n\t        return true;\n\t    }\n\t public void addLast(E e) {\n\t        if (e == null)\n\t            throw new NullPointerException();\n\t        elements[tail] = e;\n\t        if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n\t            doubleCapacity();\n\t    }\n再看一下offer方法的实现\n\n\tpublic boolean offer(E e) {\n\t        return offerLast(e);\n\t    }\n\tpublic boolean offerLast(E e) {\n\t        addLast(e);\n\t        return true;\n\t    }\n\tpublic void addLast(E e) {\n\t        if (e == null)\n\t            throw new NullPointerException();\n\t        elements[tail] = e;\n\t        if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n\t            doubleCapacity();\n\t    }\n\t    ","source":"_posts/queue.md","raw":"---\ntitle: java中的Queue与Deque\ntags:\n  - java\n  - stack\n  - add and push\ncategories:\n  - 学习笔记\n  - java\ndate: 2016-06-18 23:46:10\n---\n\njava中的栈为Stack，Stack是一个类，队列为Queue，但是与栈的实现不同的是，Queue是一个接口，而不是实现类。Queue接口定义的方法有：\n<!-- more -->\n\n\t boolean add(E e);//向队列中添加一个元素，成功返回true\n\t boolean offer(E e);//向队列中添加一个元素，成功返回true\n\t E remove();\n\t E poll();\n\t E element();\n\t E peek();\n\nDeque为双端队列，也是一个接口，继承自Queue。以Deque接口的一个实现类ArrayDeque为例，说一下add方法与offer方法的区别。\n先看一下add方法的实现\n\n\tpublic boolean add(E e) {\n\t        addLast(e);\n\t        return true;\n\t    }\n\t public void addLast(E e) {\n\t        if (e == null)\n\t            throw new NullPointerException();\n\t        elements[tail] = e;\n\t        if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n\t            doubleCapacity();\n\t    }\n再看一下offer方法的实现\n\n\tpublic boolean offer(E e) {\n\t        return offerLast(e);\n\t    }\n\tpublic boolean offerLast(E e) {\n\t        addLast(e);\n\t        return true;\n\t    }\n\tpublic void addLast(E e) {\n\t        if (e == null)\n\t            throw new NullPointerException();\n\t        elements[tail] = e;\n\t        if ( (tail = (tail + 1) & (elements.length - 1)) == head)\n\t            doubleCapacity();\n\t    }\n\t    ","slug":"queue","published":1,"updated":"2016-07-19T13:20:52.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmkt002i1kvsn2z0dold","content":"<p>java中的栈为Stack，Stack是一个类，队列为Queue，但是与栈的实现不同的是，Queue是一个接口，而不是实现类。Queue接口定义的方法有：<br><a id=\"more\"></a></p>\n<pre><code>boolean add(E e);//向队列中添加一个元素，成功返回true\nboolean offer(E e);//向队列中添加一个元素，成功返回true\nE remove();\nE poll();\nE element();\nE peek();\n</code></pre><p>Deque为双端队列，也是一个接口，继承自Queue。以Deque接口的一个实现类ArrayDeque为例，说一下add方法与offer方法的区别。<br>先看一下add方法的实现</p>\n<pre><code>public boolean add(E e) {\n        addLast(e);\n        return true;\n    }\n public void addLast(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        elements[tail] = e;\n        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)\n            doubleCapacity();\n    }\n</code></pre><p>再看一下offer方法的实现</p>\n<pre><code>public boolean offer(E e) {\n        return offerLast(e);\n    }\npublic boolean offerLast(E e) {\n        addLast(e);\n        return true;\n    }\npublic void addLast(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        elements[tail] = e;\n        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)\n            doubleCapacity();\n    }\n</code></pre>","excerpt":"<p>java中的栈为Stack，Stack是一个类，队列为Queue，但是与栈的实现不同的是，Queue是一个接口，而不是实现类。Queue接口定义的方法有：<br>","more":"</p>\n<pre><code>boolean add(E e);//向队列中添加一个元素，成功返回true\nboolean offer(E e);//向队列中添加一个元素，成功返回true\nE remove();\nE poll();\nE element();\nE peek();\n</code></pre><p>Deque为双端队列，也是一个接口，继承自Queue。以Deque接口的一个实现类ArrayDeque为例，说一下add方法与offer方法的区别。<br>先看一下add方法的实现</p>\n<pre><code>public boolean add(E e) {\n        addLast(e);\n        return true;\n    }\n public void addLast(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        elements[tail] = e;\n        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)\n            doubleCapacity();\n    }\n</code></pre><p>再看一下offer方法的实现</p>\n<pre><code>public boolean offer(E e) {\n        return offerLast(e);\n    }\npublic boolean offerLast(E e) {\n        addLast(e);\n        return true;\n    }\npublic void addLast(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        elements[tail] = e;\n        if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)\n            doubleCapacity();\n    }\n</code></pre>"},{"title":"jquery源码分析之merge()","date":"2016-07-17T12:31:09.000Z","_content":"jquery中的merge\n作用：合并两个数组，返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素\n<!-- more -->\n\n\tmerge: function( first, second ) {\n\t\t\tvar i = first.length,\n\t\t\t\tj = 0;\n            //对于类数组对象\n\t\t\tif ( typeof second.length === \"number\" ) {\n\t\t\t\tfor ( var l = second.length; j < l; j++ ) {\n\t\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t\t}\n\n            //对于非类数组对象\n\t\t\t} else {\n\t\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t\t}\n\t\t\t}\n\t\t   //手动修正数组的length\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\t\n\t\t}\ntypeof second.length === \"number\" 很好理解，下面举个else中的例子：\n\n\tvar people = {\n\t   \tname:\"xiaohua\",\n\t   \tage:\"26\"\n\t}\n\tconsole.log(people.length); => undefined\n\tconsole.log($.merge([1,2,3], people)); => 1,2,3\n\n但是对于键为数值的对象，如果是从0开始往后依次加1的情况（如果不是从0开始，second[0]就为undefined，则退出循环），仍然可以加入到数组中，如：\n\n\tvar people = {\n\t   \t0:\"xiaohua\",\n\t   \t1:\"26\"\n\t}\n\tconsole.log(people.length); => undefined\n\tconsole.log($.merge([1,2,3], people)); => 1,2,3,xiaohua,26\n\t\t\n需要注意的是第一个元素的length一定要为数值。\n最后解释下为什么需要修正length值。当第一个参数是类数组时，如：\n\n\t<ul>\n\t<li></li>\n\t</ul>\n\tvar first = [1,2,3,4,5,6];\n\tconsole.log($.merge($(\"li\"), first).length); =>7\n\n如果不进行修正的话，则\n\n   $.merge($(\"li\"), first).length => 1\n\n\n","source":"_posts/jqueryMerge.md","raw":"---\ntitle: jquery源码分析之merge()\ndate: 2016-07-17 20:31:09\ntags: \n  - javascript\n  - jQuery源码\ncategories:\n  - 学习笔记\n  - 前端学习\n---\njquery中的merge\n作用：合并两个数组，返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素\n<!-- more -->\n\n\tmerge: function( first, second ) {\n\t\t\tvar i = first.length,\n\t\t\t\tj = 0;\n            //对于类数组对象\n\t\t\tif ( typeof second.length === \"number\" ) {\n\t\t\t\tfor ( var l = second.length; j < l; j++ ) {\n\t\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t\t}\n\n            //对于非类数组对象\n\t\t\t} else {\n\t\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t\t}\n\t\t\t}\n\t\t   //手动修正数组的length\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\t\n\t\t}\ntypeof second.length === \"number\" 很好理解，下面举个else中的例子：\n\n\tvar people = {\n\t   \tname:\"xiaohua\",\n\t   \tage:\"26\"\n\t}\n\tconsole.log(people.length); => undefined\n\tconsole.log($.merge([1,2,3], people)); => 1,2,3\n\n但是对于键为数值的对象，如果是从0开始往后依次加1的情况（如果不是从0开始，second[0]就为undefined，则退出循环），仍然可以加入到数组中，如：\n\n\tvar people = {\n\t   \t0:\"xiaohua\",\n\t   \t1:\"26\"\n\t}\n\tconsole.log(people.length); => undefined\n\tconsole.log($.merge([1,2,3], people)); => 1,2,3,xiaohua,26\n\t\t\n需要注意的是第一个元素的length一定要为数值。\n最后解释下为什么需要修正length值。当第一个参数是类数组时，如：\n\n\t<ul>\n\t<li></li>\n\t</ul>\n\tvar first = [1,2,3,4,5,6];\n\tconsole.log($.merge($(\"li\"), first).length); =>7\n\n如果不进行修正的话，则\n\n   $.merge($(\"li\"), first).length => 1\n\n\n","slug":"jqueryMerge","published":1,"updated":"2016-07-17T13:46:28.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kml9002l1kvsvg9n4yb1","content":"<p>jquery中的merge<br>作用：合并两个数组，返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素<br><a id=\"more\"></a></p>\n<pre><code>merge: function( first, second ) {\n        var i = first.length,\n            j = 0;\n        //对于类数组对象\n        if ( typeof second.length === &quot;number&quot; ) {\n            for ( var l = second.length; j &lt; l; j++ ) {\n                first[ i++ ] = second[ j ];\n            }\n\n        //对于非类数组对象\n        } else {\n            while ( second[j] !== undefined ) {\n                first[ i++ ] = second[ j++ ];\n            }\n        }\n       //手动修正数组的length\n        first.length = i;\n\n        return first;    \n    }\n</code></pre><p>typeof second.length === “number” 很好理解，下面举个else中的例子：</p>\n<pre><code>var people = {\n       name:&quot;xiaohua&quot;,\n       age:&quot;26&quot;\n}\nconsole.log(people.length); =&gt; undefined\nconsole.log($.merge([1,2,3], people)); =&gt; 1,2,3\n</code></pre><p>但是对于键为数值的对象，如果是从0开始往后依次加1的情况（如果不是从0开始，second[0]就为undefined，则退出循环），仍然可以加入到数组中，如：</p>\n<pre><code>var people = {\n       0:&quot;xiaohua&quot;,\n       1:&quot;26&quot;\n}\nconsole.log(people.length); =&gt; undefined\nconsole.log($.merge([1,2,3], people)); =&gt; 1,2,3,xiaohua,26\n</code></pre><p>需要注意的是第一个元素的length一定要为数值。<br>最后解释下为什么需要修正length值。当第一个参数是类数组时，如：</p>\n<pre><code>&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\nvar first = [1,2,3,4,5,6];\nconsole.log($.merge($(&quot;li&quot;), first).length); =&gt;7\n</code></pre><p>如果不进行修正的话，则</p>\n<p>   $.merge($(“li”), first).length =&gt; 1</p>\n","excerpt":"<p>jquery中的merge<br>作用：合并两个数组，返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素<br>","more":"</p>\n<pre><code>merge: function( first, second ) {\n        var i = first.length,\n            j = 0;\n        //对于类数组对象\n        if ( typeof second.length === &quot;number&quot; ) {\n            for ( var l = second.length; j &lt; l; j++ ) {\n                first[ i++ ] = second[ j ];\n            }\n\n        //对于非类数组对象\n        } else {\n            while ( second[j] !== undefined ) {\n                first[ i++ ] = second[ j++ ];\n            }\n        }\n       //手动修正数组的length\n        first.length = i;\n\n        return first;    \n    }\n</code></pre><p>typeof second.length === “number” 很好理解，下面举个else中的例子：</p>\n<pre><code>var people = {\n       name:&quot;xiaohua&quot;,\n       age:&quot;26&quot;\n}\nconsole.log(people.length); =&gt; undefined\nconsole.log($.merge([1,2,3], people)); =&gt; 1,2,3\n</code></pre><p>但是对于键为数值的对象，如果是从0开始往后依次加1的情况（如果不是从0开始，second[0]就为undefined，则退出循环），仍然可以加入到数组中，如：</p>\n<pre><code>var people = {\n       0:&quot;xiaohua&quot;,\n       1:&quot;26&quot;\n}\nconsole.log(people.length); =&gt; undefined\nconsole.log($.merge([1,2,3], people)); =&gt; 1,2,3,xiaohua,26\n</code></pre><p>需要注意的是第一个元素的length一定要为数值。<br>最后解释下为什么需要修正length值。当第一个参数是类数组时，如：</p>\n<pre><code>&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\nvar first = [1,2,3,4,5,6];\nconsole.log($.merge($(&quot;li&quot;), first).length); =&gt;7\n</code></pre><p>如果不进行修正的话，则</p>\n<p>   $.merge($(“li”), first).length =&gt; 1</p>"},{"title":"SVM学习笔记（一）","date":"2016-06-12T03:29:08.000Z","_content":"# 一些基本概念介绍\n1. 线性可分：可以用一条直线将正样本与负样本分隔\n2. 间隔最大化\n2.1 函数间隔：可以表示分类预测的正确性及确信度，\n2.2 几何间隔 \n3. 特征空间：\n4. 特征向量：\n5. 欧氏空间\n6. 希尔伯特空间\n7. 分离超平面：wx+b = 0\n8. 支持向量\n\n# SVM基本介绍\n1. SVM（支持向量机）是一种二类分类模型，基本模型是定义在特征空间上的间隔最大的线性分类器\n2. 包含由简至繁的模型：\n（1）线性可分支持向量机（又称硬间隔支持向量机）\n训练数据线性可分，通过硬间隔最大化学习的线性分类器\n（2）线性支持向量机（又称软间隔支持向量机）\n训练数据近似线性可分，通过软间隔最大化学习的线性分类器\n（3）非线性支持向量机\n训练数据线性不可分，通过使用核技巧和软间隔最大化学习的非线性支持向量机\n","source":"_posts/svm.md","raw":"---\ntitle: SVM学习笔记（一）\ndate: 2016-06-12 11:29:08\ntags:\n---\n# 一些基本概念介绍\n1. 线性可分：可以用一条直线将正样本与负样本分隔\n2. 间隔最大化\n2.1 函数间隔：可以表示分类预测的正确性及确信度，\n2.2 几何间隔 \n3. 特征空间：\n4. 特征向量：\n5. 欧氏空间\n6. 希尔伯特空间\n7. 分离超平面：wx+b = 0\n8. 支持向量\n\n# SVM基本介绍\n1. SVM（支持向量机）是一种二类分类模型，基本模型是定义在特征空间上的间隔最大的线性分类器\n2. 包含由简至繁的模型：\n（1）线性可分支持向量机（又称硬间隔支持向量机）\n训练数据线性可分，通过硬间隔最大化学习的线性分类器\n（2）线性支持向量机（又称软间隔支持向量机）\n训练数据近似线性可分，通过软间隔最大化学习的线性分类器\n（3）非线性支持向量机\n训练数据线性不可分，通过使用核技巧和软间隔最大化学习的非线性支持向量机\n","slug":"svm","published":1,"updated":"2016-06-14T12:33:58.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmlo002o1kvsgu0ivps2","content":"<h1 id=\"一些基本概念介绍\"><a href=\"#一些基本概念介绍\" class=\"headerlink\" title=\"一些基本概念介绍\"></a>一些基本概念介绍</h1><ol>\n<li>线性可分：可以用一条直线将正样本与负样本分隔</li>\n<li>间隔最大化<br>2.1 函数间隔：可以表示分类预测的正确性及确信度，<br>2.2 几何间隔 </li>\n<li>特征空间：</li>\n<li>特征向量：</li>\n<li>欧氏空间</li>\n<li>希尔伯特空间</li>\n<li>分离超平面：wx+b = 0</li>\n<li>支持向量</li>\n</ol>\n<h1 id=\"SVM基本介绍\"><a href=\"#SVM基本介绍\" class=\"headerlink\" title=\"SVM基本介绍\"></a>SVM基本介绍</h1><ol>\n<li>SVM（支持向量机）是一种二类分类模型，基本模型是定义在特征空间上的间隔最大的线性分类器</li>\n<li>包含由简至繁的模型：<br>（1）线性可分支持向量机（又称硬间隔支持向量机）<br>训练数据线性可分，通过硬间隔最大化学习的线性分类器<br>（2）线性支持向量机（又称软间隔支持向量机）<br>训练数据近似线性可分，通过软间隔最大化学习的线性分类器<br>（3）非线性支持向量机<br>训练数据线性不可分，通过使用核技巧和软间隔最大化学习的非线性支持向量机</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"一些基本概念介绍\"><a href=\"#一些基本概念介绍\" class=\"headerlink\" title=\"一些基本概念介绍\"></a>一些基本概念介绍</h1><ol>\n<li>线性可分：可以用一条直线将正样本与负样本分隔</li>\n<li>间隔最大化<br>2.1 函数间隔：可以表示分类预测的正确性及确信度，<br>2.2 几何间隔 </li>\n<li>特征空间：</li>\n<li>特征向量：</li>\n<li>欧氏空间</li>\n<li>希尔伯特空间</li>\n<li>分离超平面：wx+b = 0</li>\n<li>支持向量</li>\n</ol>\n<h1 id=\"SVM基本介绍\"><a href=\"#SVM基本介绍\" class=\"headerlink\" title=\"SVM基本介绍\"></a>SVM基本介绍</h1><ol>\n<li>SVM（支持向量机）是一种二类分类模型，基本模型是定义在特征空间上的间隔最大的线性分类器</li>\n<li>包含由简至繁的模型：<br>（1）线性可分支持向量机（又称硬间隔支持向量机）<br>训练数据线性可分，通过硬间隔最大化学习的线性分类器<br>（2）线性支持向量机（又称软间隔支持向量机）<br>训练数据近似线性可分，通过软间隔最大化学习的线性分类器<br>（3）非线性支持向量机<br>训练数据线性不可分，通过使用核技巧和软间隔最大化学习的非线性支持向量机</li>\n</ol>\n"},{"title":"java栈方法中push与add方法的区别","date":"2016-06-17T01:06:46.000Z","_content":"Java中Stack的压栈操作有两个方法，add和push，\n先看下push的api\n<!-- more -->\n\n\t TreeNode java.util.Stack.push(TreeNode item)\n\n\n\tPushes an item onto the top of this stack. This has exactly the same effect as: \n\n\t addElement(item)\n\tParameters:\n\titem the item to be pushed onto this stack.\n\tReturns:\n\tthe item argument.\n\tSee Also:\n\tjava.util.Vector.addElement\n再看一下add的api\n\n\t boolean java.util.Vector.add(TreeNode e)\n\n\n\tAppends the specified element to the end of this Vector.\n\n\tSpecified by: add(...) in List, Overrides: add(...) in AbstractList\n\tParameters:\n\te element to be appended to this Vector\n\tReturns:\n\ttrue (as specified by Collection.add)\n\tSince:\n\t1.2\n可以发现两者的返回值不同，push方法返回的是被压入栈的元素，add方法返回的是压栈是否成功。\n再来看一下两者的实现。首先是push方法\n\npush是在Stack类中实现的，可以看到返回的就是压栈的元素本身。\n\n\tpublic E push(E item) {\n\t        addElement(item);\n\t        return item;\n\t    }\n而addElement方法是在Vector类中实现的，代码如下：\n\n\t public synchronized void addElement(E obj) {\n\t        modCount++;\n\t        ensureCapacityHelper(elementCount + 1);\n\t        elementData[elementCount++] = obj;\n\t    }\n\n接下来看一下add方法的实现，add方法直接是在Vector类中实现的，代码如下：\n\n\tpublic synchronized boolean add(E e) {\n\t        modCount++;\n\t        ensureCapacityHelper(elementCount + 1);\n\t        elementData[elementCount++] = e;\n\t        return true;\n\t    }\n通过源代码可以看出两者只有返回值不同。","source":"_posts/java栈方法.md","raw":"---\ntitle: java栈方法中push与add方法的区别\ndate: 2016-06-17 09:06:46\ntags: \n  - java\n  - stack\n  - add and push\ncategories:\n  - 学习笔记\n  - java\n---\nJava中Stack的压栈操作有两个方法，add和push，\n先看下push的api\n<!-- more -->\n\n\t TreeNode java.util.Stack.push(TreeNode item)\n\n\n\tPushes an item onto the top of this stack. This has exactly the same effect as: \n\n\t addElement(item)\n\tParameters:\n\titem the item to be pushed onto this stack.\n\tReturns:\n\tthe item argument.\n\tSee Also:\n\tjava.util.Vector.addElement\n再看一下add的api\n\n\t boolean java.util.Vector.add(TreeNode e)\n\n\n\tAppends the specified element to the end of this Vector.\n\n\tSpecified by: add(...) in List, Overrides: add(...) in AbstractList\n\tParameters:\n\te element to be appended to this Vector\n\tReturns:\n\ttrue (as specified by Collection.add)\n\tSince:\n\t1.2\n可以发现两者的返回值不同，push方法返回的是被压入栈的元素，add方法返回的是压栈是否成功。\n再来看一下两者的实现。首先是push方法\n\npush是在Stack类中实现的，可以看到返回的就是压栈的元素本身。\n\n\tpublic E push(E item) {\n\t        addElement(item);\n\t        return item;\n\t    }\n而addElement方法是在Vector类中实现的，代码如下：\n\n\t public synchronized void addElement(E obj) {\n\t        modCount++;\n\t        ensureCapacityHelper(elementCount + 1);\n\t        elementData[elementCount++] = obj;\n\t    }\n\n接下来看一下add方法的实现，add方法直接是在Vector类中实现的，代码如下：\n\n\tpublic synchronized boolean add(E e) {\n\t        modCount++;\n\t        ensureCapacityHelper(elementCount + 1);\n\t        elementData[elementCount++] = e;\n\t        return true;\n\t    }\n通过源代码可以看出两者只有返回值不同。","slug":"java栈方法","published":1,"updated":"2016-06-18T13:53:41.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmlo002r1kvs56q2onbx","content":"<p>Java中Stack的压栈操作有两个方法，add和push，<br>先看下push的api<br><a id=\"more\"></a></p>\n<pre><code> TreeNode java.util.Stack.push(TreeNode item)\n\n\nPushes an item onto the top of this stack. This has exactly the same effect as: \n\n addElement(item)\nParameters:\nitem the item to be pushed onto this stack.\nReturns:\nthe item argument.\nSee Also:\njava.util.Vector.addElement\n</code></pre><p>再看一下add的api</p>\n<pre><code> boolean java.util.Vector.add(TreeNode e)\n\n\nAppends the specified element to the end of this Vector.\n\nSpecified by: add(...) in List, Overrides: add(...) in AbstractList\nParameters:\ne element to be appended to this Vector\nReturns:\ntrue (as specified by Collection.add)\nSince:\n1.2\n</code></pre><p>可以发现两者的返回值不同，push方法返回的是被压入栈的元素，add方法返回的是压栈是否成功。<br>再来看一下两者的实现。首先是push方法</p>\n<p>push是在Stack类中实现的，可以看到返回的就是压栈的元素本身。</p>\n<pre><code>public E push(E item) {\n        addElement(item);\n        return item;\n    }\n</code></pre><p>而addElement方法是在Vector类中实现的，代码如下：</p>\n<pre><code>public synchronized void addElement(E obj) {\n       modCount++;\n       ensureCapacityHelper(elementCount + 1);\n       elementData[elementCount++] = obj;\n   }\n</code></pre><p>接下来看一下add方法的实现，add方法直接是在Vector类中实现的，代码如下：</p>\n<pre><code>public synchronized boolean add(E e) {\n        modCount++;\n        ensureCapacityHelper(elementCount + 1);\n        elementData[elementCount++] = e;\n        return true;\n    }\n</code></pre><p>通过源代码可以看出两者只有返回值不同。</p>\n","excerpt":"<p>Java中Stack的压栈操作有两个方法，add和push，<br>先看下push的api<br>","more":"</p>\n<pre><code> TreeNode java.util.Stack.push(TreeNode item)\n\n\nPushes an item onto the top of this stack. This has exactly the same effect as: \n\n addElement(item)\nParameters:\nitem the item to be pushed onto this stack.\nReturns:\nthe item argument.\nSee Also:\njava.util.Vector.addElement\n</code></pre><p>再看一下add的api</p>\n<pre><code> boolean java.util.Vector.add(TreeNode e)\n\n\nAppends the specified element to the end of this Vector.\n\nSpecified by: add(...) in List, Overrides: add(...) in AbstractList\nParameters:\ne element to be appended to this Vector\nReturns:\ntrue (as specified by Collection.add)\nSince:\n1.2\n</code></pre><p>可以发现两者的返回值不同，push方法返回的是被压入栈的元素，add方法返回的是压栈是否成功。<br>再来看一下两者的实现。首先是push方法</p>\n<p>push是在Stack类中实现的，可以看到返回的就是压栈的元素本身。</p>\n<pre><code>public E push(E item) {\n        addElement(item);\n        return item;\n    }\n</code></pre><p>而addElement方法是在Vector类中实现的，代码如下：</p>\n<pre><code>public synchronized void addElement(E obj) {\n       modCount++;\n       ensureCapacityHelper(elementCount + 1);\n       elementData[elementCount++] = obj;\n   }\n</code></pre><p>接下来看一下add方法的实现，add方法直接是在Vector类中实现的，代码如下：</p>\n<pre><code>public synchronized boolean add(E e) {\n        modCount++;\n        ensureCapacityHelper(elementCount + 1);\n        elementData[elementCount++] = e;\n        return true;\n    }\n</code></pre><p>通过源代码可以看出两者只有返回值不同。</p>"},{"title":"javascript 中的this","date":"2016-07-17T07:42:30.000Z","_content":"javascript中的this始终指向当前运行的函数所属的对象。\n<!-- more -->\n一 普通的函数调用中this\n\n\t \tvar x=1;\n\t\tfunction test(){\n\t\t\talert(this.x);\n\t\t}\n\t\ttest();\n当前函数的所属对象是window对象，故this指向window对象\n二 当this作为对象的方法被调用时，指向调用该方法的对象。\n三 当函数作为构造函数被调用时，this指向由该构造函数创建的对象\n四 call和apply可以改变this的指向，使this指向call或apply的第一个参数所代表的对象\n\n另外，关于this的指向的问题，有个很奇怪的例子：\n例一：\n\n\t\tvar name = \"outer\";\n\t\tvar person = {\n\t\t\tname:\"inner\",\n\t\t\tage:18,\n\t\t\tgetName:function(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\t\t}\n\t\tconsole.log((person.getName=person.getName)());  //=>outer\n而例二：\n\n\t\tvar name = \"outer\";\n\t\tvar person = {\n\t\t\tname:\"inner\",\n\t\t\tage:18,\n\t\t\tgetName:function(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\t\t}\n\t\tperson.getName=person.getName;\n\t\tconsole.log(person.getName());  //=>inner\n\n解释：在例一中，赋值表达式的结果是函数本身，即（person.getName=person.getName）的结果是一个值，而这个值是函数。\n\n\t\t\tfunction(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\n然后直接调用，因此此时this指向的是window对象。\n而例二中明确指定是调用person的方法，故this指向的是person对象。","source":"_posts/this.md","raw":"---\ntitle: javascript 中的this\ndate: 2016-07-17 15:42:30\ntags: \n  - javascript\n  - this\ncategories:\n  - 学习笔记\n  - 前端学习\n---\njavascript中的this始终指向当前运行的函数所属的对象。\n<!-- more -->\n一 普通的函数调用中this\n\n\t \tvar x=1;\n\t\tfunction test(){\n\t\t\talert(this.x);\n\t\t}\n\t\ttest();\n当前函数的所属对象是window对象，故this指向window对象\n二 当this作为对象的方法被调用时，指向调用该方法的对象。\n三 当函数作为构造函数被调用时，this指向由该构造函数创建的对象\n四 call和apply可以改变this的指向，使this指向call或apply的第一个参数所代表的对象\n\n另外，关于this的指向的问题，有个很奇怪的例子：\n例一：\n\n\t\tvar name = \"outer\";\n\t\tvar person = {\n\t\t\tname:\"inner\",\n\t\t\tage:18,\n\t\t\tgetName:function(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\t\t}\n\t\tconsole.log((person.getName=person.getName)());  //=>outer\n而例二：\n\n\t\tvar name = \"outer\";\n\t\tvar person = {\n\t\t\tname:\"inner\",\n\t\t\tage:18,\n\t\t\tgetName:function(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\t\t}\n\t\tperson.getName=person.getName;\n\t\tconsole.log(person.getName());  //=>inner\n\n解释：在例一中，赋值表达式的结果是函数本身，即（person.getName=person.getName）的结果是一个值，而这个值是函数。\n\n\t\t\tfunction(){\n\t\t\t\treturn this.name;\n\t\t\t}\n\n然后直接调用，因此此时this指向的是window对象。\n而例二中明确指定是调用person的方法，故this指向的是person对象。","slug":"this","published":1,"updated":"2016-07-31T06:39:38.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmm4002u1kvsy0us8asg","content":"<p>javascript中的this始终指向当前运行的函数所属的对象。<br><a id=\"more\"></a><br>一 普通的函数调用中this</p>\n<pre><code> var x=1;\nfunction test(){\n    alert(this.x);\n}\ntest();\n</code></pre><p>当前函数的所属对象是window对象，故this指向window对象<br>二 当this作为对象的方法被调用时，指向调用该方法的对象。<br>三 当函数作为构造函数被调用时，this指向由该构造函数创建的对象<br>四 call和apply可以改变this的指向，使this指向call或apply的第一个参数所代表的对象</p>\n<p>另外，关于this的指向的问题，有个很奇怪的例子：<br>例一：</p>\n<pre><code>var name = &quot;outer&quot;;\nvar person = {\n    name:&quot;inner&quot;,\n    age:18,\n    getName:function(){\n        return this.name;\n    }\n}\nconsole.log((person.getName=person.getName)());  //=&gt;outer\n</code></pre><p>而例二：</p>\n<pre><code>var name = &quot;outer&quot;;\nvar person = {\n    name:&quot;inner&quot;,\n    age:18,\n    getName:function(){\n        return this.name;\n    }\n}\nperson.getName=person.getName;\nconsole.log(person.getName());  //=&gt;inner\n</code></pre><p>解释：在例一中，赋值表达式的结果是函数本身，即（person.getName=person.getName）的结果是一个值，而这个值是函数。</p>\n<pre><code>function(){\n    return this.name;\n}\n</code></pre><p>然后直接调用，因此此时this指向的是window对象。<br>而例二中明确指定是调用person的方法，故this指向的是person对象。</p>\n","excerpt":"<p>javascript中的this始终指向当前运行的函数所属的对象。<br>","more":"<br>一 普通的函数调用中this</p>\n<pre><code> var x=1;\nfunction test(){\n    alert(this.x);\n}\ntest();\n</code></pre><p>当前函数的所属对象是window对象，故this指向window对象<br>二 当this作为对象的方法被调用时，指向调用该方法的对象。<br>三 当函数作为构造函数被调用时，this指向由该构造函数创建的对象<br>四 call和apply可以改变this的指向，使this指向call或apply的第一个参数所代表的对象</p>\n<p>另外，关于this的指向的问题，有个很奇怪的例子：<br>例一：</p>\n<pre><code>var name = &quot;outer&quot;;\nvar person = {\n    name:&quot;inner&quot;,\n    age:18,\n    getName:function(){\n        return this.name;\n    }\n}\nconsole.log((person.getName=person.getName)());  //=&gt;outer\n</code></pre><p>而例二：</p>\n<pre><code>var name = &quot;outer&quot;;\nvar person = {\n    name:&quot;inner&quot;,\n    age:18,\n    getName:function(){\n        return this.name;\n    }\n}\nperson.getName=person.getName;\nconsole.log(person.getName());  //=&gt;inner\n</code></pre><p>解释：在例一中，赋值表达式的结果是函数本身，即（person.getName=person.getName）的结果是一个值，而这个值是函数。</p>\n<pre><code>function(){\n    return this.name;\n}\n</code></pre><p>然后直接调用，因此此时this指向的是window对象。<br>而例二中明确指定是调用person的方法，故this指向的是person对象。</p>"},{"title":"setTimeout","date":"2016-08-01T07:32:56.000Z","_content":"今天来分析下setTimeout这个函数。\n\n# 语法\n<!-- more -->\n\n首先是setTimeout方法的api：\n\nsetTimeout(code,millisec);\n\n|参数|描述|\n|------|------|\n|code|必需。要调用的函数后要执行的 JavaScript 代码串。|\n|millisec|必需。在执行代码前需等待的毫秒数。|\n\n\nsetTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式，其实是在指定毫秒后将调用函数或计算表达式的任务加入到任务队列。\n\n# setTimeout原理\n\nJavaScript 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务。这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是 Ajax 请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。假如当前 JavaScript 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。\n\n# 关于任务队列与事件循环\n\nsetTimeout的作用是延迟将任务加入到任务队列，那任务队列又是什么呢？\n\n首先，JavaScript是单线程语言，即一次只能执行一个任务，也就是说所有的任务需要排队，当前一个任务结束之后后一个任务才能执行，如果前一个任务耗时很长，则后一个任务将一直阻塞。如果当前执行的任务是IO操作，则CPU此时空闲，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\n\n于是，任务被分成了两种：\n一种是同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务\n另一种是异步任务（asynchronous）:不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n>（2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n>（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n>（4）主线程不断重复上面的第三步。\n\n注意只有当主线程空了的时候才会去读任务队列中的任务。\n主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。\n![事件循环](/img/event_loop.png)\n\n上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在\"任务队列\"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取\"任务队列\"，依次执行那些事件所对应的回调函数。\n\n# 关于setTimeout(fn,0)\n\nsetTimeout(fn,0)与fn有什么区别呢？\n\nsetTimeout(fn,0)表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\n\n本文总结自 http://www.ruanyifeng.com/blog/2014/10/event-loop.html","source":"_posts/setTimeout.md","raw":"---\ntitle: setTimeout\ndate: 2016-08-01 15:32:56\ntags: \n  - javascript\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n今天来分析下setTimeout这个函数。\n\n# 语法\n<!-- more -->\n\n首先是setTimeout方法的api：\n\nsetTimeout(code,millisec);\n\n|参数|描述|\n|------|------|\n|code|必需。要调用的函数后要执行的 JavaScript 代码串。|\n|millisec|必需。在执行代码前需等待的毫秒数。|\n\n\nsetTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式，其实是在指定毫秒后将调用函数或计算表达式的任务加入到任务队列。\n\n# setTimeout原理\n\nJavaScript 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务。这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是 Ajax 请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。假如当前 JavaScript 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。\n\n# 关于任务队列与事件循环\n\nsetTimeout的作用是延迟将任务加入到任务队列，那任务队列又是什么呢？\n\n首先，JavaScript是单线程语言，即一次只能执行一个任务，也就是说所有的任务需要排队，当前一个任务结束之后后一个任务才能执行，如果前一个任务耗时很长，则后一个任务将一直阻塞。如果当前执行的任务是IO操作，则CPU此时空闲，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。\n\n于是，任务被分成了两种：\n一种是同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务\n另一种是异步任务（asynchronous）:不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）\n>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。\n>（2）主线程之外，还存在一个\"任务队列\"（task queue）。只要异步任务有了运行结果，就在\"任务队列\"之中放置一个事件。\n>（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统就会读取\"任务队列\"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。\n>（4）主线程不断重复上面的第三步。\n\n注意只有当主线程空了的时候才会去读任务队列中的任务。\n主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。\n![事件循环](/img/event_loop.png)\n\n上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在\"任务队列\"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取\"任务队列\"，依次执行那些事件所对应的回调函数。\n\n# 关于setTimeout(fn,0)\n\nsetTimeout(fn,0)与fn有什么区别呢？\n\nsetTimeout(fn,0)表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。\n\n本文总结自 http://www.ruanyifeng.com/blog/2014/10/event-loop.html","slug":"setTimeout","published":1,"updated":"2016-09-03T14:28:35.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmm4002x1kvssm83pfj6","content":"<p>今天来分析下setTimeout这个函数。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><a id=\"more\"></a>\n<p>首先是setTimeout方法的api：</p>\n<p>setTimeout(code,millisec);</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>code</td>\n<td>必需。要调用的函数后要执行的 JavaScript 代码串。</td>\n</tr>\n<tr>\n<td>millisec</td>\n<td>必需。在执行代码前需等待的毫秒数。</td>\n</tr>\n</tbody>\n</table>\n<p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式，其实是在指定毫秒后将调用函数或计算表达式的任务加入到任务队列。</p>\n<h1 id=\"setTimeout原理\"><a href=\"#setTimeout原理\" class=\"headerlink\" title=\"setTimeout原理\"></a>setTimeout原理</h1><p>JavaScript 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务。这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是 Ajax 请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。假如当前 JavaScript 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</p>\n<h1 id=\"关于任务队列与事件循环\"><a href=\"#关于任务队列与事件循环\" class=\"headerlink\" title=\"关于任务队列与事件循环\"></a>关于任务队列与事件循环</h1><p>setTimeout的作用是延迟将任务加入到任务队列，那任务队列又是什么呢？</p>\n<p>首先，JavaScript是单线程语言，即一次只能执行一个任务，也就是说所有的任务需要排队，当前一个任务结束之后后一个任务才能执行，如果前一个任务耗时很长，则后一个任务将一直阻塞。如果当前执行的任务是IO操作，则CPU此时空闲，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>\n<p>于是，任务被分成了两种：<br>一种是同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务<br>另一种是异步任务（asynchronous）:不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<blockquote>\n<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p>\n</blockquote>\n<p>注意只有当主线程空了的时候才会去读任务队列中的任务。<br>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。<br><img src=\"/img/event_loop.png\" alt=\"事件循环\"></p>\n<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>\n<h1 id=\"关于setTimeout-fn-0\"><a href=\"#关于setTimeout-fn-0\" class=\"headerlink\" title=\"关于setTimeout(fn,0)\"></a>关于setTimeout(fn,0)</h1><p>setTimeout(fn,0)与fn有什么区别呢？</p>\n<p>setTimeout(fn,0)表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>\n<p>本文总结自 <a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>\n","excerpt":"<p>今天来分析下setTimeout这个函数。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1>","more":"<p>首先是setTimeout方法的api：</p>\n<p>setTimeout(code,millisec);</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>code</td>\n<td>必需。要调用的函数后要执行的 JavaScript 代码串。</td>\n</tr>\n<tr>\n<td>millisec</td>\n<td>必需。在执行代码前需等待的毫秒数。</td>\n</tr>\n</tbody>\n</table>\n<p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式，其实是在指定毫秒后将调用函数或计算表达式的任务加入到任务队列。</p>\n<h1 id=\"setTimeout原理\"><a href=\"#setTimeout原理\" class=\"headerlink\" title=\"setTimeout原理\"></a>setTimeout原理</h1><p>JavaScript 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务。这也常被称为 “阻塞式执行”。所以一次鼠标点击，或是计时器到达时间点，或是 Ajax 请求完成触发了回调函数，这些事件处理程序或回调函数都不会立即运行，而是立即排队，一旦线程有空闲就执行。假如当前 JavaScript 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行。如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</p>\n<h1 id=\"关于任务队列与事件循环\"><a href=\"#关于任务队列与事件循环\" class=\"headerlink\" title=\"关于任务队列与事件循环\"></a>关于任务队列与事件循环</h1><p>setTimeout的作用是延迟将任务加入到任务队列，那任务队列又是什么呢？</p>\n<p>首先，JavaScript是单线程语言，即一次只能执行一个任务，也就是说所有的任务需要排队，当前一个任务结束之后后一个任务才能执行，如果前一个任务耗时很长，则后一个任务将一直阻塞。如果当前执行的任务是IO操作，则CPU此时空闲，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>\n<p>于是，任务被分成了两种：<br>一种是同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务<br>另一种是异步任务（asynchronous）:不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<blockquote>\n<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）<br>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p>\n</blockquote>\n<p>注意只有当主线程空了的时候才会去读任务队列中的任务。<br>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。<br><img src=\"/img/event_loop.png\" alt=\"事件循环\"></p>\n<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>\n<h1 id=\"关于setTimeout-fn-0\"><a href=\"#关于setTimeout-fn-0\" class=\"headerlink\" title=\"关于setTimeout(fn,0)\"></a>关于setTimeout(fn,0)</h1><p>setTimeout(fn,0)与fn有什么区别呢？</p>\n<p>setTimeout(fn,0)表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>\n<p>本文总结自 <a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>"},{"title":"javascript作用域","date":"2016-07-31T06:35:58.000Z","_content":"在此篇文章中，针对变量的作用域，执行环境等问题，通过一些小demo进行了对比分析\n我们来看下面的几个小例子\n<!-- more -->\n\n1. 首先来个最简单的：\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>1\n这个程序输出1肯定没什么问题了，函数局部作用域内没有局部变量a，因此沿着作用域链向上查找，找到了全局变量a，于是输出。\n\n2. 接下来添加个局部变量：\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  var a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>2\n这段程序输出2，因为沿着作用域链向上查找时，首先找到的是局部变量a是2，于是将2输出.\n\n3. 继续变形\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  console.log(a);\n\t\t  var a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>undefined 2\n这时第一个console.log(a)输出undefined，第二个输出2，第二个其实不难理解，但是有可能有人不能理解第一个为什么会输出undefined。其实主要是变量声明提升（javascript引擎在执行时，会把所有的变量的声明都提升到当前作用域的最前端）的问题，即上面的代码相当于\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  var a;\n\t\t  console.log(a);\n\t\t  a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();\n这时，当第一次要输出a时，程序会首先在局部作用域中查找a，在这个函数中，程序找到了变量a，故不会继续沿着作用域链向上查找，但是这里的a只声明了并没有进行初始化，故默认为undefined。\n\n4. 接下来，看一下下面的代码会输出什么\n\n\t\tvar a = 1;\n\t\tfunction test2(){\n\t\t  console.log(a);\n\t\t}\n\t\tfunction test1() {\n\t\t  var a = 2;\n\t\t  test2();\n\t\t}\n\t\ttest1();\n输出的是1 ，为什么呢，我们要清楚，在test1中，我们只是让test2函数执行了，而test2仍在全局环境中，并不是test1的局部环境，故test2根本不会访问到位于test1局部环境中的a。\n\n5. 对4中的代码进行修改，我们来看一下将test2定义在test1中的情况\n\n\t\tvar a = 1;\n\t\tfunction test1() {\n\t\t  var a = 2;\n\t\t  function test2(){\n\t\t    console.log(a);\n\t\t  }\n\t\t  test2();\n\t\t}\n\t\ttest1();\n这样一来，test2在test1的局部环境中，a自然就会输出2。\n\n6. 接下来我们来看看对象中的方法\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(a);\n\t\t   }\n\t\t}\n\t\tb.show();  //=>1\n单纯的这样看这段代码为什么会输出1可能会不太明显，但是如果稍微转换一下，就很好明白了。\n\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(a);\n\t\t   }\n\t\t}\n其实是相当于\n\n\t\tvar b = {};\n\t\tb.a = 2;\n\t\tb.show = function(){\n\t\t  console.log(a);\n\t\t}\n这样很明显就看出a应该是全局环境中的a了.\n\n7. 与上面例子类似的，看下面的代码：\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(this.a);\n\t\t   }\n\t\t}\n\t\tb.show();  //=>2\n上面是经常使用的，定义对象的方式，使用了this关键字，将a与当前的执行对象绑定，输出的是当前执行对象的a属性，故输出2.\n\n8. 再继续对上面的例子进行变形\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(this.a);\n\t\t   }\n\t\t}\n\t\tvar c = b.show;\n\t\tc();  //=> 1\n这里是个比较容易出问题的地方，需要注意的是，this指向的是执行时的当前对象，在上个例子中，直接调用b.show()，show方法的执行环境是b，故输出的是b.a,但是在这个例子中，c指向的是function(){console.log(this.a)}，相当于你在全局环境中定义c\n\n\t\tvar c = function(){\n\t\t  console.log(this.a);\n\t\t}\n这里c的执行环境是全局环境，故应输出window.a。\n关于this的指向的问题，请参看http://slygg.cn/2016/07/17/this/","source":"_posts/javascript作用域.md","raw":"---\ntitle: javascript作用域\ndate: 2016-07-31 14:35:58\ntags: \n  - javascript\n  - 作用域\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n在此篇文章中，针对变量的作用域，执行环境等问题，通过一些小demo进行了对比分析\n我们来看下面的几个小例子\n<!-- more -->\n\n1. 首先来个最简单的：\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>1\n这个程序输出1肯定没什么问题了，函数局部作用域内没有局部变量a，因此沿着作用域链向上查找，找到了全局变量a，于是输出。\n\n2. 接下来添加个局部变量：\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  var a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>2\n这段程序输出2，因为沿着作用域链向上查找时，首先找到的是局部变量a是2，于是将2输出.\n\n3. 继续变形\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  console.log(a);\n\t\t  var a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();   //=>undefined 2\n这时第一个console.log(a)输出undefined，第二个输出2，第二个其实不难理解，但是有可能有人不能理解第一个为什么会输出undefined。其实主要是变量声明提升（javascript引擎在执行时，会把所有的变量的声明都提升到当前作用域的最前端）的问题，即上面的代码相当于\n\n\t\tvar a = 1;\n\t\tfunction test1(){\n\t\t  var a;\n\t\t  console.log(a);\n\t\t  a = 2;\n\t\t  console.log(a);\n\t\t}\n\t\ttest1();\n这时，当第一次要输出a时，程序会首先在局部作用域中查找a，在这个函数中，程序找到了变量a，故不会继续沿着作用域链向上查找，但是这里的a只声明了并没有进行初始化，故默认为undefined。\n\n4. 接下来，看一下下面的代码会输出什么\n\n\t\tvar a = 1;\n\t\tfunction test2(){\n\t\t  console.log(a);\n\t\t}\n\t\tfunction test1() {\n\t\t  var a = 2;\n\t\t  test2();\n\t\t}\n\t\ttest1();\n输出的是1 ，为什么呢，我们要清楚，在test1中，我们只是让test2函数执行了，而test2仍在全局环境中，并不是test1的局部环境，故test2根本不会访问到位于test1局部环境中的a。\n\n5. 对4中的代码进行修改，我们来看一下将test2定义在test1中的情况\n\n\t\tvar a = 1;\n\t\tfunction test1() {\n\t\t  var a = 2;\n\t\t  function test2(){\n\t\t    console.log(a);\n\t\t  }\n\t\t  test2();\n\t\t}\n\t\ttest1();\n这样一来，test2在test1的局部环境中，a自然就会输出2。\n\n6. 接下来我们来看看对象中的方法\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(a);\n\t\t   }\n\t\t}\n\t\tb.show();  //=>1\n单纯的这样看这段代码为什么会输出1可能会不太明显，但是如果稍微转换一下，就很好明白了。\n\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(a);\n\t\t   }\n\t\t}\n其实是相当于\n\n\t\tvar b = {};\n\t\tb.a = 2;\n\t\tb.show = function(){\n\t\t  console.log(a);\n\t\t}\n这样很明显就看出a应该是全局环境中的a了.\n\n7. 与上面例子类似的，看下面的代码：\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(this.a);\n\t\t   }\n\t\t}\n\t\tb.show();  //=>2\n上面是经常使用的，定义对象的方式，使用了this关键字，将a与当前的执行对象绑定，输出的是当前执行对象的a属性，故输出2.\n\n8. 再继续对上面的例子进行变形\n\n\t\tvar a = 1;\n\t\tvar b = {\n\t\t    a: \t2,\n\t\t    show:function(){\n\t\t\tconsole.log(this.a);\n\t\t   }\n\t\t}\n\t\tvar c = b.show;\n\t\tc();  //=> 1\n这里是个比较容易出问题的地方，需要注意的是，this指向的是执行时的当前对象，在上个例子中，直接调用b.show()，show方法的执行环境是b，故输出的是b.a,但是在这个例子中，c指向的是function(){console.log(this.a)}，相当于你在全局环境中定义c\n\n\t\tvar c = function(){\n\t\t  console.log(this.a);\n\t\t}\n这里c的执行环境是全局环境，故应输出window.a。\n关于this的指向的问题，请参看http://slygg.cn/2016/07/17/this/","slug":"javascript作用域","published":1,"updated":"2016-07-31T06:39:49.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmmk00301kvsh7h54gbl","content":"<p>在此篇文章中，针对变量的作用域，执行环境等问题，通过一些小demo进行了对比分析<br>我们来看下面的几个小例子<br><a id=\"more\"></a></p>\n<ol>\n<li><p>首先来个最简单的：</p>\n<pre><code>var a = 1;\nfunction test1(){\n  console.log(a);\n}\ntest1();   //=&gt;1\n</code></pre><p>这个程序输出1肯定没什么问题了，函数局部作用域内没有局部变量a，因此沿着作用域链向上查找，找到了全局变量a，于是输出。</p>\n</li>\n<li><p>接下来添加个局部变量：</p>\n<pre><code>var a = 1;\nfunction test1(){\n  var a = 2;\n  console.log(a);\n}\ntest1();   //=&gt;2\n</code></pre><p>这段程序输出2，因为沿着作用域链向上查找时，首先找到的是局部变量a是2，于是将2输出.</p>\n</li>\n<li><p>继续变形</p>\n<pre><code>var a = 1;\nfunction test1(){\n  console.log(a);\n  var a = 2;\n  console.log(a);\n}\ntest1();   //=&gt;undefined 2\n</code></pre><p>这时第一个console.log(a)输出undefined，第二个输出2，第二个其实不难理解，但是有可能有人不能理解第一个为什么会输出undefined。其实主要是变量声明提升（javascript引擎在执行时，会把所有的变量的声明都提升到当前作用域的最前端）的问题，即上面的代码相当于</p>\n<pre><code>var a = 1;\nfunction test1(){\n  var a;\n  console.log(a);\n  a = 2;\n  console.log(a);\n}\ntest1();\n</code></pre><p>这时，当第一次要输出a时，程序会首先在局部作用域中查找a，在这个函数中，程序找到了变量a，故不会继续沿着作用域链向上查找，但是这里的a只声明了并没有进行初始化，故默认为undefined。</p>\n</li>\n<li><p>接下来，看一下下面的代码会输出什么</p>\n<pre><code>var a = 1;\nfunction test2(){\n  console.log(a);\n}\nfunction test1() {\n  var a = 2;\n  test2();\n}\ntest1();\n</code></pre><p>输出的是1 ，为什么呢，我们要清楚，在test1中，我们只是让test2函数执行了，而test2仍在全局环境中，并不是test1的局部环境，故test2根本不会访问到位于test1局部环境中的a。</p>\n</li>\n<li><p>对4中的代码进行修改，我们来看一下将test2定义在test1中的情况</p>\n<pre><code>var a = 1;\nfunction test1() {\n  var a = 2;\n  function test2(){\n    console.log(a);\n  }\n  test2();\n}\ntest1();\n</code></pre><p>这样一来，test2在test1的局部环境中，a自然就会输出2。</p>\n</li>\n<li><p>接下来我们来看看对象中的方法</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(a);\n   }\n}\nb.show();  //=&gt;1\n</code></pre><p>单纯的这样看这段代码为什么会输出1可能会不太明显，但是如果稍微转换一下，就很好明白了。</p>\n<pre><code>var b = {\n    a:     2,\n    show:function(){\n    console.log(a);\n   }\n}\n</code></pre><p>其实是相当于</p>\n<pre><code>var b = {};\nb.a = 2;\nb.show = function(){\n  console.log(a);\n}\n</code></pre><p>这样很明显就看出a应该是全局环境中的a了.</p>\n</li>\n<li><p>与上面例子类似的，看下面的代码：</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(this.a);\n   }\n}\nb.show();  //=&gt;2\n</code></pre><p>上面是经常使用的，定义对象的方式，使用了this关键字，将a与当前的执行对象绑定，输出的是当前执行对象的a属性，故输出2.</p>\n</li>\n<li><p>再继续对上面的例子进行变形</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(this.a);\n   }\n}\nvar c = b.show;\nc();  //=&gt; 1\n</code></pre><p>这里是个比较容易出问题的地方，需要注意的是，this指向的是执行时的当前对象，在上个例子中，直接调用b.show()，show方法的执行环境是b，故输出的是b.a,但是在这个例子中，c指向的是function(){console.log(this.a)}，相当于你在全局环境中定义c</p>\n<pre><code>var c = function(){\n  console.log(this.a);\n}\n</code></pre><p>这里c的执行环境是全局环境，故应输出window.a。<br>关于this的指向的问题，请参看<a href=\"http://slygg.cn/2016/07/17/this/\" target=\"_blank\" rel=\"external\">http://slygg.cn/2016/07/17/this/</a></p>\n</li>\n</ol>\n","excerpt":"<p>在此篇文章中，针对变量的作用域，执行环境等问题，通过一些小demo进行了对比分析<br>我们来看下面的几个小例子<br>","more":"</p>\n<ol>\n<li><p>首先来个最简单的：</p>\n<pre><code>var a = 1;\nfunction test1(){\n  console.log(a);\n}\ntest1();   //=&gt;1\n</code></pre><p>这个程序输出1肯定没什么问题了，函数局部作用域内没有局部变量a，因此沿着作用域链向上查找，找到了全局变量a，于是输出。</p>\n</li>\n<li><p>接下来添加个局部变量：</p>\n<pre><code>var a = 1;\nfunction test1(){\n  var a = 2;\n  console.log(a);\n}\ntest1();   //=&gt;2\n</code></pre><p>这段程序输出2，因为沿着作用域链向上查找时，首先找到的是局部变量a是2，于是将2输出.</p>\n</li>\n<li><p>继续变形</p>\n<pre><code>var a = 1;\nfunction test1(){\n  console.log(a);\n  var a = 2;\n  console.log(a);\n}\ntest1();   //=&gt;undefined 2\n</code></pre><p>这时第一个console.log(a)输出undefined，第二个输出2，第二个其实不难理解，但是有可能有人不能理解第一个为什么会输出undefined。其实主要是变量声明提升（javascript引擎在执行时，会把所有的变量的声明都提升到当前作用域的最前端）的问题，即上面的代码相当于</p>\n<pre><code>var a = 1;\nfunction test1(){\n  var a;\n  console.log(a);\n  a = 2;\n  console.log(a);\n}\ntest1();\n</code></pre><p>这时，当第一次要输出a时，程序会首先在局部作用域中查找a，在这个函数中，程序找到了变量a，故不会继续沿着作用域链向上查找，但是这里的a只声明了并没有进行初始化，故默认为undefined。</p>\n</li>\n<li><p>接下来，看一下下面的代码会输出什么</p>\n<pre><code>var a = 1;\nfunction test2(){\n  console.log(a);\n}\nfunction test1() {\n  var a = 2;\n  test2();\n}\ntest1();\n</code></pre><p>输出的是1 ，为什么呢，我们要清楚，在test1中，我们只是让test2函数执行了，而test2仍在全局环境中，并不是test1的局部环境，故test2根本不会访问到位于test1局部环境中的a。</p>\n</li>\n<li><p>对4中的代码进行修改，我们来看一下将test2定义在test1中的情况</p>\n<pre><code>var a = 1;\nfunction test1() {\n  var a = 2;\n  function test2(){\n    console.log(a);\n  }\n  test2();\n}\ntest1();\n</code></pre><p>这样一来，test2在test1的局部环境中，a自然就会输出2。</p>\n</li>\n<li><p>接下来我们来看看对象中的方法</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(a);\n   }\n}\nb.show();  //=&gt;1\n</code></pre><p>单纯的这样看这段代码为什么会输出1可能会不太明显，但是如果稍微转换一下，就很好明白了。</p>\n<pre><code>var b = {\n    a:     2,\n    show:function(){\n    console.log(a);\n   }\n}\n</code></pre><p>其实是相当于</p>\n<pre><code>var b = {};\nb.a = 2;\nb.show = function(){\n  console.log(a);\n}\n</code></pre><p>这样很明显就看出a应该是全局环境中的a了.</p>\n</li>\n<li><p>与上面例子类似的，看下面的代码：</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(this.a);\n   }\n}\nb.show();  //=&gt;2\n</code></pre><p>上面是经常使用的，定义对象的方式，使用了this关键字，将a与当前的执行对象绑定，输出的是当前执行对象的a属性，故输出2.</p>\n</li>\n<li><p>再继续对上面的例子进行变形</p>\n<pre><code>var a = 1;\nvar b = {\n    a:     2,\n    show:function(){\n    console.log(this.a);\n   }\n}\nvar c = b.show;\nc();  //=&gt; 1\n</code></pre><p>这里是个比较容易出问题的地方，需要注意的是，this指向的是执行时的当前对象，在上个例子中，直接调用b.show()，show方法的执行环境是b，故输出的是b.a,但是在这个例子中，c指向的是function(){console.log(this.a)}，相当于你在全局环境中定义c</p>\n<pre><code>var c = function(){\n  console.log(this.a);\n}\n</code></pre><p>这里c的执行环境是全局环境，故应输出window.a。<br>关于this的指向的问题，请参看<a href=\"http://slygg.cn/2016/07/17/this/\">http://slygg.cn/2016/07/17/this/</a></p>\n</li>\n</ol>"},{"title":"关门山","date":"2014-10-18T13:18:35.000Z","_content":"刚刚忽然发现这个网站里面都是学习的记录，好无聊呀，为了使网站内容更丰富些，在次添加几张14年去关门山旅游的照片，虽然去的时候枫叶都落没了，不过其他的景色还是蛮漂亮的，主要是玩的也很开心呀，哈哈哈~ 下面上图\n<!--more-->\n![照片一](/img/1.jpg)\n![照片二](/img/2.jpg)\n![照片三](/img/3.jpg)\n![照片四](/img/4.jpg)\n\n这次只是选了几张照片，只是为了点缀，等以后再出去玩的，在好好发些。","source":"_posts/关门山.md","raw":"---\ntitle: 关门山\ndate: 2014-10-18 21:18:35\ntags: \n  - 旅游日记\ncategories:\n  - 随手日记\n---\n刚刚忽然发现这个网站里面都是学习的记录，好无聊呀，为了使网站内容更丰富些，在次添加几张14年去关门山旅游的照片，虽然去的时候枫叶都落没了，不过其他的景色还是蛮漂亮的，主要是玩的也很开心呀，哈哈哈~ 下面上图\n<!--more-->\n![照片一](/img/1.jpg)\n![照片二](/img/2.jpg)\n![照片三](/img/3.jpg)\n![照片四](/img/4.jpg)\n\n这次只是选了几张照片，只是为了点缀，等以后再出去玩的，在好好发些。","slug":"关门山","published":1,"updated":"2016-05-05T13:38:13.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmmk00341kvssg7dpew1","content":"<p>刚刚忽然发现这个网站里面都是学习的记录，好无聊呀，为了使网站内容更丰富些，在次添加几张14年去关门山旅游的照片，虽然去的时候枫叶都落没了，不过其他的景色还是蛮漂亮的，主要是玩的也很开心呀，哈哈哈~ 下面上图<br><a id=\"more\"></a><br><img src=\"/img/1.jpg\" alt=\"照片一\"><br><img src=\"/img/2.jpg\" alt=\"照片二\"><br><img src=\"/img/3.jpg\" alt=\"照片三\"><br><img src=\"/img/4.jpg\" alt=\"照片四\"></p>\n<p>这次只是选了几张照片，只是为了点缀，等以后再出去玩的，在好好发些。</p>\n","excerpt":"<p>刚刚忽然发现这个网站里面都是学习的记录，好无聊呀，为了使网站内容更丰富些，在次添加几张14年去关门山旅游的照片，虽然去的时候枫叶都落没了，不过其他的景色还是蛮漂亮的，主要是玩的也很开心呀，哈哈哈~ 下面上图<br>","more":"<br><img src=\"/img/1.jpg\" alt=\"照片一\"><br><img src=\"/img/2.jpg\" alt=\"照片二\"><br><img src=\"/img/3.jpg\" alt=\"照片三\"><br><img src=\"/img/4.jpg\" alt=\"照片四\"></p>\n<p>这次只是选了几张照片，只是为了点缀，等以后再出去玩的，在好好发些。</p>"},{"title":"doctype","date":"2016-09-07T14:48:56.000Z","_content":"## 关于doctype的一些知识\n\n1. <!DOCTYPE>声明必须位于文档的第一行，位于<html>之前\n2. <!DOCTYPE>不是html的标签，是指示web浏览器关于页面使用哪个HTML版本进行编写的指令\n3. 在 HTML 4.01 中，<!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。\n4. HTML5 不基于 SGML，所以不需要引用 DTD。\n5. <!DOCTYPE> 声明没有结束标签。\n6. <!DOCTYPE> 声明对大小写不敏感。\n<!-- more -->\n\n## 常见的DOCTYPE类型\nhtml 5\n&lt;!DOCTYPE html>\nhtml 4.01\nstrict \nframeset\ntraditional\nxhtml 1.0\nstrict \nframeset\ntraditional","source":"_posts/doctype.md","raw":"---\ntitle: doctype\ndate: 2016-09-07 22:48:56\ntags:\n  -html\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n## 关于doctype的一些知识\n\n1. <!DOCTYPE>声明必须位于文档的第一行，位于<html>之前\n2. <!DOCTYPE>不是html的标签，是指示web浏览器关于页面使用哪个HTML版本进行编写的指令\n3. 在 HTML 4.01 中，<!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。\n4. HTML5 不基于 SGML，所以不需要引用 DTD。\n5. <!DOCTYPE> 声明没有结束标签。\n6. <!DOCTYPE> 声明对大小写不敏感。\n<!-- more -->\n\n## 常见的DOCTYPE类型\nhtml 5\n&lt;!DOCTYPE html>\nhtml 4.01\nstrict \nframeset\ntraditional\nxhtml 1.0\nstrict \nframeset\ntraditional","slug":"doctype","published":1,"updated":"2016-09-07T16:05:41.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmmk00361kvso0mqs34a","content":"<h2 id=\"关于doctype的一些知识\"><a href=\"#关于doctype的一些知识\" class=\"headerlink\" title=\"关于doctype的一些知识\"></a>关于doctype的一些知识</h2><ol>\n<li>&lt;!DOCTYPE&gt;声明必须位于文档的第一行，位于<html>之前</html></li>\n<li>&lt;!DOCTYPE&gt;不是html的标签，是指示web浏览器关于页面使用哪个HTML版本进行编写的指令</li>\n<li>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</li>\n<li>HTML5 不基于 SGML，所以不需要引用 DTD。</li>\n<li>&lt;!DOCTYPE&gt; 声明没有结束标签。</li>\n<li>&lt;!DOCTYPE&gt; 声明对大小写不敏感。<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"常见的DOCTYPE类型\"><a href=\"#常见的DOCTYPE类型\" class=\"headerlink\" title=\"常见的DOCTYPE类型\"></a>常见的DOCTYPE类型</h2><p>html 5<br>&lt;!DOCTYPE html&gt;<br>html 4.01<br>strict<br>frameset<br>traditional<br>xhtml 1.0<br>strict<br>frameset<br>traditional</p>\n","excerpt":"<h2 id=\"关于doctype的一些知识\"><a href=\"#关于doctype的一些知识\" class=\"headerlink\" title=\"关于doctype的一些知识\"></a>关于doctype的一些知识</h2><ol>\n<li>&lt;!DOCTYPE&gt;声明必须位于文档的第一行，位于<html>之前</li>\n<li>&lt;!DOCTYPE&gt;不是html的标签，是指示web浏览器关于页面使用哪个HTML版本进行编写的指令</li>\n<li>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。</li>\n<li>HTML5 不基于 SGML，所以不需要引用 DTD。</li>\n<li>&lt;!DOCTYPE&gt; 声明没有结束标签。</li>\n<li>&lt;!DOCTYPE&gt; 声明对大小写不敏感。","more":"</li>\n</ol>\n<h2 id=\"常见的DOCTYPE类型\"><a href=\"#常见的DOCTYPE类型\" class=\"headerlink\" title=\"常见的DOCTYPE类型\"></a>常见的DOCTYPE类型</h2><p>html 5<br>&lt;!DOCTYPE html&gt;<br>html 4.01<br>strict<br>frameset<br>traditional<br>xhtml 1.0<br>strict<br>frameset<br>traditional</p>"},{"title":"数据库学习笔记（一）","date":"2016-05-24T02:02:24.000Z","_content":"# 基本概念\n1. 数据库管理系统和数据库\n   数据库管理系统（DBMS）是由一个互联相关的数据的集合和一组用以访问这些数据的程序组成。一个数据集合称作数据库。DBMS的主要目标是要提供一个可以方便、高效地存取数据库信息的环境。\n   <!-- more -->\n2. 数据视图\n   数据库系统是一些互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合。数据库系统的一个主要目的是给用户提供一个数据的抽象视图，即系统隐藏关于数据存储和维护的某些细节。\n3. 数据抽象\n系统开发人员通过以下几个层次的抽象来对用户屏蔽复杂性：\n3.1 物理层：最低层次的抽象，描述数据实际上是怎么存储的。（数据是如何存储的，编译器为开发人员屏蔽了这一层的细节，就像java中对象是如何存储的一样）\n3.2 逻辑层：描述数据库中存储什么数据及这些数据间存在什么关系。（通过sql语言描述的，像java中类的定义）\n3.3 视图层：最高层次的抽象，只描述数据库的一部分，系统为同一数据库提供多个视图。（数据选择呈现）\n4. 实例和模式\n特定时刻存储在数据库中的信息的集合称作数据库的一个实例。而数据库的总体设计称作数据库模式。（对比java中的对象与类）\n数据库系统可以分为几种不同的模式，物理模式在物理层描述了数据库的设计，逻辑模式在逻辑层描述数据库的设计。数据库在视图层也可以分为几种模式，有时称为子模式，它描述了数据库的不同视图。\n5. 数据模型\n5.1 数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念的工具。数据模型提供了一种物理层、逻辑层以及视图层数据库的设计方式。\n5.2 数据模型可以被分为四类\n（1）关系模型（表的集合来表示数据与数据之间的关系）\n（2）实体连续模型\n（3）基于对象数据模型\n（4）半结构化数据模型\n\n# 数据库语言\n1. 数据库操纵语言（DML）\n1.1 过程化DML 要求用户指定需要什么数据以及如何获取这些数据\n1.2 声明式DML 只要求用户指定需要什么数据，不需要指定如何获取\n2. 数据库描述语言（DDL）\n数据库模式是通过一系列的定义来说明的，这些定义由一种称作数据定义语言（DDL）的特殊语言来表达。\n2.1 一致性约束\n\t2.1.1 域约束\n\t2.1.2 参照完整性\n\t2.1.3 断言。域约束和参照完整性约束是断言的特殊形式。\n\t2.1.4 授权\n2.2 数据字典\nDDL的输出放到数据字典中，数据字典包含了元数据，元数据是关于数据的数据。","source":"_posts/数据库.md","raw":"---\ntitle: 数据库学习笔记（一）\ndate: 2016-05-24 10:02:24\ntags: \n  - 数据库\ncategories:\n  - 学习笔记\n  - 数据库\n---\n# 基本概念\n1. 数据库管理系统和数据库\n   数据库管理系统（DBMS）是由一个互联相关的数据的集合和一组用以访问这些数据的程序组成。一个数据集合称作数据库。DBMS的主要目标是要提供一个可以方便、高效地存取数据库信息的环境。\n   <!-- more -->\n2. 数据视图\n   数据库系统是一些互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合。数据库系统的一个主要目的是给用户提供一个数据的抽象视图，即系统隐藏关于数据存储和维护的某些细节。\n3. 数据抽象\n系统开发人员通过以下几个层次的抽象来对用户屏蔽复杂性：\n3.1 物理层：最低层次的抽象，描述数据实际上是怎么存储的。（数据是如何存储的，编译器为开发人员屏蔽了这一层的细节，就像java中对象是如何存储的一样）\n3.2 逻辑层：描述数据库中存储什么数据及这些数据间存在什么关系。（通过sql语言描述的，像java中类的定义）\n3.3 视图层：最高层次的抽象，只描述数据库的一部分，系统为同一数据库提供多个视图。（数据选择呈现）\n4. 实例和模式\n特定时刻存储在数据库中的信息的集合称作数据库的一个实例。而数据库的总体设计称作数据库模式。（对比java中的对象与类）\n数据库系统可以分为几种不同的模式，物理模式在物理层描述了数据库的设计，逻辑模式在逻辑层描述数据库的设计。数据库在视图层也可以分为几种模式，有时称为子模式，它描述了数据库的不同视图。\n5. 数据模型\n5.1 数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念的工具。数据模型提供了一种物理层、逻辑层以及视图层数据库的设计方式。\n5.2 数据模型可以被分为四类\n（1）关系模型（表的集合来表示数据与数据之间的关系）\n（2）实体连续模型\n（3）基于对象数据模型\n（4）半结构化数据模型\n\n# 数据库语言\n1. 数据库操纵语言（DML）\n1.1 过程化DML 要求用户指定需要什么数据以及如何获取这些数据\n1.2 声明式DML 只要求用户指定需要什么数据，不需要指定如何获取\n2. 数据库描述语言（DDL）\n数据库模式是通过一系列的定义来说明的，这些定义由一种称作数据定义语言（DDL）的特殊语言来表达。\n2.1 一致性约束\n\t2.1.1 域约束\n\t2.1.2 参照完整性\n\t2.1.3 断言。域约束和参照完整性约束是断言的特殊形式。\n\t2.1.4 授权\n2.2 数据字典\nDDL的输出放到数据字典中，数据字典包含了元数据，元数据是关于数据的数据。","slug":"数据库","published":1,"updated":"2016-05-24T13:20:55.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmmz003a1kvsheu9tze3","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>数据库管理系统和数据库<br>数据库管理系统（DBMS）是由一个互联相关的数据的集合和一组用以访问这些数据的程序组成。一个数据集合称作数据库。DBMS的主要目标是要提供一个可以方便、高效地存取数据库信息的环境。<a id=\"more\"></a></li>\n<li>数据视图<br>数据库系统是一些互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合。数据库系统的一个主要目的是给用户提供一个数据的抽象视图，即系统隐藏关于数据存储和维护的某些细节。</li>\n<li>数据抽象<br>系统开发人员通过以下几个层次的抽象来对用户屏蔽复杂性：<br>3.1 物理层：最低层次的抽象，描述数据实际上是怎么存储的。（数据是如何存储的，编译器为开发人员屏蔽了这一层的细节，就像java中对象是如何存储的一样）<br>3.2 逻辑层：描述数据库中存储什么数据及这些数据间存在什么关系。（通过sql语言描述的，像java中类的定义）<br>3.3 视图层：最高层次的抽象，只描述数据库的一部分，系统为同一数据库提供多个视图。（数据选择呈现）</li>\n<li>实例和模式<br>特定时刻存储在数据库中的信息的集合称作数据库的一个实例。而数据库的总体设计称作数据库模式。（对比java中的对象与类）<br>数据库系统可以分为几种不同的模式，物理模式在物理层描述了数据库的设计，逻辑模式在逻辑层描述数据库的设计。数据库在视图层也可以分为几种模式，有时称为子模式，它描述了数据库的不同视图。</li>\n<li>数据模型<br>5.1 数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念的工具。数据模型提供了一种物理层、逻辑层以及视图层数据库的设计方式。<br>5.2 数据模型可以被分为四类<br>（1）关系模型（表的集合来表示数据与数据之间的关系）<br>（2）实体连续模型<br>（3）基于对象数据模型<br>（4）半结构化数据模型</li>\n</ol>\n<h1 id=\"数据库语言\"><a href=\"#数据库语言\" class=\"headerlink\" title=\"数据库语言\"></a>数据库语言</h1><ol>\n<li>数据库操纵语言（DML）<br>1.1 过程化DML 要求用户指定需要什么数据以及如何获取这些数据<br>1.2 声明式DML 只要求用户指定需要什么数据，不需要指定如何获取</li>\n<li>数据库描述语言（DDL）<br>数据库模式是通过一系列的定义来说明的，这些定义由一种称作数据定义语言（DDL）的特殊语言来表达。<br>2.1 一致性约束<br> 2.1.1 域约束<br> 2.1.2 参照完整性<br> 2.1.3 断言。域约束和参照完整性约束是断言的特殊形式。<br> 2.1.4 授权<br>2.2 数据字典<br>DDL的输出放到数据字典中，数据字典包含了元数据，元数据是关于数据的数据。</li>\n</ol>\n","excerpt":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>数据库管理系统和数据库<br>数据库管理系统（DBMS）是由一个互联相关的数据的集合和一组用以访问这些数据的程序组成。一个数据集合称作数据库。DBMS的主要目标是要提供一个可以方便、高效地存取数据库信息的环境。","more":"</li>\n<li>数据视图<br>数据库系统是一些互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合。数据库系统的一个主要目的是给用户提供一个数据的抽象视图，即系统隐藏关于数据存储和维护的某些细节。</li>\n<li>数据抽象<br>系统开发人员通过以下几个层次的抽象来对用户屏蔽复杂性：<br>3.1 物理层：最低层次的抽象，描述数据实际上是怎么存储的。（数据是如何存储的，编译器为开发人员屏蔽了这一层的细节，就像java中对象是如何存储的一样）<br>3.2 逻辑层：描述数据库中存储什么数据及这些数据间存在什么关系。（通过sql语言描述的，像java中类的定义）<br>3.3 视图层：最高层次的抽象，只描述数据库的一部分，系统为同一数据库提供多个视图。（数据选择呈现）</li>\n<li>实例和模式<br>特定时刻存储在数据库中的信息的集合称作数据库的一个实例。而数据库的总体设计称作数据库模式。（对比java中的对象与类）<br>数据库系统可以分为几种不同的模式，物理模式在物理层描述了数据库的设计，逻辑模式在逻辑层描述数据库的设计。数据库在视图层也可以分为几种模式，有时称为子模式，它描述了数据库的不同视图。</li>\n<li>数据模型<br>5.1 数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念的工具。数据模型提供了一种物理层、逻辑层以及视图层数据库的设计方式。<br>5.2 数据模型可以被分为四类<br>（1）关系模型（表的集合来表示数据与数据之间的关系）<br>（2）实体连续模型<br>（3）基于对象数据模型<br>（4）半结构化数据模型</li>\n</ol>\n<h1 id=\"数据库语言\"><a href=\"#数据库语言\" class=\"headerlink\" title=\"数据库语言\"></a>数据库语言</h1><ol>\n<li>数据库操纵语言（DML）<br>1.1 过程化DML 要求用户指定需要什么数据以及如何获取这些数据<br>1.2 声明式DML 只要求用户指定需要什么数据，不需要指定如何获取</li>\n<li>数据库描述语言（DDL）<br>数据库模式是通过一系列的定义来说明的，这些定义由一种称作数据定义语言（DDL）的特殊语言来表达。<br>2.1 一致性约束<br> 2.1.1 域约束<br> 2.1.2 参照完整性<br> 2.1.3 断言。域约束和参照完整性约束是断言的特殊形式。<br> 2.1.4 授权<br>2.2 数据字典<br>DDL的输出放到数据字典中，数据字典包含了元数据，元数据是关于数据的数据。</li>\n</ol>"},{"title":".gitignore配置","date":"2016-04-27T14:37:18.000Z","_content":"  首先，windows下，在根目录下创建一个文件***.gitignore.***,注意末尾还有个点。但是保存之后系统会自动重命名为***.gitignore。这个文件创建的目的就是告诉Git哪些文件不需要被添加到版本管理中。下面简要介绍下文件的配置规则：\n  <!-- more -->\n  1. 以斜杠“/”开头表示目录；\n  2. 以星号“*”通配多个字符；\n  3. 以问号“?”通配单个字符\n  4. 以方括号“[]”包含单个字符的匹配列表；\n  5. 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n","source":"_posts/gitignore配置.md","raw":"---\ntitle: .gitignore配置\ndate: 2016-04-27 22:37:18\ntags: \n  - git\n  - gitignore配置\ncategories:\n  - 学习笔记\n  - git学习\n---\n  首先，windows下，在根目录下创建一个文件***.gitignore.***,注意末尾还有个点。但是保存之后系统会自动重命名为***.gitignore。这个文件创建的目的就是告诉Git哪些文件不需要被添加到版本管理中。下面简要介绍下文件的配置规则：\n  <!-- more -->\n  1. 以斜杠“/”开头表示目录；\n  2. 以星号“*”通配多个字符；\n  3. 以问号“?”通配单个字符\n  4. 以方括号“[]”包含单个字符的匹配列表；\n  5. 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n","slug":"gitignore配置","published":1,"updated":"2016-05-05T14:39:35.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmmz003d1kvsodo875qd","content":"<p>  首先，windows下，在根目录下创建一个文件<strong><em>.gitignore.</em></strong>,注意末尾还有个点。但是保存之后系统会自动重命名为<em>*</em>.gitignore。这个文件创建的目的就是告诉Git哪些文件不需要被添加到版本管理中。下面简要介绍下文件的配置规则：<br>  <a id=\"more\"></a></p>\n<ol>\n<li>以斜杠“/”开头表示目录；</li>\n<li>以星号“*”通配多个字符；</li>\n<li>以问号“?”通配单个字符</li>\n<li>以方括号“[]”包含单个字符的匹配列表；</li>\n<li>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</li>\n</ol>\n","excerpt":"<p>  首先，windows下，在根目录下创建一个文件<strong><em>.gitignore.</em></strong>,注意末尾还有个点。但是保存之后系统会自动重命名为<em>*</em>.gitignore。这个文件创建的目的就是告诉Git哪些文件不需要被添加到版本管理中。下面简要介绍下文件的配置规则：<br>","more":"</p>\n<ol>\n<li>以斜杠“/”开头表示目录；</li>\n<li>以星号“*”通配多个字符；</li>\n<li>以问号“?”通配单个字符</li>\n<li>以方括号“[]”包含单个字符的匹配列表；</li>\n<li>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</li>\n</ol>"},{"title":"正则表达式","date":"2016-07-28T07:18:00.000Z","_content":"关于正则表达式的文章\nhttp://www.haorooms.com/post/js_regex_refuse","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2016-07-28 15:18:00\ntags:\n---\n关于正则表达式的文章\nhttp://www.haorooms.com/post/js_regex_refuse","slug":"正则表达式","published":1,"updated":"2016-07-28T13:15:11.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnf003h1kvs79wkiuvd","content":"<p>关于正则表达式的文章<br><a href=\"http://www.haorooms.com/post/js_regex_refuse\" target=\"_blank\" rel=\"external\">http://www.haorooms.com/post/js_regex_refuse</a></p>\n","excerpt":"","more":"<p>关于正则表达式的文章<br><a href=\"http://www.haorooms.com/post/js_regex_refuse\">http://www.haorooms.com/post/js_regex_refuse</a></p>\n"},{"title":"css3中transition用法总结","date":"2016-05-05T05:33:54.000Z","_content":"\n以下内容主要出自《图解CSS3-大漠》\n\n### W3C标准中对transition的描述\nCSS3的transition允许css的属性值在一定的时间区间内平滑的过渡。这种效果可以在鼠标单击，获得焦点，被点击或者对元素的任何改变中触发，并平滑地以动画的效果改变css的属性值。\n<!-- more -->\n### css中创建简单过渡的步骤\n  （1）在默认样式中声明元素的初始状态样式\n  （2）声明过渡元素最终状态样式\n  （3）在默认样式中通过添加过渡函数，添加一些不同的样式。 \n### transition属性主要包含四个属性值\n  （1）transition-property：指定过渡或动态模拟的CSS属性\n  （2）transition-duration：指定完成过渡所需的时间\n  （3）transition-timing-function：指定过渡函数\n  （4）transition-delay:指定过渡开始出现的延迟时间\n### 简写形式\n      transition: <property> <duration> <animation type> <delay>\n### 可以使用过渡的属性\n  （1）颜色属性\n  （2）具有长度值，百分比的属性\n  （3）integer\n  （4）number真实的（浮点型）数值\n  （5）变形系列属性。如rotate(),rotate3d(),scale(),scale3d(),skew(),translate(),translate3d()等\n  （6）reactangle：通过x,y,width,height变形\n  （7）visibility：离散步骤，在0~1范围内\n  （8）阴影\n  （9）渐变\n  （10）paint server(SVG)：只支持下面的情况。从gradient到gradient，以及从color到color\n  （11）space-separated list of above：如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化\n  （12）缩写属性\n### 浏览器兼容性\n  （1）IE 10+（PP3）（平台预览第三版），Firefox4.0~15.0，Chrome4.0~\t20.0，Safari3.1~6.0和Opera10.5~12.0，在使用时需要加上各浏览器的私有属性。\n  （2）IE10+，Firefox16.0+，chrome26.0+，Safari 7.0+，Opera 12.1+支持transition的标准语法。\n  （3）ios Safari 3.2~6.1、Android browser2.1+，Blackberry browser7.0+和chrome for Android 27.0需要添加浏览器前缀-webkit-,Opero mobile 10.0~12.0中需要添加浏览器前缀-o-。\n  （4）ios Safari 7.0+和Firefox for Android 22.0支持transition的标准语法。\n### 开关状态的不同过渡方式\n\t\tinput{\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\tborder: 1px solid #CCC;\n\t\t\ttransition: width 1s;\n\t\t}\n\t\tinput:focus{\n\t\t\twidth: 300px;\n\t\t}\n这样当input获得焦点时和失去焦点时，input宽度的变化都是在1秒内完成的。\n但是如果像下面这样写\n\n\t\tinput{\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\tborder: 1px solid #CCC;\n\t\t\ttransition: width .2s;\n\t\t}\n\t\tinput:focus{\n\t\t\twidth: 300px;\n\t\t\ttransition: width 1s;\n\t\t}\n那么当input获得焦点时，宽度从200px变化到300px是在1s内完成的，失去焦点时宽度从300px变回到200px时则是在0.2s内完成的。\n演示见 http://shly.github.io/shly/IFE/task_12/index.html\n### css过渡的触发\n（1）伪元素触发 :active :focus :checked\n（2）媒体查询触发\n（3）JavaScript触发，给元素添加新的类，向新的类添加过渡如\n\n\t\t.box{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tborder:1px solid #000;\n\t\t\ttransition: width 2s;\n\t\t}\n\t\t.box .on{\n\t\t\twidth:200px;\n\t\t}\n### 启用硬件加速使过渡更流畅\n   以下内容引自：<http://www.cnblogs.com/rubylouvre/p/3471490.html>\n   CSS animations, transforms 以及 transitions不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。\n   现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。\n   例如：\n\n\t\t.cube {\n\t\t   -webkit-transform: translate3d(250px,250px,250px)\n\t\t   rotate3d(250px,250px,250px,-120deg)\n\t\t   scale3d(0.5, 0.5, 0.5);\n\t\t}\n可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。\n虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速。\n\n\t\t.cube {\n\t\t   -webkit-transform: translateZ(0);\n\t\t   -moz-transform: translateZ(0);\n\t\t   -ms-transform: translateZ(0);\n\t\t   -o-transform: translateZ(0);\n\t\t   transform: translateZ(0);\n\t\t   /* Other transform properties here */\n\t\t}\n   在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：\n\n\t\t.cube {\n\t\t   -webkit-backface-visibility: hidden;\n\t\t   -moz-backface-visibility: hidden;\n\t\t   -ms-backface-visibility: hidden;\n\t\t   backface-visibility: hidden;\n\t\t \n\t\t   -webkit-perspective: 1000;\n\t\t   -moz-perspective: 1000;\n\t\t   -ms-perspective: 1000;\n\t\t   perspective: 1000;\n\t\t   /* Other transform properties here */\n\t\t}\n   在webkit内核的浏览器中，另一个行之有效的方法是\n\n\t\t.cube {\n\t\t   -webkit-transform: translate3d(0, 0, 0);\n\t\t   -moz-transform: translate3d(0, 0, 0);\n\t\t   -ms-transform: translate3d(0, 0, 0);\n\t\t   transform: translate3d(0, 0, 0);\n\t\t  /* Other transform properties here */\n\t\t}\n原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。\n\n只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。\n小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。","source":"_posts/transition.md","raw":"---\ntitle: css3中transition用法总结\ndate: 2016-05-05 13:33:54\ntags: \n  - css3\n  - css3 transition\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n\n以下内容主要出自《图解CSS3-大漠》\n\n### W3C标准中对transition的描述\nCSS3的transition允许css的属性值在一定的时间区间内平滑的过渡。这种效果可以在鼠标单击，获得焦点，被点击或者对元素的任何改变中触发，并平滑地以动画的效果改变css的属性值。\n<!-- more -->\n### css中创建简单过渡的步骤\n  （1）在默认样式中声明元素的初始状态样式\n  （2）声明过渡元素最终状态样式\n  （3）在默认样式中通过添加过渡函数，添加一些不同的样式。 \n### transition属性主要包含四个属性值\n  （1）transition-property：指定过渡或动态模拟的CSS属性\n  （2）transition-duration：指定完成过渡所需的时间\n  （3）transition-timing-function：指定过渡函数\n  （4）transition-delay:指定过渡开始出现的延迟时间\n### 简写形式\n      transition: <property> <duration> <animation type> <delay>\n### 可以使用过渡的属性\n  （1）颜色属性\n  （2）具有长度值，百分比的属性\n  （3）integer\n  （4）number真实的（浮点型）数值\n  （5）变形系列属性。如rotate(),rotate3d(),scale(),scale3d(),skew(),translate(),translate3d()等\n  （6）reactangle：通过x,y,width,height变形\n  （7）visibility：离散步骤，在0~1范围内\n  （8）阴影\n  （9）渐变\n  （10）paint server(SVG)：只支持下面的情况。从gradient到gradient，以及从color到color\n  （11）space-separated list of above：如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化\n  （12）缩写属性\n### 浏览器兼容性\n  （1）IE 10+（PP3）（平台预览第三版），Firefox4.0~15.0，Chrome4.0~\t20.0，Safari3.1~6.0和Opera10.5~12.0，在使用时需要加上各浏览器的私有属性。\n  （2）IE10+，Firefox16.0+，chrome26.0+，Safari 7.0+，Opera 12.1+支持transition的标准语法。\n  （3）ios Safari 3.2~6.1、Android browser2.1+，Blackberry browser7.0+和chrome for Android 27.0需要添加浏览器前缀-webkit-,Opero mobile 10.0~12.0中需要添加浏览器前缀-o-。\n  （4）ios Safari 7.0+和Firefox for Android 22.0支持transition的标准语法。\n### 开关状态的不同过渡方式\n\t\tinput{\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\tborder: 1px solid #CCC;\n\t\t\ttransition: width 1s;\n\t\t}\n\t\tinput:focus{\n\t\t\twidth: 300px;\n\t\t}\n这样当input获得焦点时和失去焦点时，input宽度的变化都是在1秒内完成的。\n但是如果像下面这样写\n\n\t\tinput{\n\t\t\twidth: 200px;\n\t\t\theight: 20px;\n\t\t\tborder: 1px solid #CCC;\n\t\t\ttransition: width .2s;\n\t\t}\n\t\tinput:focus{\n\t\t\twidth: 300px;\n\t\t\ttransition: width 1s;\n\t\t}\n那么当input获得焦点时，宽度从200px变化到300px是在1s内完成的，失去焦点时宽度从300px变回到200px时则是在0.2s内完成的。\n演示见 http://shly.github.io/shly/IFE/task_12/index.html\n### css过渡的触发\n（1）伪元素触发 :active :focus :checked\n（2）媒体查询触发\n（3）JavaScript触发，给元素添加新的类，向新的类添加过渡如\n\n\t\t.box{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tborder:1px solid #000;\n\t\t\ttransition: width 2s;\n\t\t}\n\t\t.box .on{\n\t\t\twidth:200px;\n\t\t}\n### 启用硬件加速使过渡更流畅\n   以下内容引自：<http://www.cnblogs.com/rubylouvre/p/3471490.html>\n   CSS animations, transforms 以及 transitions不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。\n   现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。\n   例如：\n\n\t\t.cube {\n\t\t   -webkit-transform: translate3d(250px,250px,250px)\n\t\t   rotate3d(250px,250px,250px,-120deg)\n\t\t   scale3d(0.5, 0.5, 0.5);\n\t\t}\n可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。\n虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速。\n\n\t\t.cube {\n\t\t   -webkit-transform: translateZ(0);\n\t\t   -moz-transform: translateZ(0);\n\t\t   -ms-transform: translateZ(0);\n\t\t   -o-transform: translateZ(0);\n\t\t   transform: translateZ(0);\n\t\t   /* Other transform properties here */\n\t\t}\n   在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：\n\n\t\t.cube {\n\t\t   -webkit-backface-visibility: hidden;\n\t\t   -moz-backface-visibility: hidden;\n\t\t   -ms-backface-visibility: hidden;\n\t\t   backface-visibility: hidden;\n\t\t \n\t\t   -webkit-perspective: 1000;\n\t\t   -moz-perspective: 1000;\n\t\t   -ms-perspective: 1000;\n\t\t   perspective: 1000;\n\t\t   /* Other transform properties here */\n\t\t}\n   在webkit内核的浏览器中，另一个行之有效的方法是\n\n\t\t.cube {\n\t\t   -webkit-transform: translate3d(0, 0, 0);\n\t\t   -moz-transform: translate3d(0, 0, 0);\n\t\t   -ms-transform: translate3d(0, 0, 0);\n\t\t   transform: translate3d(0, 0, 0);\n\t\t  /* Other transform properties here */\n\t\t}\n原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。\n\n只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。\n小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。","slug":"transition","published":1,"updated":"2016-05-05T14:37:50.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnf003l1kvsqsmz2z83","content":"<p>以下内容主要出自《图解CSS3-大漠》</p>\n<h3 id=\"W3C标准中对transition的描述\"><a href=\"#W3C标准中对transition的描述\" class=\"headerlink\" title=\"W3C标准中对transition的描述\"></a>W3C标准中对transition的描述</h3><p>CSS3的transition允许css的属性值在一定的时间区间内平滑的过渡。这种效果可以在鼠标单击，获得焦点，被点击或者对元素的任何改变中触发，并平滑地以动画的效果改变css的属性值。<br><a id=\"more\"></a></p>\n<h3 id=\"css中创建简单过渡的步骤\"><a href=\"#css中创建简单过渡的步骤\" class=\"headerlink\" title=\"css中创建简单过渡的步骤\"></a>css中创建简单过渡的步骤</h3><p>  （1）在默认样式中声明元素的初始状态样式<br>  （2）声明过渡元素最终状态样式<br>  （3）在默认样式中通过添加过渡函数，添加一些不同的样式。 </p>\n<h3 id=\"transition属性主要包含四个属性值\"><a href=\"#transition属性主要包含四个属性值\" class=\"headerlink\" title=\"transition属性主要包含四个属性值\"></a>transition属性主要包含四个属性值</h3><p>  （1）transition-property：指定过渡或动态模拟的CSS属性<br>  （2）transition-duration：指定完成过渡所需的时间<br>  （3）transition-timing-function：指定过渡函数<br>  （4）transition-delay:指定过渡开始出现的延迟时间</p>\n<h3 id=\"简写形式\"><a href=\"#简写形式\" class=\"headerlink\" title=\"简写形式\"></a>简写形式</h3><pre><code>transition: &lt;property&gt; &lt;duration&gt; &lt;animation type&gt; &lt;delay&gt;\n</code></pre><h3 id=\"可以使用过渡的属性\"><a href=\"#可以使用过渡的属性\" class=\"headerlink\" title=\"可以使用过渡的属性\"></a>可以使用过渡的属性</h3><p>  （1）颜色属性<br>  （2）具有长度值，百分比的属性<br>  （3）integer<br>  （4）number真实的（浮点型）数值<br>  （5）变形系列属性。如rotate(),rotate3d(),scale(),scale3d(),skew(),translate(),translate3d()等<br>  （6）reactangle：通过x,y,width,height变形<br>  （7）visibility：离散步骤，在0~1范围内<br>  （8）阴影<br>  （9）渐变<br>  （10）paint server(SVG)：只支持下面的情况。从gradient到gradient，以及从color到color<br>  （11）space-separated list of above：如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化<br>  （12）缩写属性</p>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p>  （1）IE 10+（PP3）（平台预览第三版），Firefox4.0~15.0，Chrome4.0~    20.0，Safari3.1~6.0和Opera10.5~12.0，在使用时需要加上各浏览器的私有属性。<br>  （2）IE10+，Firefox16.0+，chrome26.0+，Safari 7.0+，Opera 12.1+支持transition的标准语法。<br>  （3）ios Safari 3.2~6.1、Android browser2.1+，Blackberry browser7.0+和chrome for Android 27.0需要添加浏览器前缀-webkit-,Opero mobile 10.0~12.0中需要添加浏览器前缀-o-。<br>  （4）ios Safari 7.0+和Firefox for Android 22.0支持transition的标准语法。</p>\n<h3 id=\"开关状态的不同过渡方式\"><a href=\"#开关状态的不同过渡方式\" class=\"headerlink\" title=\"开关状态的不同过渡方式\"></a>开关状态的不同过渡方式</h3><pre><code>input{\n    width: 200px;\n    height: 20px;\n    border: 1px solid #CCC;\n    transition: width 1s;\n}\ninput:focus{\n    width: 300px;\n}\n</code></pre><p>这样当input获得焦点时和失去焦点时，input宽度的变化都是在1秒内完成的。<br>但是如果像下面这样写</p>\n<pre><code>input{\n    width: 200px;\n    height: 20px;\n    border: 1px solid #CCC;\n    transition: width .2s;\n}\ninput:focus{\n    width: 300px;\n    transition: width 1s;\n}\n</code></pre><p>那么当input获得焦点时，宽度从200px变化到300px是在1s内完成的，失去焦点时宽度从300px变回到200px时则是在0.2s内完成的。<br>演示见 <a href=\"http://shly.github.io/shly/IFE/task_12/index.html\" target=\"_blank\" rel=\"external\">http://shly.github.io/shly/IFE/task_12/index.html</a></p>\n<h3 id=\"css过渡的触发\"><a href=\"#css过渡的触发\" class=\"headerlink\" title=\"css过渡的触发\"></a>css过渡的触发</h3><p>（1）伪元素触发 :active :focus :checked<br>（2）媒体查询触发<br>（3）JavaScript触发，给元素添加新的类，向新的类添加过渡如</p>\n<pre><code>.box{\n    width:100px;\n    height:100px;\n    border:1px solid #000;\n    transition: width 2s;\n}\n.box .on{\n    width:200px;\n}\n</code></pre><h3 id=\"启用硬件加速使过渡更流畅\"><a href=\"#启用硬件加速使过渡更流畅\" class=\"headerlink\" title=\"启用硬件加速使过渡更流畅\"></a>启用硬件加速使过渡更流畅</h3><p>   以下内容引自：<a href=\"http://www.cnblogs.com/rubylouvre/p/3471490.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/rubylouvre/p/3471490.html</a><br>   CSS animations, transforms 以及 transitions不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。<br>   现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。<br>   例如：</p>\n<pre><code>.cube {\n   -webkit-transform: translate3d(250px,250px,250px)\n   rotate3d(250px,250px,250px,-120deg)\n   scale3d(0.5, 0.5, 0.5);\n}\n</code></pre><p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。<br>虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速。</p>\n<pre><code>.cube {\n   -webkit-transform: translateZ(0);\n   -moz-transform: translateZ(0);\n   -ms-transform: translateZ(0);\n   -o-transform: translateZ(0);\n   transform: translateZ(0);\n   /* Other transform properties here */\n}\n</code></pre><p>   在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：</p>\n<pre><code>.cube {\n   -webkit-backface-visibility: hidden;\n   -moz-backface-visibility: hidden;\n   -ms-backface-visibility: hidden;\n   backface-visibility: hidden;\n\n   -webkit-perspective: 1000;\n   -moz-perspective: 1000;\n   -ms-perspective: 1000;\n   perspective: 1000;\n   /* Other transform properties here */\n}\n</code></pre><p>   在webkit内核的浏览器中，另一个行之有效的方法是</p>\n<pre><code>.cube {\n   -webkit-transform: translate3d(0, 0, 0);\n   -moz-transform: translate3d(0, 0, 0);\n   -ms-transform: translate3d(0, 0, 0);\n   transform: translate3d(0, 0, 0);\n  /* Other transform properties here */\n}\n</code></pre><p>原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。</p>\n<p>只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。<br>小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。</p>\n","excerpt":"<p>以下内容主要出自《图解CSS3-大漠》</p>\n<h3 id=\"W3C标准中对transition的描述\"><a href=\"#W3C标准中对transition的描述\" class=\"headerlink\" title=\"W3C标准中对transition的描述\"></a>W3C标准中对transition的描述</h3><p>CSS3的transition允许css的属性值在一定的时间区间内平滑的过渡。这种效果可以在鼠标单击，获得焦点，被点击或者对元素的任何改变中触发，并平滑地以动画的效果改变css的属性值。<br>","more":"</p>\n<h3 id=\"css中创建简单过渡的步骤\"><a href=\"#css中创建简单过渡的步骤\" class=\"headerlink\" title=\"css中创建简单过渡的步骤\"></a>css中创建简单过渡的步骤</h3><p>  （1）在默认样式中声明元素的初始状态样式<br>  （2）声明过渡元素最终状态样式<br>  （3）在默认样式中通过添加过渡函数，添加一些不同的样式。 </p>\n<h3 id=\"transition属性主要包含四个属性值\"><a href=\"#transition属性主要包含四个属性值\" class=\"headerlink\" title=\"transition属性主要包含四个属性值\"></a>transition属性主要包含四个属性值</h3><p>  （1）transition-property：指定过渡或动态模拟的CSS属性<br>  （2）transition-duration：指定完成过渡所需的时间<br>  （3）transition-timing-function：指定过渡函数<br>  （4）transition-delay:指定过渡开始出现的延迟时间</p>\n<h3 id=\"简写形式\"><a href=\"#简写形式\" class=\"headerlink\" title=\"简写形式\"></a>简写形式</h3><pre><code>transition: &lt;property&gt; &lt;duration&gt; &lt;animation type&gt; &lt;delay&gt;\n</code></pre><h3 id=\"可以使用过渡的属性\"><a href=\"#可以使用过渡的属性\" class=\"headerlink\" title=\"可以使用过渡的属性\"></a>可以使用过渡的属性</h3><p>  （1）颜色属性<br>  （2）具有长度值，百分比的属性<br>  （3）integer<br>  （4）number真实的（浮点型）数值<br>  （5）变形系列属性。如rotate(),rotate3d(),scale(),scale3d(),skew(),translate(),translate3d()等<br>  （6）reactangle：通过x,y,width,height变形<br>  （7）visibility：离散步骤，在0~1范围内<br>  （8）阴影<br>  （9）渐变<br>  （10）paint server(SVG)：只支持下面的情况。从gradient到gradient，以及从color到color<br>  （11）space-separated list of above：如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化<br>  （12）缩写属性</p>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p>  （1）IE 10+（PP3）（平台预览第三版），Firefox4.0~15.0，Chrome4.0~    20.0，Safari3.1~6.0和Opera10.5~12.0，在使用时需要加上各浏览器的私有属性。<br>  （2）IE10+，Firefox16.0+，chrome26.0+，Safari 7.0+，Opera 12.1+支持transition的标准语法。<br>  （3）ios Safari 3.2~6.1、Android browser2.1+，Blackberry browser7.0+和chrome for Android 27.0需要添加浏览器前缀-webkit-,Opero mobile 10.0~12.0中需要添加浏览器前缀-o-。<br>  （4）ios Safari 7.0+和Firefox for Android 22.0支持transition的标准语法。</p>\n<h3 id=\"开关状态的不同过渡方式\"><a href=\"#开关状态的不同过渡方式\" class=\"headerlink\" title=\"开关状态的不同过渡方式\"></a>开关状态的不同过渡方式</h3><pre><code>input{\n    width: 200px;\n    height: 20px;\n    border: 1px solid #CCC;\n    transition: width 1s;\n}\ninput:focus{\n    width: 300px;\n}\n</code></pre><p>这样当input获得焦点时和失去焦点时，input宽度的变化都是在1秒内完成的。<br>但是如果像下面这样写</p>\n<pre><code>input{\n    width: 200px;\n    height: 20px;\n    border: 1px solid #CCC;\n    transition: width .2s;\n}\ninput:focus{\n    width: 300px;\n    transition: width 1s;\n}\n</code></pre><p>那么当input获得焦点时，宽度从200px变化到300px是在1s内完成的，失去焦点时宽度从300px变回到200px时则是在0.2s内完成的。<br>演示见 <a href=\"http://shly.github.io/shly/IFE/task_12/index.html\">http://shly.github.io/shly/IFE/task_12/index.html</a></p>\n<h3 id=\"css过渡的触发\"><a href=\"#css过渡的触发\" class=\"headerlink\" title=\"css过渡的触发\"></a>css过渡的触发</h3><p>（1）伪元素触发 :active :focus :checked<br>（2）媒体查询触发<br>（3）JavaScript触发，给元素添加新的类，向新的类添加过渡如</p>\n<pre><code>.box{\n    width:100px;\n    height:100px;\n    border:1px solid #000;\n    transition: width 2s;\n}\n.box .on{\n    width:200px;\n}\n</code></pre><h3 id=\"启用硬件加速使过渡更流畅\"><a href=\"#启用硬件加速使过渡更流畅\" class=\"headerlink\" title=\"启用硬件加速使过渡更流畅\"></a>启用硬件加速使过渡更流畅</h3><p>   以下内容引自：<a href=\"http://www.cnblogs.com/rubylouvre/p/3471490.html\">http://www.cnblogs.com/rubylouvre/p/3471490.html</a><br>   CSS animations, transforms 以及 transitions不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器提供了某些触发的CSS规则。<br>   现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。<br>   例如：</p>\n<pre><code>.cube {\n   -webkit-transform: translate3d(250px,250px,250px)\n   rotate3d(250px,250px,250px,-120deg)\n   scale3d(0.5, 0.5, 0.5);\n}\n</code></pre><p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。<br>虽然我们可能不想对元素应用3D变换，可我们一样可以开启3D引擎。例如我们可以用transform: translateZ(0); 来开启硬件加速。</p>\n<pre><code>.cube {\n   -webkit-transform: translateZ(0);\n   -moz-transform: translateZ(0);\n   -ms-transform: translateZ(0);\n   -o-transform: translateZ(0);\n   transform: translateZ(0);\n   /* Other transform properties here */\n}\n</code></pre><p>   在 Chrome and Safari中，当我们使用CSS transforms 或者 animations时可能会有页面闪烁的效果，下面的代码可以修复此情况：</p>\n<pre><code>.cube {\n   -webkit-backface-visibility: hidden;\n   -moz-backface-visibility: hidden;\n   -ms-backface-visibility: hidden;\n   backface-visibility: hidden;\n\n   -webkit-perspective: 1000;\n   -moz-perspective: 1000;\n   -ms-perspective: 1000;\n   perspective: 1000;\n   /* Other transform properties here */\n}\n</code></pre><p>   在webkit内核的浏览器中，另一个行之有效的方法是</p>\n<pre><code>.cube {\n   -webkit-transform: translate3d(0, 0, 0);\n   -moz-transform: translate3d(0, 0, 0);\n   -ms-transform: translate3d(0, 0, 0);\n   transform: translate3d(0, 0, 0);\n  /* Other transform properties here */\n}\n</code></pre><p>原生的移动端应用(Native mobile applications)总是可以很好的运用GPU，这是为什么它比网页应用(Web apps)表现更好的原因。硬件加速在移动端尤其有用，因为它可以有效的减少资源的利用(麦时注：移动端本身资源有限)。</p>\n<p>只对我们需要实现动画效果的元素应用以上方法，如果仅仅为了开启硬件加速而随便乱用，那是不明智的。<br>小心使用这些方法，如果通过你的测试，结果确是提高了性能，你才可以使用这些方法。使用GPU可能会导致严重的性能问题，因为它增加了内存的使用，而且它会减少移动端设备的电池寿命。</p>"},{"title":"思考","date":"2016-05-24T13:21:38.000Z","_content":"之前一直想同样环境下学习的两个人，为什么取得的成果会有很大的不同，得出的结论就是思考。也就是说，为什么同样的学习，有些人也看起来更努力一些，结果往往还不如那些看起来不努力的人？那除了智商的原因，还有什么其他的东西导致了人与人之间的不同？通过长时间的观察研究，我得出的结论是，同样的学习，有些人一边学习，一边思考一边总结，那他掌握东西就比那些不思考的人掌握的更多更深刻。俗话讲的失败乃成功之母，你失败了不去总结经验，下次还是失败。所以说人一定要不断学习不断思考总结。\n<!-- more -->\n那还有什么原因造成两个人进步的不同？答案是有的人站在了巨人的肩膀上。除了自己不断试错不断总结经验，我们还要学会从其他人的身上学习经验。有些人这点可能做得很好，但是我自己这点就很差，别人的教训我往往很难接受，经常是自己吃了亏，才明白别人当初说的没错。所谓站在巨人的肩膀上还有一个意思，要勇于向别人请教，也许有的时候你看了很久的书还没有思路的问题，别人一句话就会点醒你。当然，问别人的前提是你自己得做了足够的功课。\n我一直牢记要思考，所以最近发生件特别有趣的事情，我一直在心里想，我毕设到底做什么，这些数据能做什么，注意，是在想，可是我发现想的就是这两句话，可是大脑根本没转。我想了一下为什么会这样，很尴尬的发现不是它不爱转，是因为知识储备不够，脑袋根本转不起来。。。后来跑去看了一些论文，终于有了一些想法。于是明白了一句话，学而不思则罔，思而不学则殆。\n\n","source":"_posts/思考.md","raw":"---\ntitle: 思考\ndate: 2016-05-24 21:21:38\ntags:\n - 随笔\ncategories:\n - 随手日记\n---\n之前一直想同样环境下学习的两个人，为什么取得的成果会有很大的不同，得出的结论就是思考。也就是说，为什么同样的学习，有些人也看起来更努力一些，结果往往还不如那些看起来不努力的人？那除了智商的原因，还有什么其他的东西导致了人与人之间的不同？通过长时间的观察研究，我得出的结论是，同样的学习，有些人一边学习，一边思考一边总结，那他掌握东西就比那些不思考的人掌握的更多更深刻。俗话讲的失败乃成功之母，你失败了不去总结经验，下次还是失败。所以说人一定要不断学习不断思考总结。\n<!-- more -->\n那还有什么原因造成两个人进步的不同？答案是有的人站在了巨人的肩膀上。除了自己不断试错不断总结经验，我们还要学会从其他人的身上学习经验。有些人这点可能做得很好，但是我自己这点就很差，别人的教训我往往很难接受，经常是自己吃了亏，才明白别人当初说的没错。所谓站在巨人的肩膀上还有一个意思，要勇于向别人请教，也许有的时候你看了很久的书还没有思路的问题，别人一句话就会点醒你。当然，问别人的前提是你自己得做了足够的功课。\n我一直牢记要思考，所以最近发生件特别有趣的事情，我一直在心里想，我毕设到底做什么，这些数据能做什么，注意，是在想，可是我发现想的就是这两句话，可是大脑根本没转。我想了一下为什么会这样，很尴尬的发现不是它不爱转，是因为知识储备不够，脑袋根本转不起来。。。后来跑去看了一些论文，终于有了一些想法。于是明白了一句话，学而不思则罔，思而不学则殆。\n\n","slug":"思考","published":1,"updated":"2016-05-24T13:47:48.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnf003o1kvsm99ecmyo","content":"<p>之前一直想同样环境下学习的两个人，为什么取得的成果会有很大的不同，得出的结论就是思考。也就是说，为什么同样的学习，有些人也看起来更努力一些，结果往往还不如那些看起来不努力的人？那除了智商的原因，还有什么其他的东西导致了人与人之间的不同？通过长时间的观察研究，我得出的结论是，同样的学习，有些人一边学习，一边思考一边总结，那他掌握东西就比那些不思考的人掌握的更多更深刻。俗话讲的失败乃成功之母，你失败了不去总结经验，下次还是失败。所以说人一定要不断学习不断思考总结。<br><a id=\"more\"></a><br>那还有什么原因造成两个人进步的不同？答案是有的人站在了巨人的肩膀上。除了自己不断试错不断总结经验，我们还要学会从其他人的身上学习经验。有些人这点可能做得很好，但是我自己这点就很差，别人的教训我往往很难接受，经常是自己吃了亏，才明白别人当初说的没错。所谓站在巨人的肩膀上还有一个意思，要勇于向别人请教，也许有的时候你看了很久的书还没有思路的问题，别人一句话就会点醒你。当然，问别人的前提是你自己得做了足够的功课。<br>我一直牢记要思考，所以最近发生件特别有趣的事情，我一直在心里想，我毕设到底做什么，这些数据能做什么，注意，是在想，可是我发现想的就是这两句话，可是大脑根本没转。我想了一下为什么会这样，很尴尬的发现不是它不爱转，是因为知识储备不够，脑袋根本转不起来。。。后来跑去看了一些论文，终于有了一些想法。于是明白了一句话，学而不思则罔，思而不学则殆。</p>\n","excerpt":"<p>之前一直想同样环境下学习的两个人，为什么取得的成果会有很大的不同，得出的结论就是思考。也就是说，为什么同样的学习，有些人也看起来更努力一些，结果往往还不如那些看起来不努力的人？那除了智商的原因，还有什么其他的东西导致了人与人之间的不同？通过长时间的观察研究，我得出的结论是，同样的学习，有些人一边学习，一边思考一边总结，那他掌握东西就比那些不思考的人掌握的更多更深刻。俗话讲的失败乃成功之母，你失败了不去总结经验，下次还是失败。所以说人一定要不断学习不断思考总结。<br>","more":"<br>那还有什么原因造成两个人进步的不同？答案是有的人站在了巨人的肩膀上。除了自己不断试错不断总结经验，我们还要学会从其他人的身上学习经验。有些人这点可能做得很好，但是我自己这点就很差，别人的教训我往往很难接受，经常是自己吃了亏，才明白别人当初说的没错。所谓站在巨人的肩膀上还有一个意思，要勇于向别人请教，也许有的时候你看了很久的书还没有思路的问题，别人一句话就会点醒你。当然，问别人的前提是你自己得做了足够的功课。<br>我一直牢记要思考，所以最近发生件特别有趣的事情，我一直在心里想，我毕设到底做什么，这些数据能做什么，注意，是在想，可是我发现想的就是这两句话，可是大脑根本没转。我想了一下为什么会这样，很尴尬的发现不是它不爱转，是因为知识储备不够，脑袋根本转不起来。。。后来跑去看了一些论文，终于有了一些想法。于是明白了一句话，学而不思则罔，思而不学则殆。</p>"},{"title":"Java中Stack对象的empty() and isEmpty() 对比","date":"2016-06-17T01:21:54.000Z","_content":"java中判断栈是否为空有两个empty方法，stack.empty()和stack.isEmpty()。那么两者有什么区别呢？\n还是先看api。empty()方法：\n<!-- more -->\n\n\t boolean java.util.Stack.empty()\n\n\n\tTests if this stack is empty.\n\n\tReturns:\n\ttrue if and only if this stack contains no items; false otherwise.\nisEmpty()方法：\n\tboolean java.util.Vector.isEmpty()\n\n\n\tTests if this vector has no components.\n\n\tSpecified by: isEmpty() in List, Overrides: isEmpty() in AbstractCollection\n\tReturns:\n\ttrue if and only if this vector has no components, that is, its size is zero; false otherwise.\n\n源代码中，empty方法是Stack类中\n\t public boolean empty() {\n\t        return size() == 0;\n\t    }\n而size()是在Vector类中实现的，如下\n\n\tpublic synchronized int size() {\n\t        return elementCount;\n\t    }\nisEmpty()方法在Vector类中实现，代码如下：\n\n\t public synchronized boolean isEmpty() {\n\t        return elementCount == 0;\n\t    }\n总结：Stack是继承自Vector，所以Stack类型的对象可以访问Vector对象中的方法，那么问题来了，当Stack和Vector中有完成相同功能的方法时，应该调用Stack中的还是Vector中的呢？","source":"_posts/栈方法1.md","raw":"---\ntitle: Java中Stack对象的empty() and isEmpty() 对比\ndate: 2016-06-17 09:21:54\ntags: \n  - java\n  - stack\n  - empty and isEmpty\ncategories:\n  - 学习笔记\n  - java\n---\njava中判断栈是否为空有两个empty方法，stack.empty()和stack.isEmpty()。那么两者有什么区别呢？\n还是先看api。empty()方法：\n<!-- more -->\n\n\t boolean java.util.Stack.empty()\n\n\n\tTests if this stack is empty.\n\n\tReturns:\n\ttrue if and only if this stack contains no items; false otherwise.\nisEmpty()方法：\n\tboolean java.util.Vector.isEmpty()\n\n\n\tTests if this vector has no components.\n\n\tSpecified by: isEmpty() in List, Overrides: isEmpty() in AbstractCollection\n\tReturns:\n\ttrue if and only if this vector has no components, that is, its size is zero; false otherwise.\n\n源代码中，empty方法是Stack类中\n\t public boolean empty() {\n\t        return size() == 0;\n\t    }\n而size()是在Vector类中实现的，如下\n\n\tpublic synchronized int size() {\n\t        return elementCount;\n\t    }\nisEmpty()方法在Vector类中实现，代码如下：\n\n\t public synchronized boolean isEmpty() {\n\t        return elementCount == 0;\n\t    }\n总结：Stack是继承自Vector，所以Stack类型的对象可以访问Vector对象中的方法，那么问题来了，当Stack和Vector中有完成相同功能的方法时，应该调用Stack中的还是Vector中的呢？","slug":"栈方法1","published":1,"updated":"2016-06-18T13:53:41.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnu003r1kvsw5d361gp","content":"<p>java中判断栈是否为空有两个empty方法，stack.empty()和stack.isEmpty()。那么两者有什么区别呢？<br>还是先看api。empty()方法：<br><a id=\"more\"></a></p>\n<pre><code> boolean java.util.Stack.empty()\n\n\nTests if this stack is empty.\n\nReturns:\ntrue if and only if this stack contains no items; false otherwise.\n</code></pre><p>isEmpty()方法：<br>    boolean java.util.Vector.isEmpty()</p>\n<pre><code>Tests if this vector has no components.\n\nSpecified by: isEmpty() in List, Overrides: isEmpty() in AbstractCollection\nReturns:\ntrue if and only if this vector has no components, that is, its size is zero; false otherwise.\n</code></pre><p>源代码中，empty方法是Stack类中<br>     public boolean empty() {<br>            return size() == 0;<br>        }<br>而size()是在Vector类中实现的，如下</p>\n<pre><code>public synchronized int size() {\n        return elementCount;\n    }\n</code></pre><p>isEmpty()方法在Vector类中实现，代码如下：</p>\n<pre><code>public synchronized boolean isEmpty() {\n       return elementCount == 0;\n   }\n</code></pre><p>总结：Stack是继承自Vector，所以Stack类型的对象可以访问Vector对象中的方法，那么问题来了，当Stack和Vector中有完成相同功能的方法时，应该调用Stack中的还是Vector中的呢？</p>\n","excerpt":"<p>java中判断栈是否为空有两个empty方法，stack.empty()和stack.isEmpty()。那么两者有什么区别呢？<br>还是先看api。empty()方法：<br>","more":"</p>\n<pre><code> boolean java.util.Stack.empty()\n\n\nTests if this stack is empty.\n\nReturns:\ntrue if and only if this stack contains no items; false otherwise.\n</code></pre><p>isEmpty()方法：<br>    boolean java.util.Vector.isEmpty()</p>\n<pre><code>Tests if this vector has no components.\n\nSpecified by: isEmpty() in List, Overrides: isEmpty() in AbstractCollection\nReturns:\ntrue if and only if this vector has no components, that is, its size is zero; false otherwise.\n</code></pre><p>源代码中，empty方法是Stack类中<br>     public boolean empty() {<br>            return size() == 0;<br>        }<br>而size()是在Vector类中实现的，如下</p>\n<pre><code>public synchronized int size() {\n        return elementCount;\n    }\n</code></pre><p>isEmpty()方法在Vector类中实现，代码如下：</p>\n<pre><code>public synchronized boolean isEmpty() {\n       return elementCount == 0;\n   }\n</code></pre><p>总结：Stack是继承自Vector，所以Stack类型的对象可以访问Vector对象中的方法，那么问题来了，当Stack和Vector中有完成相同功能的方法时，应该调用Stack中的还是Vector中的呢？</p>"},{"title":"将本地项目首次提交到远程git上遇到的问题","date":"2016-07-20T09:27:33.000Z","_content":"当初将一个项目托管到git上时，应首先在git上建立一个仓库，比如名为example，然后在本地项目的文件夹下执行下面的指令：\n<!-- more -->\n\n1. git init\n2. git add README.md\n3. git commit -m \"first commit\"\n4. git remote add origin git@github.com:shly/example.git\n5. git push -u origin master\n这里面要注意下第5步，平时我们向git上提交代码时只需要执行git push origin master即可，但是第一次一定要加个-u，否则以后执行git pull时必须执行git push -u origin master，加上之后每次pull时只要git pull即可。没加-u时，执行git pull\n\n\twarning: push.default is unset; its implicit value has changed in\n\tGit 2.0 from 'matching' to 'simple'. To squelch this message\n\tand maintain the traditional behavior, use:\n\n\t  git config --global push.default matching\n\n\tTo squelch this message and adopt the new behavior now, use:\n\n\t  git config --global push.default simple\n\n\tWhen push.default is set to 'matching', git will push local branches\n\tto the remote branches that already exist with the same name.\n\n\tSince Git 2.0, Git defaults to the more conservative 'simple'\n\tbehavior, which only pushes the current branch to the corresponding\n\tremote branch that 'git pull' uses to update the current branch.\n\n\tSee 'git help config' and search for 'push.default' for further information.\n\t(the 'simple' mode was introduced in Git 1.7.11. Use the similar mode\n\t'current' instead of 'simple' if you sometimes use older versions of Git)\n\n\tfatal: 'master' does not appear to be a git repository\n\tfatal: Could not read from remote repository.\n\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\n详情见：\nhttp://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma","source":"_posts/将本地项目首次提交到远程git上遇到的问题.md","raw":"---\ntitle: 将本地项目首次提交到远程git上遇到的问题\ndate: 2016-07-20 17:27:33\ntags: \n  - git\n  - gitignore配置\ncategories:\n  - 学习笔记\n  - git学习\n---\n当初将一个项目托管到git上时，应首先在git上建立一个仓库，比如名为example，然后在本地项目的文件夹下执行下面的指令：\n<!-- more -->\n\n1. git init\n2. git add README.md\n3. git commit -m \"first commit\"\n4. git remote add origin git@github.com:shly/example.git\n5. git push -u origin master\n这里面要注意下第5步，平时我们向git上提交代码时只需要执行git push origin master即可，但是第一次一定要加个-u，否则以后执行git pull时必须执行git push -u origin master，加上之后每次pull时只要git pull即可。没加-u时，执行git pull\n\n\twarning: push.default is unset; its implicit value has changed in\n\tGit 2.0 from 'matching' to 'simple'. To squelch this message\n\tand maintain the traditional behavior, use:\n\n\t  git config --global push.default matching\n\n\tTo squelch this message and adopt the new behavior now, use:\n\n\t  git config --global push.default simple\n\n\tWhen push.default is set to 'matching', git will push local branches\n\tto the remote branches that already exist with the same name.\n\n\tSince Git 2.0, Git defaults to the more conservative 'simple'\n\tbehavior, which only pushes the current branch to the corresponding\n\tremote branch that 'git pull' uses to update the current branch.\n\n\tSee 'git help config' and search for 'push.default' for further information.\n\t(the 'simple' mode was introduced in Git 1.7.11. Use the similar mode\n\t'current' instead of 'simple' if you sometimes use older versions of Git)\n\n\tfatal: 'master' does not appear to be a git repository\n\tfatal: Could not read from remote repository.\n\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\n详情见：\nhttp://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma","slug":"将本地项目首次提交到远程git上遇到的问题","published":1,"updated":"2016-07-20T12:35:07.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnu003u1kvss2equvi7","content":"<p>当初将一个项目托管到git上时，应首先在git上建立一个仓库，比如名为example，然后在本地项目的文件夹下执行下面的指令：<br><a id=\"more\"></a></p>\n<ol>\n<li>git init</li>\n<li>git add README.md</li>\n<li>git commit -m “first commit”</li>\n<li>git remote add origin git@github.com:shly/example.git</li>\n<li><p>git push -u origin master<br>这里面要注意下第5步，平时我们向git上提交代码时只需要执行git push origin master即可，但是第一次一定要加个-u，否则以后执行git pull时必须执行git push -u origin master，加上之后每次pull时只要git pull即可。没加-u时，执行git pull</p>\n<p> warning: push.default is unset; its implicit value has changed in<br> Git 2.0 from ‘matching’ to ‘simple’. To squelch this message<br> and maintain the traditional behavior, use:</p>\n<p>   git config –global push.default matching</p>\n<p> To squelch this message and adopt the new behavior now, use:</p>\n<p>   git config –global push.default simple</p>\n<p> When push.default is set to ‘matching’, git will push local branches<br> to the remote branches that already exist with the same name.</p>\n<p> Since Git 2.0, Git defaults to the more conservative ‘simple’<br> behavior, which only pushes the current branch to the corresponding<br> remote branch that ‘git pull’ uses to update the current branch.</p>\n<p> See ‘git help config’ and search for ‘push.default’ for further information.<br> (the ‘simple’ mode was introduced in Git 1.7.11. Use the similar mode<br> ‘current’ instead of ‘simple’ if you sometimes use older versions of Git)</p>\n<p> fatal: ‘master’ does not appear to be a git repository<br> fatal: Could not read from remote repository.</p>\n<p> Please make sure you have the correct access rights<br> and the repository exists.</p>\n</li>\n</ol>\n<p>详情见：<br><a href=\"http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma</a></p>\n","excerpt":"<p>当初将一个项目托管到git上时，应首先在git上建立一个仓库，比如名为example，然后在本地项目的文件夹下执行下面的指令：<br>","more":"</p>\n<ol>\n<li>git init</li>\n<li>git add README.md</li>\n<li>git commit -m “first commit”</li>\n<li>git remote add origin git@github.com:shly/example.git</li>\n<li><p>git push -u origin master<br>这里面要注意下第5步，平时我们向git上提交代码时只需要执行git push origin master即可，但是第一次一定要加个-u，否则以后执行git pull时必须执行git push -u origin master，加上之后每次pull时只要git pull即可。没加-u时，执行git pull</p>\n<p> warning: push.default is unset; its implicit value has changed in<br> Git 2.0 from ‘matching’ to ‘simple’. To squelch this message<br> and maintain the traditional behavior, use:</p>\n<p>   git config –global push.default matching</p>\n<p> To squelch this message and adopt the new behavior now, use:</p>\n<p>   git config –global push.default simple</p>\n<p> When push.default is set to ‘matching’, git will push local branches<br> to the remote branches that already exist with the same name.</p>\n<p> Since Git 2.0, Git defaults to the more conservative ‘simple’<br> behavior, which only pushes the current branch to the corresponding<br> remote branch that ‘git pull’ uses to update the current branch.</p>\n<p> See ‘git help config’ and search for ‘push.default’ for further information.<br> (the ‘simple’ mode was introduced in Git 1.7.11. Use the similar mode<br> ‘current’ instead of ‘simple’ if you sometimes use older versions of Git)</p>\n<p> fatal: ‘master’ does not appear to be a git repository<br> fatal: Could not read from remote repository.</p>\n<p> Please make sure you have the correct access rights<br> and the repository exists.</p>\n</li>\n</ol>\n<p>详情见：<br><a href=\"http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma\">http://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma</a></p>"},{"title":"块级元素和内联元素","date":"2016-07-28T05:44:44.000Z","_content":"\n# 块级元素和内联元素的定义\n\nBlock-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the 'display' property make an element block-level: 'block', 'list-item', and 'table'.\n\nInline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the 'display' property make an element inline-level: 'inline', 'inline-table', and 'inline-block'. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context.\n<!-- more -->\n\n# 常见的块级元素和内联元素\n\n块级元素列表\n\n\t<address>\t定义地址\n\t<caption>\t定义表格标题\n\t<dd>\t定义列表中定义条目\n\t<div>\t定义文档中的分区或节\n\t<dl>\t定义列表\n\t<dt>\t定义列表中的项目\n\t<fieldset>\t定义一个框架集\n\t<form>\t创建 HTML 表单\n\t<h1>\t定义最大的标题\n\t<h2>\t定义副标题\n\t<h3>\t定义标题\n\t<h4>\t定义标题\n\t<h5>\t定义标题\n\t<h6>\t定义最小的标题\n\t<hr>\t创建一条水平线\n\t<legend>\t元素为 fieldset 元素定义标题\n\t<li>\t标签定义列表项目\n\t<noframes>\t为那些不支持框架的浏览器显示文本，于 frameset 元素内部\n\t<noscript>\t定义在脚本未被执行时的替代内容\n\t<ol>\t定义有序列表\n\t<ul>\t定义无序列表\n\t<p>\t标签定义段落\n\t<pre>\t定义预格式化的文本\n\t<table>\t标签定义 HTML 表格\n\t<tbody>\t标签表格主体（正文）\n\t<td>\t表格中的标准单元格\n\t<tfoot>\t定义表格的页脚（脚注或表注）\n\t<th>\t定义表头单元格\n\t<thead>\t标签定义表格的表头\n\t<tr>\t定义表格中的行\n\n行内元素列表\n\n\t<a>\t标签可定义锚\n\t<abbr>\t表示一个缩写形式\n\t<acronym>\t定义只取首字母缩写\n\t<b>\t字体加粗\n\t<bdo>\t可覆盖默认的文本方向\n\t<big>\t大号字体加粗\n\t<br>\t换行\n\t<cite>\t引用进行定义\n\t<code>\t定义计算机代码文本\n\t<dfn>\t定义一个定义项目\n\t<em>\t定义为强调的内容\n\t<i>\t斜体文本效果\n\t<img>\t向网页中嵌入一幅图像\n\t<input>\t输入框\n\t<kbd>\t定义键盘文本\n\t<label>\t标签为 input 元素定义标注（标记）\n\t<q>\t定义短的引用\n\t<samp>\t定义样本文本\n\t<select>\t创建单选或多选菜单\n\t<small>\t呈现小号字体效果\n\t<span>\t组合文档中的行内元素\n\t<strong>\t语气更强的强调的内容\n\t<sub>\t定义下标文本\n\t<sup>\t定义上标文本\n\t<textarea>\t多行的文本输入控件\n\t<tt>\t打字机或者等宽的文本效果\n\t<var>\t定义变量\n\n可变元素列表--可变元素为根据上下文语境决定该元素为块元素或者内联元素\n\n\t<button>\t按钮\n\t<del>\t定义文档中已被删除的文本\n\t<iframe>\t创建包含另外一个文档的内联框架（即行内框架）\n\t<ins>\t标签定义已经被插入文档中的文本\n\t<map>\t客户端图像映射（即热区）\n\t<object>\tobject对象\n\t<script>\t客户端脚本\n\n# 块级元素和行内元素的区别\n\n1. 块级元素各占一行，垂直排列，行内元素水平排列\n2. 块级元素可以包含行内元素，行内元素不能包含块级元素\n3. 行内元素无法设置宽度和高度，无法设置margin-top和margin-bottom,无法设置padding-top和padding-bottom\n\n# html标签的嵌套规则\n\n1. 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素：\n\n\t\t<div><h1></h1><p></p></div> —— 对\n\t\t<a href=”#”><span></span></a> —— 对\n\t\t<span><div></div></span> —— 错\n\n2. 块级元素不能放在 &lt;p>里面：\n\n\t\t<p><ol><li></li></ol></p> —— 错\n\t\t<p><div></div></p> —— 错\n\n3. 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：\n\n\t\th1、h2、h3、h4、h5、h6、p、dt\n\n4. li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：\n\n\tli 和 div 标 签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都 可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大 滴……\n\n5. 块级元素与块级元素并列、内嵌元素与内嵌元素并列：\n\n\t\t<div><h2></h2><p></p></div> —— 对\n\t\t<div><a href=”#”></a><span></span></div> —— 对\n\t\t<div><h2></h2><span></span></div> —— 错\n\n# 参考文章：\n\nhttp://blog.csdn.net/sykent/article/details/7738408\nhttp://www.jb51.net/web/218553.html\nhttp://www.5icool.org/a/201308/a2081.html","source":"_posts/块级元素和内联元素.md","raw":"---\ntitle: 块级元素和内联元素\ndate: 2016-07-28 13:44:44\ntags: html标签\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n\n# 块级元素和内联元素的定义\n\nBlock-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the 'display' property make an element block-level: 'block', 'list-item', and 'table'.\n\nInline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the 'display' property make an element inline-level: 'inline', 'inline-table', and 'inline-block'. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context.\n<!-- more -->\n\n# 常见的块级元素和内联元素\n\n块级元素列表\n\n\t<address>\t定义地址\n\t<caption>\t定义表格标题\n\t<dd>\t定义列表中定义条目\n\t<div>\t定义文档中的分区或节\n\t<dl>\t定义列表\n\t<dt>\t定义列表中的项目\n\t<fieldset>\t定义一个框架集\n\t<form>\t创建 HTML 表单\n\t<h1>\t定义最大的标题\n\t<h2>\t定义副标题\n\t<h3>\t定义标题\n\t<h4>\t定义标题\n\t<h5>\t定义标题\n\t<h6>\t定义最小的标题\n\t<hr>\t创建一条水平线\n\t<legend>\t元素为 fieldset 元素定义标题\n\t<li>\t标签定义列表项目\n\t<noframes>\t为那些不支持框架的浏览器显示文本，于 frameset 元素内部\n\t<noscript>\t定义在脚本未被执行时的替代内容\n\t<ol>\t定义有序列表\n\t<ul>\t定义无序列表\n\t<p>\t标签定义段落\n\t<pre>\t定义预格式化的文本\n\t<table>\t标签定义 HTML 表格\n\t<tbody>\t标签表格主体（正文）\n\t<td>\t表格中的标准单元格\n\t<tfoot>\t定义表格的页脚（脚注或表注）\n\t<th>\t定义表头单元格\n\t<thead>\t标签定义表格的表头\n\t<tr>\t定义表格中的行\n\n行内元素列表\n\n\t<a>\t标签可定义锚\n\t<abbr>\t表示一个缩写形式\n\t<acronym>\t定义只取首字母缩写\n\t<b>\t字体加粗\n\t<bdo>\t可覆盖默认的文本方向\n\t<big>\t大号字体加粗\n\t<br>\t换行\n\t<cite>\t引用进行定义\n\t<code>\t定义计算机代码文本\n\t<dfn>\t定义一个定义项目\n\t<em>\t定义为强调的内容\n\t<i>\t斜体文本效果\n\t<img>\t向网页中嵌入一幅图像\n\t<input>\t输入框\n\t<kbd>\t定义键盘文本\n\t<label>\t标签为 input 元素定义标注（标记）\n\t<q>\t定义短的引用\n\t<samp>\t定义样本文本\n\t<select>\t创建单选或多选菜单\n\t<small>\t呈现小号字体效果\n\t<span>\t组合文档中的行内元素\n\t<strong>\t语气更强的强调的内容\n\t<sub>\t定义下标文本\n\t<sup>\t定义上标文本\n\t<textarea>\t多行的文本输入控件\n\t<tt>\t打字机或者等宽的文本效果\n\t<var>\t定义变量\n\n可变元素列表--可变元素为根据上下文语境决定该元素为块元素或者内联元素\n\n\t<button>\t按钮\n\t<del>\t定义文档中已被删除的文本\n\t<iframe>\t创建包含另外一个文档的内联框架（即行内框架）\n\t<ins>\t标签定义已经被插入文档中的文本\n\t<map>\t客户端图像映射（即热区）\n\t<object>\tobject对象\n\t<script>\t客户端脚本\n\n# 块级元素和行内元素的区别\n\n1. 块级元素各占一行，垂直排列，行内元素水平排列\n2. 块级元素可以包含行内元素，行内元素不能包含块级元素\n3. 行内元素无法设置宽度和高度，无法设置margin-top和margin-bottom,无法设置padding-top和padding-bottom\n\n# html标签的嵌套规则\n\n1. 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素：\n\n\t\t<div><h1></h1><p></p></div> —— 对\n\t\t<a href=”#”><span></span></a> —— 对\n\t\t<span><div></div></span> —— 错\n\n2. 块级元素不能放在 &lt;p>里面：\n\n\t\t<p><ol><li></li></ol></p> —— 错\n\t\t<p><div></div></p> —— 错\n\n3. 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：\n\n\t\th1、h2、h3、h4、h5、h6、p、dt\n\n4. li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：\n\n\tli 和 div 标 签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都 可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大 滴……\n\n5. 块级元素与块级元素并列、内嵌元素与内嵌元素并列：\n\n\t\t<div><h2></h2><p></p></div> —— 对\n\t\t<div><a href=”#”></a><span></span></div> —— 对\n\t\t<div><h2></h2><span></span></div> —— 错\n\n# 参考文章：\n\nhttp://blog.csdn.net/sykent/article/details/7738408\nhttp://www.jb51.net/web/218553.html\nhttp://www.5icool.org/a/201308/a2081.html","slug":"块级元素和内联元素","published":1,"updated":"2016-07-28T13:15:11.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmnu003x1kvs4q9srywj","content":"<h1 id=\"块级元素和内联元素的定义\"><a href=\"#块级元素和内联元素的定义\" class=\"headerlink\" title=\"块级元素和内联元素的定义\"></a>块级元素和内联元素的定义</h1><p>Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the ‘display’ property make an element block-level: ‘block’, ‘list-item’, and ‘table’.</p>\n<p>Inline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the ‘display’ property make an element inline-level: ‘inline’, ‘inline-table’, and ‘inline-block’. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context.<br><a id=\"more\"></a></p>\n<h1 id=\"常见的块级元素和内联元素\"><a href=\"#常见的块级元素和内联元素\" class=\"headerlink\" title=\"常见的块级元素和内联元素\"></a>常见的块级元素和内联元素</h1><p>块级元素列表</p>\n<pre><code>&lt;address&gt;    定义地址\n&lt;caption&gt;    定义表格标题\n&lt;dd&gt;    定义列表中定义条目\n&lt;div&gt;    定义文档中的分区或节\n&lt;dl&gt;    定义列表\n&lt;dt&gt;    定义列表中的项目\n&lt;fieldset&gt;    定义一个框架集\n&lt;form&gt;    创建 HTML 表单\n&lt;h1&gt;    定义最大的标题\n&lt;h2&gt;    定义副标题\n&lt;h3&gt;    定义标题\n&lt;h4&gt;    定义标题\n&lt;h5&gt;    定义标题\n&lt;h6&gt;    定义最小的标题\n&lt;hr&gt;    创建一条水平线\n&lt;legend&gt;    元素为 fieldset 元素定义标题\n&lt;li&gt;    标签定义列表项目\n&lt;noframes&gt;    为那些不支持框架的浏览器显示文本，于 frameset 元素内部\n&lt;noscript&gt;    定义在脚本未被执行时的替代内容\n&lt;ol&gt;    定义有序列表\n&lt;ul&gt;    定义无序列表\n&lt;p&gt;    标签定义段落\n&lt;pre&gt;    定义预格式化的文本\n&lt;table&gt;    标签定义 HTML 表格\n&lt;tbody&gt;    标签表格主体（正文）\n&lt;td&gt;    表格中的标准单元格\n&lt;tfoot&gt;    定义表格的页脚（脚注或表注）\n&lt;th&gt;    定义表头单元格\n&lt;thead&gt;    标签定义表格的表头\n&lt;tr&gt;    定义表格中的行\n</code></pre><p>行内元素列表</p>\n<pre><code>&lt;a&gt;    标签可定义锚\n&lt;abbr&gt;    表示一个缩写形式\n&lt;acronym&gt;    定义只取首字母缩写\n&lt;b&gt;    字体加粗\n&lt;bdo&gt;    可覆盖默认的文本方向\n&lt;big&gt;    大号字体加粗\n&lt;br&gt;    换行\n&lt;cite&gt;    引用进行定义\n&lt;code&gt;    定义计算机代码文本\n&lt;dfn&gt;    定义一个定义项目\n&lt;em&gt;    定义为强调的内容\n&lt;i&gt;    斜体文本效果\n&lt;img&gt;    向网页中嵌入一幅图像\n&lt;input&gt;    输入框\n&lt;kbd&gt;    定义键盘文本\n&lt;label&gt;    标签为 input 元素定义标注（标记）\n&lt;q&gt;    定义短的引用\n&lt;samp&gt;    定义样本文本\n&lt;select&gt;    创建单选或多选菜单\n&lt;small&gt;    呈现小号字体效果\n&lt;span&gt;    组合文档中的行内元素\n&lt;strong&gt;    语气更强的强调的内容\n&lt;sub&gt;    定义下标文本\n&lt;sup&gt;    定义上标文本\n&lt;textarea&gt;    多行的文本输入控件\n&lt;tt&gt;    打字机或者等宽的文本效果\n&lt;var&gt;    定义变量\n</code></pre><p>可变元素列表–可变元素为根据上下文语境决定该元素为块元素或者内联元素</p>\n<pre><code>&lt;button&gt;    按钮\n&lt;del&gt;    定义文档中已被删除的文本\n&lt;iframe&gt;    创建包含另外一个文档的内联框架（即行内框架）\n&lt;ins&gt;    标签定义已经被插入文档中的文本\n&lt;map&gt;    客户端图像映射（即热区）\n&lt;object&gt;    object对象\n&lt;script&gt;    客户端脚本\n</code></pre><h1 id=\"块级元素和行内元素的区别\"><a href=\"#块级元素和行内元素的区别\" class=\"headerlink\" title=\"块级元素和行内元素的区别\"></a>块级元素和行内元素的区别</h1><ol>\n<li>块级元素各占一行，垂直排列，行内元素水平排列</li>\n<li>块级元素可以包含行内元素，行内元素不能包含块级元素</li>\n<li>行内元素无法设置宽度和高度，无法设置margin-top和margin-bottom,无法设置padding-top和padding-bottom</li>\n</ol>\n<h1 id=\"html标签的嵌套规则\"><a href=\"#html标签的嵌套规则\" class=\"headerlink\" title=\"html标签的嵌套规则\"></a>html标签的嵌套规则</h1><ol>\n<li><p>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素：</p>\n<pre><code>&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; —— 对\n&lt;a href=”#”&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; —— 对\n&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; —— 错\n</code></pre></li>\n<li><p>块级元素不能放在 &lt;p&gt;里面：</p>\n<pre><code>&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; —— 错\n&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; —— 错\n</code></pre></li>\n<li><p>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：</p>\n<pre><code>h1、h2、h3、h4、h5、h6、p、dt\n</code></pre></li>\n<li><p>li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：</p>\n<p> li 和 div 标 签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都 可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大 滴……</p>\n</li>\n<li><p>块级元素与块级元素并列、内嵌元素与内嵌元素并列：</p>\n<pre><code>&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; —— 对\n&lt;div&gt;&lt;a href=”#”&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; —— 对\n&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; —— 错\n</code></pre></li>\n</ol>\n<h1 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h1><p><a href=\"http://blog.csdn.net/sykent/article/details/7738408\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sykent/article/details/7738408</a><br><a href=\"http://www.jb51.net/web/218553.html\" target=\"_blank\" rel=\"external\">http://www.jb51.net/web/218553.html</a><br><a href=\"http://www.5icool.org/a/201308/a2081.html\" target=\"_blank\" rel=\"external\">http://www.5icool.org/a/201308/a2081.html</a></p>\n","excerpt":"<h1 id=\"块级元素和内联元素的定义\"><a href=\"#块级元素和内联元素的定义\" class=\"headerlink\" title=\"块级元素和内联元素的定义\"></a>块级元素和内联元素的定义</h1><p>Block-level elements are those elements of the source document that are formatted visually as blocks (e.g., paragraphs). The following values of the ‘display’ property make an element block-level: ‘block’, ‘list-item’, and ‘table’.</p>\n<p>Inline-level elements are those elements of the source document that do not form new blocks of content; the content is distributed in lines (e.g., emphasized pieces of text within a paragraph, inline images, etc.). The following values of the ‘display’ property make an element inline-level: ‘inline’, ‘inline-table’, and ‘inline-block’. Inline-level elements generate inline-level boxes, which are boxes that participate in an inline formatting context.<br>","more":"</p>\n<h1 id=\"常见的块级元素和内联元素\"><a href=\"#常见的块级元素和内联元素\" class=\"headerlink\" title=\"常见的块级元素和内联元素\"></a>常见的块级元素和内联元素</h1><p>块级元素列表</p>\n<pre><code>&lt;address&gt;    定义地址\n&lt;caption&gt;    定义表格标题\n&lt;dd&gt;    定义列表中定义条目\n&lt;div&gt;    定义文档中的分区或节\n&lt;dl&gt;    定义列表\n&lt;dt&gt;    定义列表中的项目\n&lt;fieldset&gt;    定义一个框架集\n&lt;form&gt;    创建 HTML 表单\n&lt;h1&gt;    定义最大的标题\n&lt;h2&gt;    定义副标题\n&lt;h3&gt;    定义标题\n&lt;h4&gt;    定义标题\n&lt;h5&gt;    定义标题\n&lt;h6&gt;    定义最小的标题\n&lt;hr&gt;    创建一条水平线\n&lt;legend&gt;    元素为 fieldset 元素定义标题\n&lt;li&gt;    标签定义列表项目\n&lt;noframes&gt;    为那些不支持框架的浏览器显示文本，于 frameset 元素内部\n&lt;noscript&gt;    定义在脚本未被执行时的替代内容\n&lt;ol&gt;    定义有序列表\n&lt;ul&gt;    定义无序列表\n&lt;p&gt;    标签定义段落\n&lt;pre&gt;    定义预格式化的文本\n&lt;table&gt;    标签定义 HTML 表格\n&lt;tbody&gt;    标签表格主体（正文）\n&lt;td&gt;    表格中的标准单元格\n&lt;tfoot&gt;    定义表格的页脚（脚注或表注）\n&lt;th&gt;    定义表头单元格\n&lt;thead&gt;    标签定义表格的表头\n&lt;tr&gt;    定义表格中的行\n</code></pre><p>行内元素列表</p>\n<pre><code>&lt;a&gt;    标签可定义锚\n&lt;abbr&gt;    表示一个缩写形式\n&lt;acronym&gt;    定义只取首字母缩写\n&lt;b&gt;    字体加粗\n&lt;bdo&gt;    可覆盖默认的文本方向\n&lt;big&gt;    大号字体加粗\n&lt;br&gt;    换行\n&lt;cite&gt;    引用进行定义\n&lt;code&gt;    定义计算机代码文本\n&lt;dfn&gt;    定义一个定义项目\n&lt;em&gt;    定义为强调的内容\n&lt;i&gt;    斜体文本效果\n&lt;img&gt;    向网页中嵌入一幅图像\n&lt;input&gt;    输入框\n&lt;kbd&gt;    定义键盘文本\n&lt;label&gt;    标签为 input 元素定义标注（标记）\n&lt;q&gt;    定义短的引用\n&lt;samp&gt;    定义样本文本\n&lt;select&gt;    创建单选或多选菜单\n&lt;small&gt;    呈现小号字体效果\n&lt;span&gt;    组合文档中的行内元素\n&lt;strong&gt;    语气更强的强调的内容\n&lt;sub&gt;    定义下标文本\n&lt;sup&gt;    定义上标文本\n&lt;textarea&gt;    多行的文本输入控件\n&lt;tt&gt;    打字机或者等宽的文本效果\n&lt;var&gt;    定义变量\n</code></pre><p>可变元素列表–可变元素为根据上下文语境决定该元素为块元素或者内联元素</p>\n<pre><code>&lt;button&gt;    按钮\n&lt;del&gt;    定义文档中已被删除的文本\n&lt;iframe&gt;    创建包含另外一个文档的内联框架（即行内框架）\n&lt;ins&gt;    标签定义已经被插入文档中的文本\n&lt;map&gt;    客户端图像映射（即热区）\n&lt;object&gt;    object对象\n&lt;script&gt;    客户端脚本\n</code></pre><h1 id=\"块级元素和行内元素的区别\"><a href=\"#块级元素和行内元素的区别\" class=\"headerlink\" title=\"块级元素和行内元素的区别\"></a>块级元素和行内元素的区别</h1><ol>\n<li>块级元素各占一行，垂直排列，行内元素水平排列</li>\n<li>块级元素可以包含行内元素，行内元素不能包含块级元素</li>\n<li>行内元素无法设置宽度和高度，无法设置margin-top和margin-bottom,无法设置padding-top和padding-bottom</li>\n</ol>\n<h1 id=\"html标签的嵌套规则\"><a href=\"#html标签的嵌套规则\" class=\"headerlink\" title=\"html标签的嵌套规则\"></a>html标签的嵌套规则</h1><ol>\n<li><p>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素：</p>\n<pre><code>&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; —— 对\n&lt;a href=”#”&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; —— 对\n&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; —— 错\n</code></pre></li>\n<li><p>块级元素不能放在 &lt;p&gt;里面：</p>\n<pre><code>&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; —— 错\n&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; —— 错\n</code></pre></li>\n<li><p>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：</p>\n<pre><code>h1、h2、h3、h4、h5、h6、p、dt\n</code></pre></li>\n<li><p>li 内可以包含 div 标签 —— 这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：</p>\n<p> li 和 div 标 签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2 这样森严的等级制度^_^），要知道，li 标签连它的父级 ul 或者是 ol 都 可以容纳的，为什么有人会觉得 li 偏偏容纳不下一个 div 呢？别把 li 看得那么小气嘛，别看 li 长得挺瘦小，其实 li 的胸襟很大 滴……</p>\n</li>\n<li><p>块级元素与块级元素并列、内嵌元素与内嵌元素并列：</p>\n<pre><code>&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; —— 对\n&lt;div&gt;&lt;a href=”#”&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; —— 对\n&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; —— 错\n</code></pre></li>\n</ol>\n<h1 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h1><p><a href=\"http://blog.csdn.net/sykent/article/details/7738408\">http://blog.csdn.net/sykent/article/details/7738408</a><br><a href=\"http://www.jb51.net/web/218553.html\">http://www.jb51.net/web/218553.html</a><br><a href=\"http://www.5icool.org/a/201308/a2081.html\">http://www.5icool.org/a/201308/a2081.html</a></p>"},{"title":"配置Hexo","date":"2016-04-26T15:39:40.000Z","_content":"\nhexo要在node环境下部署。\n主要命令：\n1. 装置hexo\n\t\t$ npm install -g hexo\n2. 部署hexo\n\t\t$ hexo init\n<!-- more -->\n3. 生成html页面\n\t\t$ hexo g\n4. 运行测试环境\n\t\t$ hexo s\n接下来就可以在浏览器中输入 localhost:4000 查看了\n6. 安装部署插件\n\t\t$ npm install hexo-deployer-git--save\n7. 配置_config.yml文件，在文件的最后一行加上\n\t\tdeploy:\n\t\t  type: git\n \t\t repo: https://github.com/XXX/XXX.github.io.git(你的git地址)\n \t\t branch: master\n\n8. 部署\n\t\t$ hexo d\n\n另外type的值也有可能为github。\n\n当然，在进行第五步部署到git上之前，必须得有一个git地址。\n\n以下是有关Hexo配置的两篇文章\n\nhttp://blog.csdn.net/poem_of_sunshine/article/details/29369785/\n\nhttp://www.jianshu.com/p/465830080ea9","source":"_posts/配置Hexo.md","raw":"---\ntitle: 配置Hexo\ndate: 2016-04-26 23:39:40\ntags: \n  - hexo\n  - hexo配置\ncategories:\n  - 学习笔记\n  - hexo学习\n---\n\nhexo要在node环境下部署。\n主要命令：\n1. 装置hexo\n\t\t$ npm install -g hexo\n2. 部署hexo\n\t\t$ hexo init\n<!-- more -->\n3. 生成html页面\n\t\t$ hexo g\n4. 运行测试环境\n\t\t$ hexo s\n接下来就可以在浏览器中输入 localhost:4000 查看了\n6. 安装部署插件\n\t\t$ npm install hexo-deployer-git--save\n7. 配置_config.yml文件，在文件的最后一行加上\n\t\tdeploy:\n\t\t  type: git\n \t\t repo: https://github.com/XXX/XXX.github.io.git(你的git地址)\n \t\t branch: master\n\n8. 部署\n\t\t$ hexo d\n\n另外type的值也有可能为github。\n\n当然，在进行第五步部署到git上之前，必须得有一个git地址。\n\n以下是有关Hexo配置的两篇文章\n\nhttp://blog.csdn.net/poem_of_sunshine/article/details/29369785/\n\nhttp://www.jianshu.com/p/465830080ea9","slug":"配置Hexo","published":1,"updated":"2016-05-05T14:39:15.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmoa003z1kvs58wm031m","content":"<p>hexo要在node环境下部署。<br>主要命令：</p>\n<ol>\n<li>装置hexo<pre><code>$ npm install -g hexo\n</code></pre></li>\n<li>部署hexo<pre><code>$ hexo init\n</code></pre><a id=\"more\"></a></li>\n<li>生成html页面<pre><code>$ hexo g\n</code></pre></li>\n<li>运行测试环境<pre><code>$ hexo s\n</code></pre>接下来就可以在浏览器中输入 localhost:4000 查看了</li>\n<li>安装部署插件<pre><code>$ npm install hexo-deployer-git--save\n</code></pre></li>\n<li><p>配置_config.yml文件，在文件的最后一行加上</p>\n<pre><code>deploy:\n  type: git\n  repo: https://github.com/XXX/XXX.github.io.git(你的git地址)\n  branch: master\n</code></pre></li>\n<li><p>部署</p>\n<pre><code>$ hexo d\n</code></pre></li>\n</ol>\n<p>另外type的值也有可能为github。</p>\n<p>当然，在进行第五步部署到git上之前，必须得有一个git地址。</p>\n<p>以下是有关Hexo配置的两篇文章</p>\n<p><a href=\"http://blog.csdn.net/poem_of_sunshine/article/details/29369785/\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/poem_of_sunshine/article/details/29369785/</a></p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/465830080ea9</a></p>\n","excerpt":"<p>hexo要在node环境下部署。<br>主要命令：</p>\n<ol>\n<li>装置hexo<pre><code>$ npm install -g hexo\n</code></pre></li>\n<li>部署hexo<pre><code>$ hexo init\n</code></pre>","more":"</li>\n<li>生成html页面<pre><code>$ hexo g\n</code></pre></li>\n<li>运行测试环境<pre><code>$ hexo s\n</code></pre>接下来就可以在浏览器中输入 localhost:4000 查看了</li>\n<li>安装部署插件<pre><code>$ npm install hexo-deployer-git--save\n</code></pre></li>\n<li><p>配置_config.yml文件，在文件的最后一行加上</p>\n<pre><code>deploy:\n  type: git\n  repo: https://github.com/XXX/XXX.github.io.git(你的git地址)\n  branch: master\n</code></pre></li>\n<li><p>部署</p>\n<pre><code>$ hexo d\n</code></pre></li>\n</ol>\n<p>另外type的值也有可能为github。</p>\n<p>当然，在进行第五步部署到git上之前，必须得有一个git地址。</p>\n<p>以下是有关Hexo配置的两篇文章</p>\n<p><a href=\"http://blog.csdn.net/poem_of_sunshine/article/details/29369785/\">http://blog.csdn.net/poem_of_sunshine/article/details/29369785/</a></p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\">http://www.jianshu.com/p/465830080ea9</a></p>"},{"title":"hexo生成的页面部署到git上面时报错 FATAL spawn git ENOENT","date":"2016-04-27T15:58:01.000Z","_content":"报错信息\n\t\tFATAL spawn git ENOENT\n\t\tError: spawn git ENOENT\n\t\t<!-- more -->\n\t\t    at notFoundError (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-depl\n\t\toyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spaw\n\t\tn-async\\lib\\enoent.js:8:11)\n\t\t    at verifyENOENT (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-deplo\n\t\tyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spawn\n\t\t-async\\lib\\enoent.js:43:16)\n\t\t    at ChildProcess.cp.emit (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\he\n\t\txo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cro\n\t\tss-spawn-async\\lib\\enoent.js:30:19)\n\t\t    at Process.ChildProcess._handle.onexit (child_process.js:1074:12)\n解决方案：\n\n之前使用cmd执行的hexo d ,改成使用git bash执行就成功了。","source":"_posts/部署到git上面时报错.md","raw":"---\ntitle: hexo生成的页面部署到git上面时报错 FATAL spawn git ENOENT\ndate: 2016-04-27 23:58:01\ntags: \n  - hexo部署\ncategories:\n  - 学习笔记\n  - hexo学习\n---\n报错信息\n\t\tFATAL spawn git ENOENT\n\t\tError: spawn git ENOENT\n\t\t<!-- more -->\n\t\t    at notFoundError (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-depl\n\t\toyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spaw\n\t\tn-async\\lib\\enoent.js:8:11)\n\t\t    at verifyENOENT (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-deplo\n\t\tyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spawn\n\t\t-async\\lib\\enoent.js:43:16)\n\t\t    at ChildProcess.cp.emit (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\he\n\t\txo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cro\n\t\tss-spawn-async\\lib\\enoent.js:30:19)\n\t\t    at Process.ChildProcess._handle.onexit (child_process.js:1074:12)\n解决方案：\n\n之前使用cmd执行的hexo d ,改成使用git bash执行就成功了。","slug":"部署到git上面时报错","published":1,"updated":"2016-05-05T14:38:59.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmoa00421kvstfjiembm","content":"<p>报错信息<br>        FATAL spawn git ENOENT<br>        Error: spawn git ENOENT<br>        <a id=\"more\"></a><br>            at notFoundError (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-depl<br>        oyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spaw<br>        n-async\\lib\\enoent.js:8:11)<br>            at verifyENOENT (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-deplo<br>        yer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spawn<br>        -async\\lib\\enoent.js:43:16)<br>            at ChildProcess.cp.emit (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\he<br>        xo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cro<br>        ss-spawn-async\\lib\\enoent.js:30:19)<br>            at Process.ChildProcess._handle.onexit (child_process.js:1074:12)<br>解决方案：</p>\n<p>之前使用cmd执行的hexo d ,改成使用git bash执行就成功了。</p>\n","excerpt":"<p>报错信息<br>        FATAL spawn git ENOENT<br>        Error: spawn git ENOENT<br>","more":"<br>            at notFoundError (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-depl<br>        oyer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spaw<br>        n-async\\lib\\enoent.js:8:11)<br>            at verifyENOENT (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\hexo-deplo<br>        yer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cross-spawn<br>        -async\\lib\\enoent.js:43:16)<br>            at ChildProcess.cp.emit (C:\\Users\\Administrator\\Desktop\\Hexo\\node_modules\\he<br>        xo-deployer-git\\node_modules\\hexo-util\\node_modules\\cross-spawn\\node_modules\\cro<br>        ss-spawn-async\\lib\\enoent.js:30:19)<br>            at Process.ChildProcess._handle.onexit (child_process.js:1074:12)<br>解决方案：</p>\n<p>之前使用cmd执行的hexo d ,改成使用git bash执行就成功了。</p>"},{"title":"jquery源码分析之isArraylike()","date":"2016-06-16T08:18:10.000Z","_content":"在js的学习中经常见到描述一个对象为类数组对象，那么到底什么样的对象可以称为类数组对象呢？\n\n类数组对象有两个要求：\n1. 对象有一个整数类型的length属性\n2. length属性的值大于对象中元素的最大索引\n<!-- more -->\n\njQuery源码中isArraylike(obj)方法，字面理解像是判断对象是否是类数组对象的，我们来看一下\n\n\tfunction isArraylike( obj ) {\n\n\t\t// Support: iOS 8.2 (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {//不能是函数或者window对象，因为这两者也有length属性\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.nodeType === 1 && length ) {//如果是元素节点且有length属性，则返回真。\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\n\tisWindow: function( obj ) {\n\t\t/* jshint eqeqeq: false */\n\t\treturn obj != null && obj == obj.window;\n\t}\n\n目前我的理解是这个方法中\n\n\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj //数组下标为数组对象的key\n\n这句代码是判断对象是否为类数组对象的，整个方法判断的是否是数组，类数组，带length的json，是的话就返回真\n\njquery对象本身就是类数组对象，含有连续的整型属性，length属性和大量的jquery方法。\n\n下面这篇文章写得不错，很详细\nhttp://blog.csdn.net/liangklfang/article/details/48657845","source":"_posts/类数组.md","raw":"---\ntitle:  jquery源码分析之isArraylike()\ndate: 2016-06-16 16:18:10\ntags:\n - jQuery源码\ncategories:\n - 学习笔记\n - 前端学习\n---\n在js的学习中经常见到描述一个对象为类数组对象，那么到底什么样的对象可以称为类数组对象呢？\n\n类数组对象有两个要求：\n1. 对象有一个整数类型的length属性\n2. length属性的值大于对象中元素的最大索引\n<!-- more -->\n\njQuery源码中isArraylike(obj)方法，字面理解像是判断对象是否是类数组对象的，我们来看一下\n\n\tfunction isArraylike( obj ) {\n\n\t\t// Support: iOS 8.2 (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = \"length\" in obj && obj.length,\n\t\t\ttype = jQuery.type( obj );\n\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {//不能是函数或者window对象，因为这两者也有length属性\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.nodeType === 1 && length ) {//如果是元素节点且有length属性，则返回真。\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\n\tisWindow: function( obj ) {\n\t\t/* jshint eqeqeq: false */\n\t\treturn obj != null && obj == obj.window;\n\t}\n\n目前我的理解是这个方法中\n\n\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj //数组下标为数组对象的key\n\n这句代码是判断对象是否为类数组对象的，整个方法判断的是否是数组，类数组，带length的json，是的话就返回真\n\njquery对象本身就是类数组对象，含有连续的整型属性，length属性和大量的jquery方法。\n\n下面这篇文章写得不错，很详细\nhttp://blog.csdn.net/liangklfang/article/details/48657845","slug":"类数组","published":1,"updated":"2016-07-19T15:13:53.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmoq00451kvsbjhr9osa","content":"<p>在js的学习中经常见到描述一个对象为类数组对象，那么到底什么样的对象可以称为类数组对象呢？</p>\n<p>类数组对象有两个要求：</p>\n<ol>\n<li>对象有一个整数类型的length属性</li>\n<li>length属性的值大于对象中元素的最大索引<a id=\"more\"></a>\n</li>\n</ol>\n<p>jQuery源码中isArraylike(obj)方法，字面理解像是判断对象是否是类数组对象的，我们来看一下</p>\n<pre><code>function isArraylike( obj ) {\n\n    // Support: iOS 8.2 (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn&apos;t used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = &quot;length&quot; in obj &amp;&amp; obj.length,\n        type = jQuery.type( obj );\n\n    if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) {//不能是函数或者window对象，因为这两者也有length属性\n        return false;\n    }\n\n    if ( obj.nodeType === 1 &amp;&amp; length ) {//如果是元素节点且有length属性，则返回真。\n        return true;\n    }\n\n    return type === &quot;array&quot; || length === 0 ||\n        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;\n}\n\nisWindow: function( obj ) {\n    /* jshint eqeqeq: false */\n    return obj != null &amp;&amp; obj == obj.window;\n}\n</code></pre><p>目前我的理解是这个方法中</p>\n<pre><code>typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj //数组下标为数组对象的key\n</code></pre><p>这句代码是判断对象是否为类数组对象的，整个方法判断的是否是数组，类数组，带length的json，是的话就返回真</p>\n<p>jquery对象本身就是类数组对象，含有连续的整型属性，length属性和大量的jquery方法。</p>\n<p>下面这篇文章写得不错，很详细<br><a href=\"http://blog.csdn.net/liangklfang/article/details/48657845\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liangklfang/article/details/48657845</a></p>\n","excerpt":"<p>在js的学习中经常见到描述一个对象为类数组对象，那么到底什么样的对象可以称为类数组对象呢？</p>\n<p>类数组对象有两个要求：</p>\n<ol>\n<li>对象有一个整数类型的length属性</li>\n<li>length属性的值大于对象中元素的最大索引","more":"</li>\n</ol>\n<p>jQuery源码中isArraylike(obj)方法，字面理解像是判断对象是否是类数组对象的，我们来看一下</p>\n<pre><code>function isArraylike( obj ) {\n\n    // Support: iOS 8.2 (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn&apos;t used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = &quot;length&quot; in obj &amp;&amp; obj.length,\n        type = jQuery.type( obj );\n\n    if ( type === &quot;function&quot; || jQuery.isWindow( obj ) ) {//不能是函数或者window对象，因为这两者也有length属性\n        return false;\n    }\n\n    if ( obj.nodeType === 1 &amp;&amp; length ) {//如果是元素节点且有length属性，则返回真。\n        return true;\n    }\n\n    return type === &quot;array&quot; || length === 0 ||\n        typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;\n}\n\nisWindow: function( obj ) {\n    /* jshint eqeqeq: false */\n    return obj != null &amp;&amp; obj == obj.window;\n}\n</code></pre><p>目前我的理解是这个方法中</p>\n<pre><code>typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj //数组下标为数组对象的key\n</code></pre><p>这句代码是判断对象是否为类数组对象的，整个方法判断的是否是数组，类数组，带length的json，是的话就返回真</p>\n<p>jquery对象本身就是类数组对象，含有连续的整型属性，length属性和大量的jquery方法。</p>\n<p>下面这篇文章写得不错，很详细<br><a href=\"http://blog.csdn.net/liangklfang/article/details/48657845\">http://blog.csdn.net/liangklfang/article/details/48657845</a></p>"},{"title":"广度优先遍历","date":"2016-06-18T16:09:05.000Z","_content":"二叉树的广度优先遍历\n<!-- more -->\n\n\tpublic void breadFirst(TreeNode root){\n\t\t\tQueue<TreeNode> queue = new ArrayDeque<TreeNode>();\n\t\t\tif(root!=null){\n\t\t\t\tqueue.add(root);\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tTreeNode p = queue.poll();\n\t\t\t\t\tSystem.out.print(p.val);\n\t\t\t\t\tif(p.left!=null){\n\t\t\t\t\t\tqueue.offer(p.left);\n\t\t\t\t\t}\n\t\t\t\t\tif(p.right!=null){\n\t\t\t\t\t\tqueue.offer(p.right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","source":"_posts/广度优先遍历.md","raw":"---\ntitle: 广度优先遍历\ndate: 2016-06-19 00:09:05\ntags: \n  - 数据结构\n  - 二叉树\n  - 广度优先遍历\ncategories:\n  - 学习笔记\n  - 数据结构\n---\n二叉树的广度优先遍历\n<!-- more -->\n\n\tpublic void breadFirst(TreeNode root){\n\t\t\tQueue<TreeNode> queue = new ArrayDeque<TreeNode>();\n\t\t\tif(root!=null){\n\t\t\t\tqueue.add(root);\n\t\t\t\twhile(!queue.isEmpty()){\n\t\t\t\t\tTreeNode p = queue.poll();\n\t\t\t\t\tSystem.out.print(p.val);\n\t\t\t\t\tif(p.left!=null){\n\t\t\t\t\t\tqueue.offer(p.left);\n\t\t\t\t\t}\n\t\t\t\t\tif(p.right!=null){\n\t\t\t\t\t\tqueue.offer(p.right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","slug":"广度优先遍历","published":1,"updated":"2016-06-18T16:11:22.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmoq004a1kvseehxhlqi","content":"<p>二叉树的广度优先遍历<br><a id=\"more\"></a></p>\n<pre><code>public void breadFirst(TreeNode root){\n        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();\n        if(root!=null){\n            queue.add(root);\n            while(!queue.isEmpty()){\n                TreeNode p = queue.poll();\n                System.out.print(p.val);\n                if(p.left!=null){\n                    queue.offer(p.left);\n                }\n                if(p.right!=null){\n                    queue.offer(p.right);\n                }\n            }\n        }\n    }\n</code></pre>","excerpt":"<p>二叉树的广度优先遍历<br>","more":"</p>\n<pre><code>public void breadFirst(TreeNode root){\n        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;TreeNode&gt;();\n        if(root!=null){\n            queue.add(root);\n            while(!queue.isEmpty()){\n                TreeNode p = queue.poll();\n                System.out.print(p.val);\n                if(p.left!=null){\n                    queue.offer(p.left);\n                }\n                if(p.right!=null){\n                    queue.offer(p.right);\n                }\n            }\n        }\n    }\n</code></pre>"},{"title":"jquery中的prop和attr","date":"2016-07-19T13:26:27.000Z","_content":"之前分析了HTML中的属性（property）和特性attribute，在jquery中也有两个类似的方法，prop()和attr(),那么这两个方法有什么区别呢？\n首先看下api中介绍的功能差别：\n\n prop(name|properties|key,value|fn)\n\n获取在匹配的元素集中的第一个元素的属性值。\n随着一些内置属性的DOM元素或window对象，如果试图将删除该属性，浏览器可能会产生错误。jQuery第一次分配undefined值的属性，而忽略了浏览器生成的任何错误。\n\n源代码如下：\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, name, value, true, jQuery.prop );\n\t}\n\n attr(name|properties|key,value|fn)\n\n设置或返回被选元素的属性值。\n\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, name, value, true, jQuery.attr );\n\t}\n\n两者的差别在于\njQuery.access()的最后一个参数。来看一下jQuery.access()的实现\n\n\t// Mutifunctional method to get and set values to a collection\n\t\t// The value/s can optionally be executed if it's a function\n\t\taccess: function( elems, key, value, exec, fn, pass ) {\n\t\t\tvar length = elems.length;\n\n\t\t\t// Setting many attributes\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\tfor ( var k in key ) {\n\t\t\t\t\tjQuery.access( elems, k, key[k], exec, fn, value );\n\t\t\t\t}\n\t\t\t\treturn elems;\n\t\t\t}\n\n\t\t\t// Setting one attribute\n\t\t\tif ( value !== undefined ) {\n\t\t\t\t// Optionally, function values get executed if exec is true\n\t\t\t\texec = !pass && exec && jQuery.isFunction(value);\n\n\t\t\t\tfor ( var i = 0; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n\t\t\t\t}\n\n\t\t\t\treturn elems;\n\t\t\t}\n\n\t\t\t// Getting an attribute\n\t\t\treturn length ? fn( elems[0], key ) : undefined;\n\t\t}\n这个方法首先判断key是不是object，如果是，则遍历object中的每个key，对每个key执行access方法。\n其次，判断value是否给定，如果给定，则为set操作\n判断value是不是函数，如果是则exec为true，否则为false，即如果value不是函数则直接赋值，如果value为函数则要先执行函数。\n","source":"_drafts/jquery中的prop和attr.md","raw":"---\ntitle: jquery中的prop和attr\ndate: 2016-07-19 21:26:27\ntags: \n  - jquery\ncategories:\n  - 学习笔记\n  - 前端学习\n---\n之前分析了HTML中的属性（property）和特性attribute，在jquery中也有两个类似的方法，prop()和attr(),那么这两个方法有什么区别呢？\n首先看下api中介绍的功能差别：\n\n prop(name|properties|key,value|fn)\n\n获取在匹配的元素集中的第一个元素的属性值。\n随着一些内置属性的DOM元素或window对象，如果试图将删除该属性，浏览器可能会产生错误。jQuery第一次分配undefined值的属性，而忽略了浏览器生成的任何错误。\n\n源代码如下：\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, name, value, true, jQuery.prop );\n\t}\n\n attr(name|properties|key,value|fn)\n\n设置或返回被选元素的属性值。\n\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, name, value, true, jQuery.attr );\n\t}\n\n两者的差别在于\njQuery.access()的最后一个参数。来看一下jQuery.access()的实现\n\n\t// Mutifunctional method to get and set values to a collection\n\t\t// The value/s can optionally be executed if it's a function\n\t\taccess: function( elems, key, value, exec, fn, pass ) {\n\t\t\tvar length = elems.length;\n\n\t\t\t// Setting many attributes\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\tfor ( var k in key ) {\n\t\t\t\t\tjQuery.access( elems, k, key[k], exec, fn, value );\n\t\t\t\t}\n\t\t\t\treturn elems;\n\t\t\t}\n\n\t\t\t// Setting one attribute\n\t\t\tif ( value !== undefined ) {\n\t\t\t\t// Optionally, function values get executed if exec is true\n\t\t\t\texec = !pass && exec && jQuery.isFunction(value);\n\n\t\t\t\tfor ( var i = 0; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n\t\t\t\t}\n\n\t\t\t\treturn elems;\n\t\t\t}\n\n\t\t\t// Getting an attribute\n\t\t\treturn length ? fn( elems[0], key ) : undefined;\n\t\t}\n这个方法首先判断key是不是object，如果是，则遍历object中的每个key，对每个key执行access方法。\n其次，判断value是否给定，如果给定，则为set操作\n判断value是不是函数，如果是则exec为true，否则为false，即如果value不是函数则直接赋值，如果value为函数则要先执行函数。\n","slug":"jquery中的prop和attr","published":0,"updated":"2016-07-19T15:12:41.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"citn0kmoq004d1kvsng1ubk8f","content":"<p>之前分析了HTML中的属性（property）和特性attribute，在jquery中也有两个类似的方法，prop()和attr(),那么这两个方法有什么区别呢？<br>首先看下api中介绍的功能差别：</p>\n<p> prop(name|properties|key,value|fn)</p>\n<p>获取在匹配的元素集中的第一个元素的属性值。<br>随着一些内置属性的DOM元素或window对象，如果试图将删除该属性，浏览器可能会产生错误。jQuery第一次分配undefined值的属性，而忽略了浏览器生成的任何错误。</p>\n<p>源代码如下：</p>\n<pre><code>prop: function( name, value ) {\n    return jQuery.access( this, name, value, true, jQuery.prop );\n}\n</code></pre><p> attr(name|properties|key,value|fn)</p>\n<p>设置或返回被选元素的属性值。</p>\n<pre><code>attr: function( name, value ) {\n    return jQuery.access( this, name, value, true, jQuery.attr );\n}\n</code></pre><p>两者的差别在于<br>jQuery.access()的最后一个参数。来看一下jQuery.access()的实现</p>\n<pre><code>// Mutifunctional method to get and set values to a collection\n    // The value/s can optionally be executed if it&apos;s a function\n    access: function( elems, key, value, exec, fn, pass ) {\n        var length = elems.length;\n\n        // Setting many attributes\n        if ( typeof key === &quot;object&quot; ) {\n            for ( var k in key ) {\n                jQuery.access( elems, k, key[k], exec, fn, value );\n            }\n            return elems;\n        }\n\n        // Setting one attribute\n        if ( value !== undefined ) {\n            // Optionally, function values get executed if exec is true\n            exec = !pass &amp;&amp; exec &amp;&amp; jQuery.isFunction(value);\n\n            for ( var i = 0; i &lt; length; i++ ) {\n                fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n            }\n\n            return elems;\n        }\n\n        // Getting an attribute\n        return length ? fn( elems[0], key ) : undefined;\n    }\n</code></pre><p>这个方法首先判断key是不是object，如果是，则遍历object中的每个key，对每个key执行access方法。<br>其次，判断value是否给定，如果给定，则为set操作<br>判断value是不是函数，如果是则exec为true，否则为false，即如果value不是函数则直接赋值，如果value为函数则要先执行函数。</p>\n","excerpt":"","more":"<p>之前分析了HTML中的属性（property）和特性attribute，在jquery中也有两个类似的方法，prop()和attr(),那么这两个方法有什么区别呢？<br>首先看下api中介绍的功能差别：</p>\n<p> prop(name|properties|key,value|fn)</p>\n<p>获取在匹配的元素集中的第一个元素的属性值。<br>随着一些内置属性的DOM元素或window对象，如果试图将删除该属性，浏览器可能会产生错误。jQuery第一次分配undefined值的属性，而忽略了浏览器生成的任何错误。</p>\n<p>源代码如下：</p>\n<pre><code>prop: function( name, value ) {\n    return jQuery.access( this, name, value, true, jQuery.prop );\n}\n</code></pre><p> attr(name|properties|key,value|fn)</p>\n<p>设置或返回被选元素的属性值。</p>\n<pre><code>attr: function( name, value ) {\n    return jQuery.access( this, name, value, true, jQuery.attr );\n}\n</code></pre><p>两者的差别在于<br>jQuery.access()的最后一个参数。来看一下jQuery.access()的实现</p>\n<pre><code>// Mutifunctional method to get and set values to a collection\n    // The value/s can optionally be executed if it&apos;s a function\n    access: function( elems, key, value, exec, fn, pass ) {\n        var length = elems.length;\n\n        // Setting many attributes\n        if ( typeof key === &quot;object&quot; ) {\n            for ( var k in key ) {\n                jQuery.access( elems, k, key[k], exec, fn, value );\n            }\n            return elems;\n        }\n\n        // Setting one attribute\n        if ( value !== undefined ) {\n            // Optionally, function values get executed if exec is true\n            exec = !pass &amp;&amp; exec &amp;&amp; jQuery.isFunction(value);\n\n            for ( var i = 0; i &lt; length; i++ ) {\n                fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n            }\n\n            return elems;\n        }\n\n        // Getting an attribute\n        return length ? fn( elems[0], key ) : undefined;\n    }\n</code></pre><p>这个方法首先判断key是不是object，如果是，则遍历object中的每个key，对每个key执行access方法。<br>其次，判断value是否给定，如果给定，则为set操作<br>判断value是不是函数，如果是则exec为true，否则为false，即如果value不是函数则直接赋值，如果value为函数则要先执行函数。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"citn0kmgw000i1kvsypnp99m2","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmhc000p1kvst2kx6ocs"},{"post_id":"citn0kmgw000i1kvsypnp99m2","category_id":"citn0kmgf000f1kvs6x5r6umt","_id":"citn0kmhc000u1kvs95ffy9k2"},{"post_id":"citn0kmg000081kvspdlau59q","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmhs000x1kvstbmjrp82"},{"post_id":"citn0kmg000081kvspdlau59q","category_id":"citn0kmgf000f1kvs6x5r6umt","_id":"citn0kmhs00111kvsq4wbx3y4"},{"post_id":"citn0kmf400021kvszzu7s1vi","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmi800131kvsnvi7idqk"},{"post_id":"citn0kmf400021kvszzu7s1vi","category_id":"citn0kmgf000f1kvs6x5r6umt","_id":"citn0kmi800161kvs0y8zeamn"},{"post_id":"citn0kmhc000t1kvsspi695xq","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmin001a1kvscgfc9aya"},{"post_id":"citn0kmhc000t1kvsspi695xq","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmj3001e1kvssbqefnwo"},{"post_id":"citn0kmgf000d1kvsv9qb4f3l","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmj3001h1kvs04h5ew9y"},{"post_id":"citn0kmgf000d1kvsv9qb4f3l","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmji001l1kvsmu7yqoyx"},{"post_id":"citn0kmhc000w1kvsttc3acwd","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmji001o1kvsi74i1v70"},{"post_id":"citn0kmhc000w1kvsttc3acwd","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmji001s1kvs5csybcpo"},{"post_id":"citn0kmhs00101kvsr6u8n6ft","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmjy001w1kvskntzfgs7"},{"post_id":"citn0kmhs00101kvsr6u8n6ft","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmjy00201kvs4q2ey4zf"},{"post_id":"citn0kmfk00071kvsqgu63x5g","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmke00231kvsb81fwmoc"},{"post_id":"citn0kmfk00071kvsqgu63x5g","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmke00251kvs605v838w"},{"post_id":"citn0kmi800121kvsjf7gj0ml","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmkt00281kvsic6agv4b"},{"post_id":"citn0kmi800121kvsjf7gj0ml","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmkt002c1kvsanh2x8sj"},{"post_id":"citn0kmgf000e1kvsjotm0jx0","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmkt002g1kvsrufz2z63"},{"post_id":"citn0kmgf000e1kvsjotm0jx0","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kml9002j1kvs1fungiep"},{"post_id":"citn0kmin00191kvs50s60icw","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kml9002m1kvsooyg1tt9"},{"post_id":"citn0kmin00191kvs50s60icw","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmlo002q1kvscq61571v"},{"post_id":"citn0kmgw000j1kvsgz91mosl","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmm4002s1kvshr0m0dq9"},{"post_id":"citn0kmgw000j1kvsgz91mosl","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmm4002v1kvszjd7eyuc"},{"post_id":"citn0kmgw000m1kvs68fpiqwp","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmmk002y1kvszjshlkmw"},{"post_id":"citn0kmgw000m1kvs68fpiqwp","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmmk00311kvshvngib1v"},{"post_id":"citn0kmji001n1kvsgkvx1bk4","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmmk00351kvs6kivkx7h"},{"post_id":"citn0kmji001n1kvsgkvx1bk4","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmmz00371kvsv2cjkmcj"},{"post_id":"citn0kmji001r1kvstvljrgai","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmmz003b1kvsigjo850c"},{"post_id":"citn0kmji001r1kvstvljrgai","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmmz003e1kvshwvrl3ya"},{"post_id":"citn0kmi800151kvsm0irmf59","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmnf003j1kvsqvo243tn"},{"post_id":"citn0kmi800151kvsm0irmf59","category_id":"citn0kmji001q1kvs1pq6qucx","_id":"citn0kmnf003m1kvsvt30c5o2"},{"post_id":"citn0kmjy001v1kvsofb7sh9c","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmnu003p1kvshkhu4p73"},{"post_id":"citn0kmjy001v1kvsofb7sh9c","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmnu003s1kvsf5fy0pg8"},{"post_id":"citn0kmin001d1kvspdolai7x","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmnu003v1kvsdrqfucj6"},{"post_id":"citn0kmin001d1kvspdolai7x","category_id":"citn0kmjy001y1kvs3zf2acm9","_id":"citn0kmnu003y1kvs463pcdr3"},{"post_id":"citn0kmke00221kvsnds21kt0","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmoa00401kvs4s665rop"},{"post_id":"citn0kmke00221kvsnds21kt0","category_id":"citn0kmjy001y1kvs3zf2acm9","_id":"citn0kmoa00431kvsfpjqvm34"},{"post_id":"citn0kmke00241kvsz2jwr427","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmoq00471kvsvx30zmrd"},{"post_id":"citn0kmke00241kvsz2jwr427","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmoq004b1kvsh5cbfgun"},{"post_id":"citn0kmj3001g1kvsbu1cv36k","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmoq004e1kvstirqdccf"},{"post_id":"citn0kmj3001g1kvsbu1cv36k","category_id":"citn0kmjy001y1kvs3zf2acm9","_id":"citn0kmoq004i1kvsnod9b7qh"},{"post_id":"citn0kmkt002b1kvso500jldo","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp5004j1kvsy5aouedw"},{"post_id":"citn0kmkt002b1kvso500jldo","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmp5004k1kvs6ferd429"},{"post_id":"citn0kmkt002f1kvswdzwng9t","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp5004n1kvspcy5yd4l"},{"post_id":"citn0kmkt002f1kvswdzwng9t","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmp5004p1kvs34dtiboo"},{"post_id":"citn0kmjy001z1kvsrk2ytl24","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp5004r1kvs557aj8fp"},{"post_id":"citn0kmjy001z1kvsrk2ytl24","category_id":"citn0kmkt002d1kvstonuir2v","_id":"citn0kmp5004t1kvs5vlsynkd"},{"post_id":"citn0kml9002l1kvsvg9n4yb1","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp5004v1kvsx2rr1mio"},{"post_id":"citn0kml9002l1kvsvg9n4yb1","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmp5004x1kvsg65uxl6b"},{"post_id":"citn0kmlo002r1kvs56q2onbx","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp5004z1kvs85m9qlxc"},{"post_id":"citn0kmlo002r1kvs56q2onbx","category_id":"citn0kmlo002p1kvshyzdxpi7","_id":"citn0kmp500511kvsyq78um9z"},{"post_id":"citn0kmkt002i1kvsn2z0dold","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp500531kvsxfbongc9"},{"post_id":"citn0kmkt002i1kvsn2z0dold","category_id":"citn0kmlo002p1kvshyzdxpi7","_id":"citn0kmp500551kvshgit97hl"},{"post_id":"citn0kmm4002u1kvsy0us8asg","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmp500561kvsmkxpjcn1"},{"post_id":"citn0kmm4002u1kvsy0us8asg","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmp500581kvse2h46dfx"},{"post_id":"citn0kmm4002x1kvssm83pfj6","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl00591kvs03umf5vv"},{"post_id":"citn0kmm4002x1kvssm83pfj6","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmpl005b1kvs0j2tbg1c"},{"post_id":"citn0kmmk00301kvsh7h54gbl","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl005d1kvs0b4vyl4w"},{"post_id":"citn0kmmk00301kvsh7h54gbl","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmpl005g1kvskx6udiqw"},{"post_id":"citn0kmmk00361kvso0mqs34a","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl005i1kvs2zfqo7bu"},{"post_id":"citn0kmmk00361kvso0mqs34a","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmpl005k1kvsgn2wkt4q"},{"post_id":"citn0kmmk00341kvssg7dpew1","category_id":"citn0kmmz00391kvsc0rkr2vx","_id":"citn0kmpl005l1kvs2j0d8qjp"},{"post_id":"citn0kmmz003d1kvsodo875qd","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl005m1kvs0i09f7b3"},{"post_id":"citn0kmmz003d1kvsodo875qd","category_id":"citn0kmji001q1kvs1pq6qucx","_id":"citn0kmpl005p1kvs3fm8rwxn"},{"post_id":"citn0kmnf003l1kvsqsmz2z83","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl005r1kvs9sxy6shy"},{"post_id":"citn0kmnf003l1kvsqsmz2z83","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmpl005t1kvssh3x8kcf"},{"post_id":"citn0kmmz003a1kvsheu9tze3","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmpl005u1kvstq6nil14"},{"post_id":"citn0kmmz003a1kvsheu9tze3","category_id":"citn0kmnf003i1kvsif1yi9jo","_id":"citn0kmpl005w1kvs56gewrui"},{"post_id":"citn0kmnf003o1kvsm99ecmyo","category_id":"citn0kmmz00391kvsc0rkr2vx","_id":"citn0kmpl005x1kvs0avhaepr"},{"post_id":"citn0kmnu003r1kvsw5d361gp","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq0005z1kvs6b6kpimg"},{"post_id":"citn0kmnu003r1kvsw5d361gp","category_id":"citn0kmlo002p1kvshyzdxpi7","_id":"citn0kmq000611kvs7iv11dnj"},{"post_id":"citn0kmnu003u1kvss2equvi7","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq000641kvset7aqr6j"},{"post_id":"citn0kmnu003u1kvss2equvi7","category_id":"citn0kmji001q1kvs1pq6qucx","_id":"citn0kmq000661kvse83hblqj"},{"post_id":"citn0kmnu003x1kvs4q9srywj","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq000691kvsyfuspnzp"},{"post_id":"citn0kmnu003x1kvs4q9srywj","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmq0006b1kvsv0xir33x"},{"post_id":"citn0kmoq00451kvsbjhr9osa","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq0006d1kvs2381eay6"},{"post_id":"citn0kmoq00451kvsbjhr9osa","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmq0006e1kvsrdrq38nq"},{"post_id":"citn0kmoq004a1kvseehxhlqi","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq0006g1kvsf69lr6m4"},{"post_id":"citn0kmoq004a1kvseehxhlqi","category_id":"citn0kmjy001y1kvs3zf2acm9","_id":"citn0kmq0006i1kvs7urr2exv"},{"post_id":"citn0kmoa003z1kvs58wm031m","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq0006l1kvsr9kdfkmw"},{"post_id":"citn0kmoa003z1kvs58wm031m","category_id":"citn0kmoq00461kvsb3tpd9sd","_id":"citn0kmq0006n1kvsv4k8e7xp"},{"post_id":"citn0kmoq004d1kvsng1ubk8f","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmq0006o1kvs5xq1abuy"},{"post_id":"citn0kmoq004d1kvsng1ubk8f","category_id":"citn0kmhc000r1kvsk7tylaai","_id":"citn0kmq0006r1kvsh99n44oy"},{"post_id":"citn0kmoa00421kvstfjiembm","category_id":"citn0kmfk00061kvsi1xbpon6","_id":"citn0kmqg006t1kvsc5wvfew9"},{"post_id":"citn0kmoa00421kvstfjiembm","category_id":"citn0kmoq00461kvsb3tpd9sd","_id":"citn0kmqg006w1kvsy3hrribu"}],"PostTag":[{"post_id":"citn0kmf400021kvszzu7s1vi","tag_id":"citn0kmfk00051kvsq54v3k76","_id":"citn0kmgf000c1kvstii4j5gd"},{"post_id":"citn0kmfk00071kvsqgu63x5g","tag_id":"citn0kmg000091kvsa6vewn1y","_id":"citn0kmgw000h1kvsisk9gwwf"},{"post_id":"citn0kmg000081kvspdlau59q","tag_id":"citn0kmfk00051kvsq54v3k76","_id":"citn0kmgw000n1kvs7e5knjj3"},{"post_id":"citn0kmg000081kvspdlau59q","tag_id":"citn0kmgw000g1kvs0v9iqhbq","_id":"citn0kmhc000q1kvszc7ft7k8"},{"post_id":"citn0kmg0000a1kvsgvbmc3bm","tag_id":"citn0kmgw000l1kvsu0cku1sw","_id":"citn0kmhc000v1kvs94ssc8jn"},{"post_id":"citn0kmgf000d1kvsv9qb4f3l","tag_id":"citn0kmhc000s1kvsmfj5iu1c","_id":"citn0kmin00181kvs5g7lnfr3"},{"post_id":"citn0kmgf000d1kvsv9qb4f3l","tag_id":"citn0kmhs000z1kvsax5nty1q","_id":"citn0kmin001c1kvsjhi2e8mi"},{"post_id":"citn0kmgf000e1kvsjotm0jx0","tag_id":"citn0kmi800171kvscloztiej","_id":"citn0kmj3001i1kvslg386w2q"},{"post_id":"citn0kmgw000i1kvsypnp99m2","tag_id":"citn0kmfk00051kvsq54v3k76","_id":"citn0kmji001p1kvsphl9e82v"},{"post_id":"citn0kmgw000i1kvsypnp99m2","tag_id":"citn0kmj3001f1kvs5c5i59sd","_id":"citn0kmjy001t1kvsv1ymxxli"},{"post_id":"citn0kmgw000j1kvsgz91mosl","tag_id":"citn0kmji001m1kvs5r52ro5a","_id":"citn0kmjy001x1kvs1q5fj67d"},{"post_id":"citn0kmgw000m1kvs68fpiqwp","tag_id":"citn0kmhc000s1kvsmfj5iu1c","_id":"citn0kmkt002a1kvsrw94g51m"},{"post_id":"citn0kmgw000m1kvs68fpiqwp","tag_id":"citn0kmke00211kvso1tunvl7","_id":"citn0kmkt002e1kvsuzd7yisi"},{"post_id":"citn0kmhc000t1kvsspi695xq","tag_id":"citn0kmkt00291kvs77mjuna2","_id":"citn0kml9002k1kvs66f5cso7"},{"post_id":"citn0kmhc000w1kvsttc3acwd","tag_id":"citn0kmkt002h1kvs2due0xrf","_id":"citn0kmm4002w1kvsmqcwyogy"},{"post_id":"citn0kmhc000w1kvsttc3acwd","tag_id":"citn0kml9002n1kvsrvyatqtu","_id":"citn0kmmk002z1kvsmj6sf6od"},{"post_id":"citn0kmhs00101kvsr6u8n6ft","tag_id":"citn0kmm4002t1kvs2dpucsqz","_id":"citn0kmmk00331kvsaxfrmvy6"},{"post_id":"citn0kmi800121kvsjf7gj0ml","tag_id":"citn0kmmk00321kvsng5bqn45","_id":"citn0kmmz003c1kvs9bz809jg"},{"post_id":"citn0kmi800121kvsjf7gj0ml","tag_id":"citn0kmhc000s1kvsmfj5iu1c","_id":"citn0kmnf003f1kvskgmdyexp"},{"post_id":"citn0kmi800151kvsm0irmf59","tag_id":"citn0kmmz00381kvsjgkneywx","_id":"citn0kmnf003k1kvsp3oaqav2"},{"post_id":"citn0kmin00191kvs50s60icw","tag_id":"citn0kmhc000s1kvsmfj5iu1c","_id":"citn0kmnu003q1kvsr1rt0rir"},{"post_id":"citn0kmin00191kvs50s60icw","tag_id":"citn0kmnf003g1kvs66i2lc7d","_id":"citn0kmnu003t1kvs6uaaascv"},{"post_id":"citn0kmin001d1kvspdolai7x","tag_id":"citn0kmnf003n1kvsu1kiqh0p","_id":"citn0kmoa00441kvs1kxnatek"},{"post_id":"citn0kmin001d1kvspdolai7x","tag_id":"citn0kmnu003w1kvsfqf13q2c","_id":"citn0kmoq00481kvswzf1lz8k"},{"post_id":"citn0kmj3001g1kvsbu1cv36k","tag_id":"citn0kmoa00411kvsayjgvs1m","_id":"citn0kmoq004c1kvsugzgcn1e"},{"post_id":"citn0kmoq00451kvsbjhr9osa","tag_id":"citn0kmji001m1kvs5r52ro5a","_id":"citn0kmoq004g1kvsj7yxrwpd"},{"post_id":"citn0kmji001n1kvsgkvx1bk4","tag_id":"citn0kmoq00491kvsx0ght8n1","_id":"citn0kmp5004m1kvs4vnitkgn"},{"post_id":"citn0kmji001n1kvsgkvx1bk4","tag_id":"citn0kmoq004h1kvsew01yfjx","_id":"citn0kmp5004o1kvswcdj39lh"},{"post_id":"citn0kmji001r1kvstvljrgai","tag_id":"citn0kmp5004l1kvscbpovkss","_id":"citn0kmp5004s1kvs83gjt0pw"},{"post_id":"citn0kmjy001v1kvsofb7sh9c","tag_id":"citn0kmp5004q1kvscbld9l4a","_id":"citn0kmp5004w1kvsbjxj91vh"},{"post_id":"citn0kmjy001z1kvsrk2ytl24","tag_id":"citn0kmp5004u1kvs0dzqrsam","_id":"citn0kmp500501kvsogyi2hzb"},{"post_id":"citn0kmke00221kvsnds21kt0","tag_id":"citn0kmoa00411kvsayjgvs1m","_id":"citn0kmp500541kvslucow252"},{"post_id":"citn0kmke00241kvsz2jwr427","tag_id":"citn0kmp500521kvsycpyfph5","_id":"citn0kmpl005c1kvs1mm297vp"},{"post_id":"citn0kmke00241kvsz2jwr427","tag_id":"citn0kmp500571kvsoktdntev","_id":"citn0kmpl005e1kvs4n57jlmu"},{"post_id":"citn0kmkt002b1kvso500jldo","tag_id":"citn0kmpl005a1kvsavc8dvxm","_id":"citn0kmpl005h1kvsl7kivptc"},{"post_id":"citn0kmkt002f1kvswdzwng9t","tag_id":"citn0kmpl005f1kvsq1jf4ez2","_id":"citn0kmpl005o1kvs5d5j3c4i"},{"post_id":"citn0kmkt002f1kvswdzwng9t","tag_id":"citn0kmpl005j1kvswo0ds4j4","_id":"citn0kmpl005q1kvsle8opdu7"},{"post_id":"citn0kmkt002i1kvsn2z0dold","tag_id":"citn0kmpl005n1kvs42ut4l1u","_id":"citn0kmq000601kvsqgpr6jmp"},{"post_id":"citn0kmkt002i1kvsn2z0dold","tag_id":"citn0kmpl005s1kvsc0dl6qvc","_id":"citn0kmq000621kvsljrk9cjy"},{"post_id":"citn0kmkt002i1kvsn2z0dold","tag_id":"citn0kmpl005v1kvsobe3fbbz","_id":"citn0kmq000651kvswt8tpfmt"},{"post_id":"citn0kml9002l1kvsvg9n4yb1","tag_id":"citn0kmp5004u1kvs0dzqrsam","_id":"citn0kmq000671kvsnp9usiyg"},{"post_id":"citn0kml9002l1kvsvg9n4yb1","tag_id":"citn0kmji001m1kvs5r52ro5a","_id":"citn0kmq0006a1kvss4zaqien"},{"post_id":"citn0kmlo002r1kvs56q2onbx","tag_id":"citn0kmpl005n1kvs42ut4l1u","_id":"citn0kmq0006h1kvsi637o25v"},{"post_id":"citn0kmlo002r1kvs56q2onbx","tag_id":"citn0kmpl005s1kvsc0dl6qvc","_id":"citn0kmq0006j1kvsgwwhu7fs"},{"post_id":"citn0kmlo002r1kvs56q2onbx","tag_id":"citn0kmpl005v1kvsobe3fbbz","_id":"citn0kmq0006m1kvsquugtalv"},{"post_id":"citn0kmm4002u1kvsy0us8asg","tag_id":"citn0kmp5004u1kvs0dzqrsam","_id":"citn0kmq0006q1kvs706a9cxp"},{"post_id":"citn0kmm4002u1kvsy0us8asg","tag_id":"citn0kmq0006k1kvshbkm6r0f","_id":"citn0kmqg006s1kvsq8l1y1ni"},{"post_id":"citn0kmm4002x1kvssm83pfj6","tag_id":"citn0kmp5004u1kvs0dzqrsam","_id":"citn0kmqg006v1kvsbtvy5czz"},{"post_id":"citn0kmmk00301kvsh7h54gbl","tag_id":"citn0kmp5004u1kvs0dzqrsam","_id":"citn0kmqg006z1kvsc9e4ndlp"},{"post_id":"citn0kmmk00301kvsh7h54gbl","tag_id":"citn0kmqg006x1kvsin9cqvlu","_id":"citn0kmqg00701kvsh8sqmac3"},{"post_id":"citn0kmmk00341kvssg7dpew1","tag_id":"citn0kmqg006y1kvsahyq7zej","_id":"citn0kmqg00721kvsjj0zghdr"},{"post_id":"citn0kmmk00361kvso0mqs34a","tag_id":"citn0kmqg00711kvs4x9mb5ko","_id":"citn0kmqg00741kvsgx83kciv"},{"post_id":"citn0kmmz003a1kvsheu9tze3","tag_id":"citn0kmqg00731kvsa1hz8ulv","_id":"citn0kmqg00761kvsbahdx8tf"},{"post_id":"citn0kmmz003d1kvsodo875qd","tag_id":"citn0kmmz00381kvsjgkneywx","_id":"citn0kmqg00781kvs3z1o5ss2"},{"post_id":"citn0kmmz003d1kvsodo875qd","tag_id":"citn0kmqg00751kvsz3k3ouhm","_id":"citn0kmqg00791kvsfgt57jhp"},{"post_id":"citn0kmnf003l1kvsqsmz2z83","tag_id":"citn0kmhc000s1kvsmfj5iu1c","_id":"citn0kmqg007b1kvsns8r653p"},{"post_id":"citn0kmnf003l1kvsqsmz2z83","tag_id":"citn0kmqg00771kvs3rk5wcz4","_id":"citn0kmqg007c1kvsz7uwa570"},{"post_id":"citn0kmnf003o1kvsm99ecmyo","tag_id":"citn0kmqg007a1kvswrm5q3nv","_id":"citn0kmqg007e1kvs7ifudtgr"},{"post_id":"citn0kmnu003r1kvsw5d361gp","tag_id":"citn0kmpl005n1kvs42ut4l1u","_id":"citn0kmqw007i1kvstukja0er"},{"post_id":"citn0kmnu003r1kvsw5d361gp","tag_id":"citn0kmpl005s1kvsc0dl6qvc","_id":"citn0kmqw007j1kvs7sq6cikk"},{"post_id":"citn0kmnu003r1kvsw5d361gp","tag_id":"citn0kmqg007g1kvsvl1glv8r","_id":"citn0kmqw007l1kvs4by1b1x5"},{"post_id":"citn0kmnu003u1kvss2equvi7","tag_id":"citn0kmmz00381kvsjgkneywx","_id":"citn0kmqw007m1kvswzwj0x0s"},{"post_id":"citn0kmnu003u1kvss2equvi7","tag_id":"citn0kmqg00751kvsz3k3ouhm","_id":"citn0kmqw007o1kvs6a5438h3"},{"post_id":"citn0kmnu003x1kvs4q9srywj","tag_id":"citn0kmp5004q1kvscbld9l4a","_id":"citn0kmqw007p1kvs7ewgzmsy"},{"post_id":"citn0kmoa003z1kvs58wm031m","tag_id":"citn0kmqw007n1kvsf59ji5ra","_id":"citn0kmqw007s1kvs4is6nt1k"},{"post_id":"citn0kmoa003z1kvs58wm031m","tag_id":"citn0kmqw007q1kvsa1tcsl39","_id":"citn0kmqw007t1kvs0ddt5rs3"},{"post_id":"citn0kmoa00421kvstfjiembm","tag_id":"citn0kmqw007r1kvsk7osns91","_id":"citn0kmqw007v1kvsmsrtncka"},{"post_id":"citn0kmoq004a1kvseehxhlqi","tag_id":"citn0kmnf003n1kvsu1kiqh0p","_id":"citn0kmqw007y1kvssqruwwbd"},{"post_id":"citn0kmoq004a1kvseehxhlqi","tag_id":"citn0kmqw007u1kvsn9lxutdk","_id":"citn0kmqw007z1kvsd4mk8x9u"},{"post_id":"citn0kmoq004a1kvseehxhlqi","tag_id":"citn0kmqw007w1kvsz80lm411","_id":"citn0kmqw00801kvsmu3bwwmf"},{"post_id":"citn0kmoq004d1kvsng1ubk8f","tag_id":"citn0kmp5004l1kvscbpovkss","_id":"citn0kmqw00811kvsg2cuajs5"}],"Tag":[{"name":"数据挖掘","_id":"citn0kmfk00051kvsq54v3k76"},{"name":"javascript事件","_id":"citn0kmg000091kvsa6vewn1y"},{"name":"降维","_id":"citn0kmgw000g1kvs0v9iqhbq"},{"name":"mongodb","_id":"citn0kmgw000l1kvsu0cku1sw"},{"name":"css3","_id":"citn0kmhc000s1kvsmfj5iu1c"},{"name":"css3多列布局","_id":"citn0kmhs000z1kvsax5nty1q"},{"name":"BFC","_id":"citn0kmi800171kvscloztiej"},{"name":"算法评价指标","_id":"citn0kmj3001f1kvs5c5i59sd"},{"name":"jQuery源码","_id":"citn0kmji001m1kvs5r52ro5a"},{"name":"css3选择器","_id":"citn0kmke00211kvso1tunvl7"},{"name":"ajax","_id":"citn0kmkt00291kvs77mjuna2"},{"name":"CSS3","_id":"citn0kmkt002h1kvs2due0xrf"},{"name":"CSS3动画","_id":"citn0kml9002n1kvsrvyatqtu"},{"name":"cookie","_id":"citn0kmm4002t1kvs2dpucsqz"},{"name":"css3变形","_id":"citn0kmmk00321kvsng5bqn45"},{"name":"git","_id":"citn0kmmz00381kvsjgkneywx"},{"name":"FlexBox","_id":"citn0kmnf003g1kvs66i2lc7d"},{"name":"数据结构","_id":"citn0kmnf003n1kvsu1kiqh0p"},{"name":"二叉树遍历","_id":"citn0kmnu003w1kvsfqf13q2c"},{"name":"排序算法","_id":"citn0kmoa00411kvsayjgvs1m"},{"name":"css","_id":"citn0kmoq00491kvsx0ght8n1"},{"name":"inline-block","_id":"citn0kmoq004h1kvsew01yfjx"},{"name":"jquery","_id":"citn0kmp5004l1kvscbpovkss"},{"name":"html标签","_id":"citn0kmp5004q1kvscbld9l4a"},{"name":"javascript","_id":"citn0kmp5004u1kvs0dzqrsam"},{"name":"padding","_id":"citn0kmp500521kvsycpyfph5"},{"name":"margin","_id":"citn0kmp500571kvsoktdntev"},{"name":"JavaScript","_id":"citn0kmpl005a1kvsavc8dvxm"},{"name":"html5","_id":"citn0kmpl005f1kvsq1jf4ez2"},{"name":"pushState","_id":"citn0kmpl005j1kvswo0ds4j4"},{"name":"java","_id":"citn0kmpl005n1kvs42ut4l1u"},{"name":"stack","_id":"citn0kmpl005s1kvsc0dl6qvc"},{"name":"add and push","_id":"citn0kmpl005v1kvsobe3fbbz"},{"name":"this","_id":"citn0kmq0006k1kvshbkm6r0f"},{"name":"作用域","_id":"citn0kmqg006x1kvsin9cqvlu"},{"name":"旅游日记","_id":"citn0kmqg006y1kvsahyq7zej"},{"name":"-html","_id":"citn0kmqg00711kvs4x9mb5ko"},{"name":"数据库","_id":"citn0kmqg00731kvsa1hz8ulv"},{"name":"gitignore配置","_id":"citn0kmqg00751kvsz3k3ouhm"},{"name":"css3 transition","_id":"citn0kmqg00771kvs3rk5wcz4"},{"name":"随笔","_id":"citn0kmqg007a1kvswrm5q3nv"},{"name":"empty and isEmpty","_id":"citn0kmqg007g1kvsvl1glv8r"},{"name":"hexo","_id":"citn0kmqw007n1kvsf59ji5ra"},{"name":"hexo配置","_id":"citn0kmqw007q1kvsa1tcsl39"},{"name":"hexo部署","_id":"citn0kmqw007r1kvsk7osns91"},{"name":"二叉树","_id":"citn0kmqw007u1kvsn9lxutdk"},{"name":"广度优先遍历","_id":"citn0kmqw007w1kvsz80lm411"}]}}